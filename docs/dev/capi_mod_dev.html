

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CAPI Module Development Guide &mdash; AudioReach Documentation 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/audioreach.css?v=cd7bb9cf" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=f2a433a1"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Platform Porting Guide" href="plat_port.html" />
    <link rel="prev" title="Use Case Development Workflow" href="dev_workflow.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            AudioReach Documentation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../sdk_overview.html">AudioReach Project Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/index.html">AudioReach Designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">AudioReach APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">AudioReach Developer Guides</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="dev_workflow.html">Use Case Development Workflow</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">CAPI Module Development Guide</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#purpose">Purpose</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#functional-overview">Functional Overview</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module">Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#types-of-modules">Types of Modules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#life-cycle-of-a-capi">Life Cycle of a CAPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="#entry-point-functions">Entry Point Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-codes">Error Codes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#extensions">Extensions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-requirements">Other Requirements</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-integration">Module Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#workflow">Workflow</a></li>
<li class="toctree-l4"><a class="reference internal" href="#naming-convention-for-entry-point-functions">Naming Convention for Entry Point Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#functional-description">Functional Description</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#media-format">Media Format</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buffering">Buffering</a></li>
<li class="toctree-l4"><a class="reference internal" href="#debugging">Debugging</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-ports">Data Ports</a></li>
<li class="toctree-l4"><a class="reference internal" href="#get-and-set-parameters">Get and Set Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#events">Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="#process-call">Process Call</a></li>
<li class="toctree-l4"><a class="reference internal" href="#key-framework-extensions">Key Framework Extensions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#key-interface-extensions">Key Interface Extensions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#supporting-libraries">Supporting Libraries</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-flow-states">Data Flow States</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id4">Data Port Operation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#open">Open</a></li>
<li class="toctree-l4"><a class="reference internal" href="#start">Start</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stop">Stop</a></li>
<li class="toctree-l4"><a class="reference internal" href="#close">Close</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-flow-state-vs-port-state">Data Flow State vs Port State</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#intermodule-control-link-imcl">Intermodule Control Link (IMCL)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#intents">Intents</a></li>
<li class="toctree-l4"><a class="reference internal" href="#types-of-ports">Types of Ports</a></li>
<li class="toctree-l4"><a class="reference internal" href="#control-link-port-operations">Control Link Port Operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#types-of-messages">Types of Messages</a></li>
<li class="toctree-l4"><a class="reference internal" href="#typical-operation">Typical Operation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id6">Metadata</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#common-metadata-interfaces">Common Metadata Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#eos-metadata">EOS Metadata</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dfg-metadata">DFG Metadata</a></li>
<li class="toctree-l4"><a class="reference internal" href="#virtual-function-table">Virtual Function Table</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id8">Trigger Policy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#types-of-triggers">Types of Triggers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#triggerable-ports">Triggerable Ports</a></li>
<li class="toctree-l4"><a class="reference internal" href="#non-triggerable-ports-and-blocked-ports">Non-triggerable Ports and Blocked Ports</a></li>
<li class="toctree-l4"><a class="reference internal" href="#default-trigger-policy">Default Trigger Policy</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id11">Port Property Propagation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#real-time-flag">Real-time Flag</a></li>
<li class="toctree-l4"><a class="reference internal" href="#downstream-state">Downstream State</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interaction-between-port-properties-and-trigger-policy">Interaction Between Port Properties and Trigger Policy</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#frame-duration-and-threshold-related-extensions">Frame Duration and Threshold-related Extensions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#threshold-configuration">Threshold Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#container-frame-duration">Container Frame Duration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#container-processing-duration">Container Processing Duration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#data-duration-modifying-modules-and-container-handling">Data Duration Modifying Modules and Container Handling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dm-modules">DM Modules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dm-handling-in-are">DM handling in ARE</a></li>
<li class="toctree-l4"><a class="reference internal" href="#special-handling-for-fixed-output-mode-of-operation">Special handling for Fixed-Output mode of operation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#typical-recommendations">Typical Recommendations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#optimization">Optimization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#capi-interfaces">CAPI Interfaces</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id14">Virtual Function Table</a></li>
<li class="toctree-l4"><a class="reference internal" href="#process">process()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#end">end()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-param">set_param()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#get-param">get_param()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-properties">set_properties()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#get-properties">get_properties()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#capi-get-static-properties-f">capi_get_static_properties_f()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#capi-init-f">capi_init_f()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-types-and-payloads">Data Types and Payloads</a></li>
<li class="toctree-l4"><a class="reference internal" href="#capi-error-codes">Error Codes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#property-ids">Property IDs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id23">Events</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id24">Framework Extensions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#example-of-using-a-framework-extension">Example of Using a Framework Extension</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bluetooth-codec">Bluetooth Codec</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id26">Container Frame Duration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id28">Container Processing Duration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data-duration-modifying-modules">Data Duration Modifying Modules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ecns">ECNS</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multi-port-buffering">Multi-port Buffering</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pcm">PCM</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id34">Signal Triggered Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#async-signal-triggered-module">Async Signal Triggered Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#soft-timer">Soft Timer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synchronization">Synchronization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id41">Threshold Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id43">Trigger Policy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#voice-delivery">Voice Delivery</a></li>
<li class="toctree-l4"><a class="reference internal" href="#island-handling">Island Handling</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id51">Interface Extensions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#data-port-operations">Data Port Operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#imcl">IMCL</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id58">Metadata</a></li>
<li class="toctree-l4"><a class="reference internal" href="#path-delay">Path Delay</a></li>
<li class="toctree-l4"><a class="reference internal" href="#propagated-port-properties">Propagated Port Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#propagated-port-downstream-states">Propagated Port Downstream States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mimo-modules-process-states">MIMO Modules Process States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#duty-cycling-island">Duty Cycling Island</a></li>
<li class="toctree-l4"><a class="reference internal" href="#period-length">Period Length</a></li>
<li class="toctree-l4"><a class="reference internal" href="#signal-triggered-module-timestamp">Signal Triggered Module Timestamp</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#references">References</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#acronyms-and-terms">Acronyms and Terms</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="plat_port.html">Platform Porting Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="available_modules.html">Available Audio Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="adding_modules.html">How to add an Audio Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../platform/index.html">Platform Reference Guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">AudioReach Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">AudioReach Developer Guides</a></li>
      <li class="breadcrumb-item active">CAPI Module Development Guide</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/dev/capi_mod_dev.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="capi-module-development-guide">
<span id="capi-mod-dev-guide"></span><h1>CAPI Module Development Guide<a class="headerlink" href="#capi-module-development-guide" title="Link to this heading"></a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<section id="purpose">
<h3>Purpose<a class="headerlink" href="#purpose" title="Link to this heading"></a></h3>
<p>This document describes Common Audio Processor
Interface (CAPI) which is the interface between the AudioReach™
AudioReach Engine (ARE) and the audio signal processing
algorithms (such as pre/postprocessing, encoders, and decoders).</p>
</section>
</section>
<section id="functional-overview">
<h2>Functional Overview<a class="headerlink" href="#functional-overview" title="Link to this heading"></a></h2>
<p>Audio signal processing can be broadly categorized as follows:</p>
<ul class="simple">
<li><p>Audio processing</p></li>
<li><p>Encoder</p></li>
<li><p>Decoder</p></li>
</ul>
<p>For example, for audio recording, the mic data is first processed
with a high pass filter (HPF) to remove low frequencies such as AC
noise, followed by a multi-band filter to compensate for microphone
nonlinearities, followed by an Echo Canceller and Noise Suppression
(ECNS) algorithm, and so on. The data is finally encoded and stored
in a file. Similarly, in audio playback, data from a file or network
is decoded, postprocessed using effects/filters, and rendered.
Each filter, effect, and ECNS are referred to as <em>modules</em>. A series
of such modules forms a <em>graph</em>. Use the ARC to draw
graphs and associate them with high-level use cases.
Typically, the core library of such algorithms is developed
separately. To run the algorithms in the ARE, a CAPI wrapper is
written. CAPI abstracts the algorithms for the framework. A
CAPI-wrapped algorithm/functionality is referred to as a <em>CAPI
module</em> or simply as a module. In the ARE, modules are hosted by
<em>containers</em>, which provide the execution environment for the
modules.</p>
<p>Following is a typical folder structure for a module:</p>
<figure class="fig-center align-default" id="id73">
<a class="reference internal image-reference" href="../_images/capi_image1.png"><img alt="../_images/capi_image1.png" src="../_images/capi_image1.png" style="width: 4.02583in; height: 2.80750in;" />
</a>
<figcaption>
<p><span class="caption-text">Typical folder structure for a module</span><a class="headerlink" href="#id73" title="Link to this image"></a></p>
</figcaption>
</figure>
<section id="module">
<h3>Module<a class="headerlink" href="#module" title="Link to this heading"></a></h3>
<p>A module’s interface includes the following:</p>
<ul class="simple">
<li><p>Data ports</p>
<ul>
<li><p>Input and output ports, where each port can support multiple
channels</p></li>
<li><p>Zero to many input or output ports</p></li>
<li><p>Along with data, metadata is also transmitted through these ports</p></li>
</ul>
</li>
<li><p>Optional control ports for module-to-module communication</p></li>
<li><p>Interface (CAPI) with the framework (container)</p>
<ul>
<li><p>Properties, events, and extensions (which in turn contain
parameters and events)</p></li>
</ul>
</li>
<li><p>Interface with clients (HLOS or ARC platform)</p>
<ul>
<li><p>Parameters and events (annotated with h2xml tags)</p></li>
</ul>
</li>
</ul>
<p><strong>NOTE:</strong>
The h2xml tags are entered in the interface header file of the module. These tags are used to generate an XML file from the header file for importing the module into the ARC platform. For more information, see the ARC documentation.</p>
<p>In the framework, the containers assume that the entire CAPI module runs in the same thread as the container. If the module uses multithreading, it is the CAPI module’s responsibility to handle synchronization (for example, having set_param() done on the module in the main thread can cause corruption).</p>
<p>The following figure shows the interface view of a module.</p>
<figure class="fig-center align-default" id="id74">
<a class="reference internal image-reference" href="../_images/capi_image2.png"><img alt="../_images/capi_image2.png" src="../_images/capi_image2.png" style="width: 6.38000in; height: 3.88333in;" />
</a>
<figcaption>
<p><span class="caption-text">Interface view of a module</span><a class="headerlink" href="#id74" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="types-of-modules">
<h3>Types of Modules<a class="headerlink" href="#types-of-modules" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>Single input-single output (SISO) modules:</p>
<ul>
<li><p>Pre/postprocessing (PP) modules – PP algorithms such as filters,
equalizers, sample rate converters, echo cancelers, and so on</p></li>
<li><p>Encoders such as the AAC encoder</p></li>
<li><p>Decoders such as the AAC decoder</p></li>
<li><p>Packetizers such as the IEC 61937 packetizer</p></li>
<li><p>Depacketizers such as the IEC 61937 depacketizer</p></li>
<li><p>Converters such as the EAC3 format-to-AC3 format converter</p></li>
</ul>
</li>
<li><p>Source modules – Zero data input modules such as DMA source, DTMF
generator, and so on.</p></li>
<li><p>Sink modules – Zero data output modules such as DMA sink, DTMF
detector, and so on.</p></li>
<li><p>Multiple input-multiple output (MIMO) modules such as the
multi-write, multi-reader buffer, or the ECNS algorithm with
microphone and playback reference inputs as well as separate EC
output and NS output</p></li>
<li><p>Multiple input-single output (MISO) modules such as a mixer, EC with
only one output, and so on.</p></li>
<li><p>Single input-multiple output (SIMO) modules such as a splitter</p></li>
</ul>
<p>A <em>single-port module</em> refers to either a SISO module or a source
module with one output or a sink module with one input.</p>
<p>A <em>multi-port module</em> refers to all non-single-port modules. The
framework assumes no knowledge of routing inside multi-port modules.
A two-input (A and B), two-output (C and D) module can have any
possible data routing as shown in the following figure. Currently,
modules must have at least one input or output port, as illustrated
in the following figure.</p>
<figure class="fig-center align-default" id="id75">
<a class="reference internal image-reference" href="../_images/capi_image3.png"><img alt="../_images/capi_image3.png" src="../_images/capi_image3.png" style="width: 6.48167in; height: 1.25917in;" />
</a>
<figcaption>
<p><span class="caption-text">Input and output ports for a module</span><a class="headerlink" href="#id75" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Sample-based PP modules are PP modules that take N samples and
process/return the same number of samples in a process call (for
example, filters, equalizers). Fractional resampling modules or rate
matching do not belong to this category.
Simple PP modules are SISO PP modules. Includes all sample-based and
sample rate converters including fractional resampling, rate
matchers, and so on. <em>Simple</em> does not indicate that the algorithm
implemented in the module is trivial. It only means that the
framework interaction is simple.</p>
</section>
<section id="life-cycle-of-a-capi">
<h3>Life Cycle of a CAPI<a class="headerlink" href="#life-cycle-of-a-capi" title="Link to this heading"></a></h3>
<p>The following figure shows the life cycle of a CAPI. Highlighted
functions are used during run time. Except initialize and end, all
other functions can be called multiple times.</p>
<figure class="fig-center align-default" id="id76">
<a class="reference internal image-reference" href="../_images/capi_image4.png"><img alt="../_images/capi_image4.png" src="../_images/capi_image4.png" style="width: 6.63750in; height: 1.49833in;" />
</a>
<figcaption>
<p><span class="caption-text">Life cycle of a CAPI</span><a class="headerlink" href="#id76" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>CAPI has two static functions:</p>
<ul class="simple">
<li><p><a class="reference external" href="#typedef-capi-err-t-capi-get-static-properties-f-capi-proplist-t-init-set-proplist-capi-proplist-t-static-proplist">capi_get_static_properties_f()</a>
– Used to query properties such as memory required by the module,
stack size, required extensions, and so on.</p></li>
<li><p><a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a>
– Called to initialize the instance of the module.</p></li>
</ul>
<p>CAPI has the following dynamic functions handled through virtual function tables (vtables):</p>
<ul class="simple">
<li><p><a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a></p></li>
<li><p><a class="reference external" href="#capi-err-t-capi-vtbl-t-end-capi-t-pif">capi_vtbl_t::end()</a></p></li>
<li><p><a class="reference external" href="#capi-err-t-capi-vtbl-t-set-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr">capi_vtbl_t::set_param()</a></p></li>
<li><p><a class="reference external" href="#capi-err-t-capi-vtbl-t-get-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr">capi_vtbl_t::get_param()</a></p></li>
<li><p><a class="reference external" href="#capi-err-t-capi-vtbl-t-set-properties-capi-t-pif-capi-proplist-t-proplist-ptr">capi_vtbl_t::set_properties()</a></p></li>
<li><p><a class="reference external" href="#capi-err-t-capi-vtbl-t-get-properties-capi-t-pif-capi-proplist-t-proplist-ptr">capi_vtbl_t::get_properties()</a></p></li>
</ul>
<p>The vtable get_properties(), set_properties(), get_param(),
set_param(), and process() functions are used multiple times during
the module’s life. The
<a class="reference external" href="#typedef-capi-err-t-capi-get-static-properties-f-capi-proplist-t-init-set-proplist-capi-proplist-t-static-proplist">capi_get_static_properties_f()</a>
function can be called multiple times. The
<a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a>
and end() functions are called only once. CAPI can also raise events
using the callback function provided by framework during
<a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a>.</p>
<p>Following is an example of the life cycle of a CAPI.</p>
<ol class="arabic">
<li><p>The framework queries for memory required by the module by using <a class="reference external" href="#typedef-capi-err-t-capi-get-static-properties-f-capi-proplist-t-init-set-proplist-capi-proplist-t-static-proplist">capi_get_static_properties_f()</a> with the <a class="reference external" href="#_bookmark232">CAPI_INIT_MEMORY_REQUIREMENT</a> property ID.</p></li>
<li><p>The framework queries other static properties such as:</p>
<ul class="simple">
<li><p>Stack size (<a class="reference external" href="#_bookmark233">CAPI_STACK_SIZE</a>)</p></li>
<li><p>In-place processing capability
(<a class="reference external" href="#_bookmark235">CAPI_IS_INPLACE</a>)</p></li>
<li><p>Data buffering requirement
(<a class="reference external" href="#_bookmark236">CAPI_REQUIRES_DATA_BUFFERING</a>)</p></li>
<li><p>Supported interface extensions
(<a class="reference external" href="#_bookmark239">CAPI_INTERFACE_EXTENSIONS</a>)</p></li>
<li><p>Required framework extensions
(<a class="reference external" href="#_bookmark237">CAPI_NUM_NEEDED_FRAMEWORK_EXTENSIONS</a>,
<a class="reference external" href="#_bookmark238">CAPI_NEEDED_FRAMEWORK_EXTENSIONS</a>)</p></li>
<li><p>Supported interface extensions
(<a class="reference external" href="#_bookmark239">CAPI_INTERFACE_EXTENSIONS</a>)</p></li>
</ul>
<p>More properties will be added in future.</p>
<p>Queries can be performed for one or multiple properties at the time
depending on framework implementation. Typically, one property is
queried when the framework needs to know the return error code per
property.</p>
</li>
<li><p>The framework allocates memory and calls <a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a> on the CAPI.</p>
<ul class="simple">
<li><p>Now other properties are passed, such as the event callback
function (<a class="reference external" href="#_bookmark244">CAPI_EVENT_CALLBACK_INFO</a>
, the heap ID to be used for any
runtime memory allocations (<a class="reference external" href="#_bookmark246">CAPI_HEAP_ID</a>),
and so on. The same set of properties are also passed in
<a class="reference external" href="#typedef-capi-err-t-capi-get-static-properties-f-capi-proplist-t-init-set-proplist-capi-proplist-t-static-proplist">capi_get_static_properties_f()</a>.</p></li>
<li><p>CAPI returns the vtable.</p></li>
</ul>
<blockquote>
<div><p>Although the framework allocates memory before calling
<a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a>
on the module, be aware that modules are free to call malloc later,
depending on the requirements. The framework performs initial memory
allocation to host the instance structure.</p>
</div></blockquote>
</li>
<li><p>More setting and getting of properties and events can happen after <a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a> until the end of CAPI:</p>
<ul class="simple">
<li><p>Framework and interface extension-related properties.</p></li>
<li><p>The <a class="reference external" href="#capi-err-t-capi-vtbl-t-set-properties-capi-t-pif-capi-proplist-t-proplist-ptr">capi_vtbl_t::set_properties()</a> call for media format <a class="reference external" href="#_bookmark251">CAPI_INPUT_MEDIA_FORMAT_V2</a>.
A module can raise an output media format event if the output media format changes (<a class="reference external" href="#_bookmark341">CAPI_EVENT_OUTPUT_MEDIA_FORMAT_UPDATED_V2</a>).</p></li>
<li><p>Buffering-related properties such as <a class="reference external" href="#_bookmark262">CAPI_PORT_DATA_THRESHOLD</a> or <a class="reference external" href="#_bookmark336">CAPI_EVENT_PORT_DATA_THRESHOLD_CHANGE</a>.</p></li>
<li><p>Events such as KPPS (<a class="reference external" href="#_bookmark329">CAPI_EVENT_KPPS</a>), bandwidth (<a class="reference external" href="#_bookmark330">CAPI_EVENT_BANDWIDTH</a>), algorithmic delay (<a class="reference external" href="#_bookmark334">CAPI_EVENT_ALGORITHMIC_DELAY</a>), process state (<a class="reference external" href="#_bookmark333">CAPI_EVENT_PROCESS_STATE</a>), and so on.</p></li>
</ul>
</li>
<li><p>The <a class="reference external" href="#capi-err-t-capi-vtbl-t-set-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr">capi_vtbl_t::set_param()</a> and <a class="reference external" href="#capi-err-t-capi-vtbl-t-get-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr">capi_vtbl_t::get_param()</a> functions can also be called at any time after <a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a> until <a class="reference external" href="#capi-err-t-capi-vtbl-t-end-capi-t-pif">capi_vtbl_t::end()</a>.</p></li>
<li><p>The <a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a> function is called at runtime to process data.</p></li>
<li><p>Finally, the <a class="reference external" href="#capi-err-t-capi-vtbl-t-end-capi-t-pif">capi_vtbl_t::end()</a> function is called to destroy the CAPI module.</p></li>
</ol>
<p>The following table describes the differences between properties and parameters.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Property</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Defined by the core CAPI interface</p></td>
<td><p>Defined by the modules or CAPI framework and</p>
<p>interface extensions</p>
</td>
</tr>
<tr class="row-odd"><td><p>Applicable to all modules</p></td>
<td><p>Applicable only to the modules that define the</p>
<p>parameter or support the extension</p>
</td>
</tr>
<tr class="row-even"><td><p>Defines framework-module interaction</p></td>
<td><p>Typically, calibration- and configuration-related</p></td>
</tr>
<tr class="row-odd"><td><p>Module developers cannot add properties</p></td>
<td><p>Module developers can add parameters</p></td>
</tr>
<tr class="row-even"><td><p>Following functions are used:</p>
<p><a class="reference external" href="#typedef-capi-err-t-capi-get-static-properties-f-capi-proplist-t-init-set-proplist-capi-proplist-t-static-proplist">capi_get_static_properties_f()</a>,</p>
<p><a class="reference external" href="#capi-err-t-capi-vtbl-t-get-properties-capi-t-pif-capi-proplist-t-proplist-ptr">capi_vtbl_t::get_properties()</a>,</p>
<p><a class="reference external" href="#capi-err-t-capi-vtbl-t-set-properties-capi-t-pif-capi-proplist-t-proplist-ptr">capi_vtbl_t::set_properties()</a></p>
</td>
<td><p>Following functions are used:</p>
<p><a class="reference external" href="#capi-err-t-capi-vtbl-t-get-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr">capi_vtbl_t::get_param()</a> and</p>
<p><a class="reference external" href="#capi-err-t-capi-vtbl-t-set-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr">capi_vtbl_t::set_param()</a></p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="entry-point-functions">
<h3>Entry Point Functions<a class="headerlink" href="#entry-point-functions" title="Link to this heading"></a></h3>
<p>The CAPI entry point functions are
<a class="reference external" href="#typedef-capi-err-t-capi-get-static-properties-f-capi-proplist-t-init-set-proplist-capi-proplist-t-static-proplist">capi_get_static_properties_f()</a>
and
<a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a>.</p>
<p>The
<a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a>
function takes in a list of properties that can be used for
initialization of the module. The framework can use this list to set
the properties whose values are known during initialization, and the
module can use these properties to optimize its initialization
sequence. For example, the module can use the properties to
determine the size of some internal memory allocations, preventing
the need for freeing and reallocating the memory later.</p>
<p>The
<a class="reference external" href="#typedef-capi-err-t-capi-get-static-properties-f-capi-proplist-t-init-set-proplist-capi-proplist-t-static-proplist">capi_get_static_properties_f()</a>
function also takes in a list of
<a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a>
properties. The framework sends exactly the same properties as those
being sent for the
<a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a>
function. Thus, the module can correctly calculate the object size
that it returns.</p>
<p>Returning any error from
<a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a>
indicates that the module was not initialized. Therefore, a return
should only be done if the module cannot proceed because of an
error.
The module should return <a class="reference external" href="#define-capi-eok-0">CAPI_EOK</a> if an
unsupported property is set during
<a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a>.
If the module returns an error from
<a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a>,
it must ensure that all cleanup is performed because
<a class="reference external" href="#capi-err-t-capi-vtbl-t-end-capi-t-pif">capi_vtbl_t::end()</a>
will not be called.
Any static property can also be queried in
<a class="reference external" href="#capi-err-t-capi-vtbl-t-get-properties-capi-t-pif-capi-proplist-t-proplist-ptr">capi_vtbl_t::get_properties()</a>.
Modules must use common implementation for both get_properties and
<a class="reference external" href="#typedef-capi-err-t-capi-get-static-properties-f-capi-proplist-t-init-set-proplist-capi-proplist-t-static-proplist">capi_get_static_properties_f()</a>.
Static properties cannot rely on the instance memory of the CAPI.</p>
</section>
<section id="error-codes">
<h3>Error Codes<a class="headerlink" href="#error-codes" title="Link to this heading"></a></h3>
<p>The error codes returned by CAPI functions are interpreted as bit
fields. Multiple bits can be set at one time to indicate various
errors.
The <a class="reference external" href="#_bookmark224">CAPI_SET_ERROR</a> helper macro can be used to
set a bit in the error code, and the
<a class="reference external" href="#_bookmark226">CAPI_IS_ERROR_CODE_SET</a> helper macro can be
used to check if a particular bit is set in the error code.</p>
<section id="errors-while-setting-and-getting-properties">
<h4>Errors While Setting and Getting Properties<a class="headerlink" href="#errors-while-setting-and-getting-properties" title="Link to this heading"></a></h4>
<p>Functions that use the
<a class="reference external" href="#struct-capi-proplist-t">capi_proplist_t</a> structure can be
used to set or get multiple property values at one time. Errors that
occur when setting or getting a property from the list must be
handled in the following way:</p>
<ul class="simple">
<li><p>If the property is not supported by the module, the
<a class="reference external" href="#define-capi-eunsupported-uint32-t-1-2">CAPI_EUNSUPPORTED</a> flag
must be set in the error code and the actual_data_len field for
that property must be set to zero.</p></li>
<li><p>The rest of the properties must still be processed (rather than
exiting when an unsupported property is encountered).</p></li>
</ul>
</section>
</section>
<section id="extensions">
<h3>Extensions<a class="headerlink" href="#extensions" title="Link to this heading"></a></h3>
<p>CAPI provides a mechanism for extending the functionality of the
interface. The additional functionality is provided via framework
and interface extensions.</p>
<p>These extensions are typically defined using header files that are
included both by the module and the framework. Each extension is
identified with a globally unique identifier (GUID). The header file
then describes the behavior of the framework and module that use the
extensions. Any set parameter IDs, payloads, properties, events,
constant definitions, and function declarations required for an
extension are also present in the header file.</p>
<section id="framework-extensions">
<h4>Framework Extensions<a class="headerlink" href="#framework-extensions" title="Link to this heading"></a></h4>
<p>The framework uses
<a class="reference external" href="#typedef-capi-err-t-capi-get-static-properties-f-capi-proplist-t-init-set-proplist-capi-proplist-t-static-proplist">capi_get_static_properties_f()</a>
to query a module for the list of extensions that the framework
requires.</p>
<p>If the framework supports these extensions, it can create the module
and proceed. If not, the framework must send an error. Thus,
framework extensions are not optional.</p>
</section>
<section id="interface-extensions">
<h4>Interface Extensions<a class="headerlink" href="#interface-extensions" title="Link to this heading"></a></h4>
<p>The framework uses
<a class="reference external" href="#typedef-capi-err-t-capi-get-static-properties-f-capi-proplist-t-init-set-proplist-capi-proplist-t-static-proplist">capi_get_static_properties_f()</a>
to send a list of interface extensions that it supports to the
module. The module can then set flags to indicate the interface
extensions it is to use from this list.</p>
<p>If an interface extension is required by the module to operate, it
can send an error at this point. The framework then inspects the
list of interface extensions chosen by the module and, if it is
acceptable, creates the module. Thus, interface extensions are
optional.</p>
<p>An optional structure can be included with each interface extension
to negotiate more fine-grained support. The structure must be
defined in the interface extension header file.</p>
</section>
<section id="differences-between-framework-and-interface-extensions">
<h4>Differences Between Framework and Interface Extensions<a class="headerlink" href="#differences-between-framework-and-interface-extensions" title="Link to this heading"></a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Framework extension</strong></p></th>
<th class="head"><p><strong>Interface extension</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Defines a behavior that the module requires the</p>
<p>framework to support.</p>
</td>
<td><p>Can define a behavior for the framework, module,</p>
<p>or both.</p>
</td>
</tr>
<tr class="row-odd"><td><p>If a module requires a framework extension, it</p>
<p>cannot operate if the framework does not support</p>
<p>the framework extension.</p>
</td>
<td><p>Support can be negotiated between the framework</p>
<p>and the module. After negotiation, the framework</p>
<p>and module can determine if an acceptable</p>
<p>configuration is possible.</p>
</td>
</tr>
<tr class="row-even"><td><p>A framework extension is either supported by the</p>
<p>framework or not; there is no way to indicate</p>
<p>partial support.</p>
</td>
<td><p>An optional structure can be used to negotiate</p>
<p>more fine-grained capabilities.</p>
</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="other-requirements">
<h3>Other Requirements<a class="headerlink" href="#other-requirements" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>All functions must be re-entrant. This means that multiple instances
of the library are able to run simultaneously without any conflict.
All states are stored in the instance structure that is passed as the
first argument to all functions.</p></li>
<li><p>The pointer to the vtable of CAPI is required to be the first element
in a CAPI structure.</p></li>
<li><p>We recommend size checks in get and set parameters, and NULL checks
for stream data and buffers in process functions.</p></li>
</ul>
</section>
</section>
<section id="module-integration">
<h2>Module Integration<a class="headerlink" href="#module-integration" title="Link to this heading"></a></h2>
<section id="workflow">
<h3>Workflow<a class="headerlink" href="#workflow" title="Link to this heading"></a></h3>
<p>Below figure illustrates the module integration
workflow. Module ID and parameter IDs must use GUIDs. Each customer
is allotted a range from which to choose these IDs.</p>
<figure class="fig-center align-default" id="id77">
<a class="reference internal image-reference" href="../_images/capi_image5.png"><img alt="../_images/capi_image5.png" src="../_images/capi_image5.png" style="width: 753.1999999999999px; height: 320.59999999999997px;" />
</a>
<figcaption>
<p><span class="caption-text">Module integration workflow</span><a class="headerlink" href="#id77" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Refer to <a class="reference external" href="https://github.com/Audioreach/audioreach-engine?tab=readme-ov-file#adding-new-module">README</a> for more details.</p>
</section>
<section id="naming-convention-for-entry-point-functions">
<h3>Naming Convention for Entry Point Functions<a class="headerlink" href="#naming-convention-for-entry-point-functions" title="Link to this heading"></a></h3>
<p>You must define functions that follow the signature of the
<a class="reference external" href="#typedef-capi-err-t-capi-get-static-properties-f-capi-proplist-t-init-set-proplist-capi-proplist-t-static-proplist">capi_get_static_properties_f()</a>
and
<a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a>
definitions. Use these functions as entry point functions to create
an instance of the module using following naming convention:</p>
<ul class="simple">
<li><p>Your <a class="reference external" href="#typedef-capi-err-t-capi-get-static-properties-f-capi-proplist-t-init-set-proplist-capi-proplist-t-static-proplist">capi_get_static_properties_f()</a>  function variant must be named as follows: <em>&lt;</em>tag<em>&gt;</em>_get_static_properties_f(), where <em>&lt;</em>tag<em>&gt;</em> can be any string as long as the function name remains a valid C function name.</p></li>
<li><p>Your <a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a> function variant must be named as follows: <em>&lt;</em>tag<em>&gt;</em>_init, where <em>&lt;</em>tag<em>&gt;</em> must be the same string that is used as the tag in the name of the <a class="reference external" href="#typedef-capi-err-t-capi-get-static-properties-f-capi-proplist-t-init-set-proplist-capi-proplist-t-static-proplist">capi_get_static_properties_f()</a>   function variant.</p></li>
</ul>
<p>An example of a valid <em>&lt;</em>tag<em>&gt;</em> is volume_control. With this tag, the function names are volume_control_get_static_properties_f() and volume_control_init().</p>
<p>The <em>&lt;</em>tag<em>&gt;</em> used for naming the entry point functions is used to register the module with the Audio Module Data Base (AMDB) in the ARE.</p>
</section>
</section>
<section id="functional-description">
<h2>Functional Description<a class="headerlink" href="#functional-description" title="Link to this heading"></a></h2>
<section id="media-format">
<span id="id1"></span><h3>Media Format<a class="headerlink" href="#media-format" title="Link to this heading"></a></h3>
<p>The ARE handles a wide variety of media including fixed point PCM
data, raw compressed data (such as AAC bit stream), and so on. For
PCM data, additional attributes such as sampling rate and number
channels are encapsulated in the media format.</p>
<ul class="simple">
<li><p>Media format contains:</p>
<ul>
<li><p>Data format – Fixed point, packetized (such as IEC61937),
raw-compressed</p></li>
<li><p>For PCM or packetized data – Sample rate, channels, channel map,
bit width, and so on</p></li>
<li><p>Format ID for all data formats – Identifies whether data is PCM,
AAC, MP3, and so on</p></li>
</ul>
</li>
<li><p>ARE has no knowledge of the output format of the module. Modules must
implement the query
(<a class="reference external" href="#capi-err-t-capi-vtbl-t-get-properties-capi-t-pif-capi-proplist-t-proplist-ptr">capi_vtbl_t::get_properties()</a>)
and event.</p></li>
<li><p>Typically, before a
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
call is made, the ARE sets the valid input media format, and the
module must have raised the output media format (if not queried by
the ARE).</p></li>
<li><p><a class="reference external" href="#_bookmark251">CAPI_INPUT_MEDIA_FORMAT_V2</a> – Used by the ARE
to set the media format on an input data port. Data sent in a
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
call follows this media format. The ARE never uses this media format
for
<a class="reference external" href="#capi-err-t-capi-vtbl-t-get-properties-capi-t-pif-capi-proplist-t-proplist-ptr">capi_vtbl_t::get_properties()</a>.
Modules must ensure that the media format they receive is supported
(for example, some modules may not support 24-bit data or fractional
sample rates).</p></li>
<li><p><a class="reference external" href="#_bookmark267">CAPI_OUTPUT_MEDIA_FORMAT_V2</a> – Used by the ARE
to query the media format on an output data port. Data output by the
module in the
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
call follows this media format. It is never used for
<a class="reference external" href="#capi-err-t-capi-vtbl-t-set-properties-capi-t-pif-capi-proplist-t-proplist-ptr">capi_vtbl_t::set_properties</a>.
The ARE provides the buffers in a process() call per the media format
the module outputs.</p></li>
<li><p><a class="reference external" href="#_bookmark341">CAPI_EVENT_OUTPUT_MEDIA_FORMAT_UPDATED_V2</a> –
Used by a module to raise a media format event on an output data
port.</p></li>
</ul>
<p>We recommend using the v2 media format properties and events. The difference between v1 and v2 is that v1 supports a maximum of only 16 channels, whereas v2 supports an unlimited number of channels.</p>
<p>The following table provides a summary of which functions are used for media formats.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Media format</strong></p></th>
<th class="head"><p><strong>get_property()</strong></p></th>
<th class="head"><p><strong>set_property()</strong></p></th>
<th class="head"><p><strong>Event</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Input</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>Output</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
</tr>
</tbody>
</table>
<p>Typically, single-port modules are not informed of new connections
because they do not implement
<a class="reference external" href="#define-intf-extn-data-port-operation-0x0a001023">INTF_EXTN_DATA_PORT_OPERATION</a>.
The module is assumed to raise the media format, and then the port
is disconnected and reconnected. The module has no knowledge of
this. However, because port memories are recreated in the ARE,
previous media format information is lost. To know the media format,
the containers can query the media format from the modules.
Therefore, in the ARE, it is important to support both queries and
events for media formats.</p>
<section id="fixed-point">
<h4>Fixed Point<a class="headerlink" href="#fixed-point" title="Link to this heading"></a></h4>
<p>A bits_per_sample field determines the word size
(<a class="reference external" href="#struct-capi-standard-data-format-t">capi_standard_data_format_t</a>
and
<a class="reference external" href="#struct-capi-standard-data-format-v2-t">capi_standard_data_format_v2_t</a>).</p>
<p>Although bits_per_sample determines the word size, the actual
sample might be of equal or smaller width, which is determined by
the bit width. The bit width can be inferred from the Q factor. If
the Q factor is Q27, it stands for 24-bit data in 32-bit word.</p>
<p>However, to explicitly know the bit width, the PCM framework
extension
(<a class="reference external" href="#define-fwk-extn-pcm-param-id-media-format-extn-0x0a001001">FWK_EXTN_PCM_PARAM_ID_MEDIA_FORMAT_EXTN</a>)
must be used.</p>
<section id="interleaving">
<h5>Interleaving<a class="headerlink" href="#interleaving" title="Link to this heading"></a></h5>
<p>In interleaved and deinterleaved packed cases, the
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
call contains only one buffer per stream. In the deinterleaved
unpacked case, the process() call contains one buffer per channel
per stream. The following figure illustrates PCM interleaving and
deinterleaving.</p>
<figure class="fig-center align-default" id="id78">
<a class="reference internal image-reference" href="../_images/capi_image6.png"><img alt="../_images/capi_image6.png" src="../_images/capi_image6.png" style="width: 4.26000in; height: 4.50917in;" />
</a>
<figcaption>
<p><span class="caption-text">Interleaving and de-interleaving for PCM</span><a class="headerlink" href="#id78" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="channel-map-or-channel-type">
<h5>Channel Map or Channel Type<a class="headerlink" href="#channel-map-or-channel-type" title="Link to this heading"></a></h5>
<p>During playback, audio channels are routed to different speakers.
Each speaker has a designated location (for example, left, right,
center, and LFE). When different channels are processed and routed
in software, the speaker must identify the data to which a channel
is routed. Similarly, in the multichannel recording use case, mic
data can contain noise reference vs. primary signal.</p>
<p>Each channel has a channel type or map associated with it. With this
concept, there is no need to have a fixed order of channels in a
buffer. For example, the left channel is not required to be at first
position and the right channel at the second position. It is
sufficient to denote each position by channel type.</p>
<p>For example, some decoders might provide output in this order: L, R,
LFE, C, Ls, Rs. Others might provide output in this order: L, R, C,
LFE, Ls, Rs (C and LFE are reversed). If LFE is to be processed with
different filter coefficients, tuning a parameter on such a filter
will indicate the coefficient for each channel or a group of
channels.</p>
<p>Currently defined channel types mainly indicate speaker names. For
the mic path or for more speaker names, use custom channel maps
(like PCM_CUSTOM_CHANNEL_MAP_1). The system designer can assign
meaning based on product requirement.</p>
</section>
</section>
<section id="floating-point">
<h4>Floating Point<a class="headerlink" href="#floating-point" title="Link to this heading"></a></h4>
<p>The <a class="reference external" href="#_bookmark187">CAPI_FLOATING_POINT</a> data format is used
for floating point data.</p>
</section>
<section id="raw-compressed">
<h4>Raw Compressed<a class="headerlink" href="#raw-compressed" title="Link to this heading"></a></h4>
<p>The <a class="reference external" href="#_bookmark188">CAPI_RAW_COMPRESSED</a> data format is used for encoded data (for example, input of a decoder or output of an encoder).</p>
</section>
<section id="packetized-formats">
<h4>Packetized Formats<a class="headerlink" href="#packetized-formats" title="Link to this heading"></a></h4>
<p>CAPI supports various packetized formats such as IEC 61397, IEC 60958 nonlinear, DSD DOP, compressed-over-PCM (COP), and generic compressed. These formats also follow <a class="reference external" href="#struct-capi-standard-data-format-t">capi_standard_data_format_t</a> or
<a class="reference external" href="#struct-capi-standard-data-format-v2-t">capi_standard_data_format_v2_t</a> because the data looks like fixed point.</p>
</section>
<section id="deinterleaved-raw-compressed">
<h4>Deinterleaved Raw Compressed<a class="headerlink" href="#deinterleaved-raw-compressed" title="Link to this heading"></a></h4>
<p>The <a class="reference external" href="#_bookmark190">CAPI_DEINTERLEAVED_RAW_COMPRESSED</a> data
format is used to send different channels of encoded data in
separate buffers if required, e.g. left channel on one buffer and
right on another. This helps downstream modules handle left and
right channels separately.</p>
</section>
</section>
<section id="buffering">
<h3>Buffering<a class="headerlink" href="#buffering" title="Link to this heading"></a></h3>
<p>Buffering is dictated through
<a class="reference external" href="#_bookmark236">CAPI_REQUIRES_DATA_BUFFERING</a>,
<a class="reference external" href="#_bookmark262">CAPI_PORT_DATA_THRESHOLD</a>, and
<a class="reference external" href="#_bookmark336">CAPI_EVENT_PORT_DATA_THRESHOLD_CHANGE</a>.
A threshold is basically the buffer size in bytes per data port.
Examples:</p>
<ul class="simple">
<li><p>A module that can process any amount of data should return threshold
as 1 byte.</p></li>
<li><p>A fixed frame size module with 10 ms frame duration. At 48K, 2
channels, 2 bits per sample: 10 ∗ 48 ∗ 2 ∗ 2 = 1920 bytes threshold.</p></li>
<li><p>A fixed frame size module with 1024 sample frame width. At 48K, 2
channels, 2 bits per sample: 1024 ∗ 2 ∗ 2 = 4096 bytes threshold.</p></li>
<li><p>A decoder with a maximum input frame size of 8192 bytes.</p></li>
</ul>
<p>Both input and output ports can have their own thresholds. For example:</p>
<ul class="simple">
<li><p>Encoder input can be 2048 bytes and output can be 256 bytes.</p></li>
<li><p>A fixed frame size module with a 10 ms threshold at the input media
format (48K, 2 channels, 2 bits per sample) and output media format
(48K, 6 channels, 2 bits per sample) has an input threshold of 1920
and an output threshold of 11520 bytes.</p></li>
</ul>
<p>Different ports of a multiport module can have their own thresholds. For example:</p>
<ul class="simple">
<li><p>An EC module with 5 ms frame duration can have 16K, 2 channels, 2
bits per sample mic data and 48K, 2 channels, 2 bits per sample
playback reference. Thus, the first input has a threshold of 320
bytes and the second input has a threshold of 960 bytes.</p></li>
</ul>
<p>Typically, the worst-case frame size for decoders is the input and
output threshold. Unless data is processed, decoders cannot know the
required size and, to read data, a buffer is required.
A greater than 1 threshold can ensure that minimum samples (bytes)
are present in the input, and minimize the empty space available in
the output when <a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a> is called (depending on the <a class="reference external" href="#_bookmark236">CAPI_REQUIRES_DATA_BUFFERING</a> flag).</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Requires data buffering</strong></p></th>
<th class="head"><p><strong>Port threshold</strong></p></th>
<th class="head"><p><strong>Typical modules</strong></p></th>
<th class="head"><p><strong>Framework behavior</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>FALSE</p></td>
<td><p>1</p></td>
<td><p>Sample-based PP modules (N sample input produces N sample</p>
<p>output)</p>
</td>
<td><p>For PCM, the ARE ensures that when any  input is provided, the output has</p>
<p>sufficient space for that many samples of output.</p>
</td>
</tr>
<tr class="row-odd"><td><p>FALSE</p></td>
<td><p>&gt; 1</p></td>
<td><p>Encoders and fixed frame  size modules (EC that may have</p>
<p>fixed frame size such as 10 ms)</p>
</td>
<td><p>For PCM, assuming N is the input threshold and M is the output threshold,</p>
<p>the ARE ensures that when a module process is called, N samples are present</p>
<p>in the input, and M sample amount of space is available in the output.</p>
</td>
</tr>
<tr class="row-even"><td><p>TRUE</p></td>
<td><p>1</p></td>
<td><p>Resamplers (fractional), rate matching, buffering modules</p></td>
<td><p>The ARE can call the process function with any amount of input.</p>
<p>However, there are extensions available that can optimize the calls.</p>
</td>
</tr>
<tr class="row-odd"><td><p>TRUE</p></td>
<td><p>&gt; 1</p></td>
<td><p>Decoders, packetizers, depacketizers, and possibly encoders</p></td>
<td><p>The ARE can call the process function</p>
<p>with any amount of input.</p>
</td>
</tr>
</tbody>
</table>
<p>When the <a class="reference external" href="#_bookmark236">CAPI_REQUIRES_DATA_BUFFERING</a> flag is
FALSE, the same buffer can be reused for multiple modules because no
partial data will be left in those buffers after calling
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
on the module.
Setting the CAPI_REQUIRES_DATA_BUFFERING flag involves an extra
cost, so only use it when absolutely necessary.</p>
<section id="non-buffered-data-flow-model">
<h4>Non-buffered Data Flow Model<a class="headerlink" href="#non-buffered-data-flow-model" title="Link to this heading"></a></h4>
<p>In the non-buffered data flow model, the
<a class="reference external" href="#_bookmark236">CAPI_REQUIRES_DATA_BUFFERING</a> flag is set to
FALSE. The non-buffered data flow model is as follows:</p>
<ul class="simple">
<li><p>The framework must ensure that it provides the same number of samples
on every input port of the module. For compressed data, the same
number of bytes must be provided on every input port.</p></li>
<li><p>The number of output samples provided on every output port of the
module must be the same as the number of input samples. For
compressed data, the number of bytes on every port must be the same
as the number of input bytes. The framework code must ensure that
there is enough space in the output buffer.</p></li>
<li><p>The module must be able to handle any number of input samples (or
input bytes in the case of compressed data).</p></li>
</ul>
<p>This model incurs low overhead, so use it whenever possible. You can
also use this model for modules that perform processing in fixed
blocks of data (frames).</p>
</section>
<section id="buffered-data-flow-model">
<h4>Buffered Data Flow Model<a class="headerlink" href="#buffered-data-flow-model" title="Link to this heading"></a></h4>
<p>In the buffered data flow model, the
<a class="reference external" href="#_bookmark236">CAPI_REQUIRES_DATA_BUFFERING</a> flag is set to
TRUE. The buffered data flow model is as follows:</p>
<ul class="simple">
<li><p>The module must define a threshold in terms of the number of bytes
for every input and output port.</p></li>
</ul>
<p>This threshold for any port may be queried by the framework at any
time using the <a class="reference external" href="#_bookmark262">CAPI_PORT_DATA_THRESHOLD</a>
property. If the threshold changes, the module must raise the
<a class="reference external" href="#_bookmark336">CAPI_EVENT_PORT_DATA_THRESHOLD_CHANGE</a> event
for each port on which the threshold changed.</p>
<ul class="simple">
<li><p>For input ports, the threshold indicates the minimum amount of data
needed to guarantee that processing can be done. For example,
consider an input buffer with 100 bytes of data and a threshold of 25
bytes.</p>
<ul>
<li><p>If the module consumes more than 75 bytes, the amount of remaining
data in the input buffer will be less than its threshold.</p></li>
<li><p>When this occurs, the module can stop further processing and
return from
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>.</p></li>
</ul>
</li>
</ul>
<p>It is possible for the module to perform processing with a lesser
amount of data. For example, if the module performs decoding of
compressed data, this value is the worst-case compressed frame size.
The module can to perform decoding with lesser data if the actual
compressed frame size is smaller. In this case, it can continue
processing.</p>
<ul class="simple">
<li><p>For output ports, the threshold indicates the minimum amount of free
space required to guarantee that processing can be done.</p></li>
</ul>
<p>For example, consider an output buffer with a maximum size of 100
bytes and a threshold of 25 bytes. If the module produces more than
75 bytes of data, the remaining free space in the output buffer will
be less than the threshold. When this happens, the module can stop
further processing and return from the <a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>.</p>
<ul class="simple">
<li><p>The framework can provide input and output buffers of any size when calling <a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>.</p></li>
<li><p>When the <a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
call returns:</p>
<ul>
<li><p>The module must have consumed enough data so the amount of valid
data remaining in at least one input port is less than the
threshold for that port.</p></li>
<li><p>OR, the module must have produced enough data so the amount of
free space remaining in at least one output port is less than the
threshold for that port.</p></li>
</ul>
</li>
</ul>
<p>Following are examples of thresholds that can be provided:</p>
<ul class="simple">
<li><p>Decoders:</p>
<ul>
<li><p>Input threshold = the worst-case compressed frame size</p></li>
<li><p>Output threshold = the size of one uncompressed frame</p></li>
</ul>
</li>
<li><p>Encoders:</p>
<ul>
<li><p>Input threshold = the size of one uncompressed frame</p></li>
<li><p>Output threshold = the worst-case compressed frame size</p></li>
</ul>
</li>
<li><p>Sample rate converter that can work on an arbitrary number of
samples:</p>
<ul>
<li><p>Input threshold = 1</p></li>
<li><p>Output threshold = 1</p></li>
</ul>
</li>
</ul>
<p>This model incurs high overhead, so use it only when necessary.</p>
</section>
</section>
<section id="debugging">
<h3>Debugging<a class="headerlink" href="#debugging" title="Link to this heading"></a></h3>
<p>For debugging purposes, two properties are added in the ARE:</p>
<p><strong>CAPI_MODULE_INSTANCE_ID</strong>
Each module in a graph has a unique instance ID. This module
instance ID is assigned by the ARC platform and is provided to the
modules through this property at or immediately after <a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a>. The module ID is also provided here, although module ID-based logic
should not be introduced.</p>
<p><strong>CAPI_LOGGING_INFO</strong> Contains the log ID and a mask.
The log ID is unique to the module instance, and it contains bits
for identifying the container where the module runs. We recommend
that modules print debug messages with the log ID.
The mask identifies the 6 bits left for the module (this might
change in the future; hence, the mask provided must be used). When
EOS or some other discontinuity occurs, modules might increment
these 6 bits. If a module does file logging with the log ID as the
file name suffix, every discontinuity will generate a new file.</p>
<figure class="fig-center align-default" id="id79">
<a class="reference internal image-reference" href="../_images/capi_image7.png"><img alt="../_images/capi_image7.png" src="../_images/capi_image7.png" style="width: 5.75917in; height: 0.75750in;" />
</a>
<figcaption>
<p><span class="caption-text">Bit mask for the log ID</span><a class="headerlink" href="#id79" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="data-ports">
<h3>Data Ports<a class="headerlink" href="#data-ports" title="Link to this heading"></a></h3>
<p>There are different types of data ports:</p>
<ul class="simple">
<li><p>Labeled ports or static data ports – The module declares the port
IDs. For example, an EC module can label ports as mic input (<em>near
end</em> in a voice call) and playback reference input (<em>far end</em> in a
voice call).</p></li>
<li><p>Dynamic ports – The ARC platform assigns the port IDs externally.
For example, a mixer can support multiple inputs.</p></li>
</ul>
<p>The following limits apply to the number of ports:</p>
<ul class="simple">
<li><p>Module implementation might limit the maximum number of ports it can
support, or it might support an infinite number of ports.</p></li>
<li><p>When a module is placed in a graph, and depending on the maximum
number of concurrencies, there is a maximum number of ports.</p></li>
<li><p>Depending on actual active concurrencies, there is a specific number
of ports.</p></li>
</ul>
<p>The maximum number of ports possible in a given instance of a module
is communicated through <a class="reference external" href="#_bookmark245">CAPI_PORT_NUM_INFO</a>,
which is useful for memory allocations.
If a module can work with or without output ports, i.e., it can act
as a module with output ports or as a sink, then the module must
inform this to the framework when queried with property ID
<a class="reference external" href="#_bookmark241">CAPI_MIN_PORT_NUM_INFO</a> . By default, the
framework assumes the minimum number of output ports is 1. The same
applies for modules that can work both with or without input ports
(can act as source).</p>
<section id="port-indices-and-port-ids">
<h4>Port Indices and Port IDs<a class="headerlink" href="#port-indices-and-port-ids" title="Link to this heading"></a></h4>
<p>CAPI relies on port indices. For example, a
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
call uses arrays of stream data that are indexed by the port index.
For multi-port modules, port IDs are used in graph diagrams in the
ARC platform.
Although an index is sufficient for most modules, the index-port ID
mapping might be important in some cases. For example, a parameter
that includes a port ID might be exposed to the clients.
The
<a class="reference external" href="#define-intf-extn-data-port-operation-0x0a001023">INTF_EXTN_DATA_PORT_OPERATION</a>
interface extension can be used for getting port
ID-to-index mapping, and also to know when ports are opened, closed,
started, or stopped. For more details, see <a class="reference internal" href="#id4"><span class="std std-ref">Data Port Operation</span></a>.
Port indices are assigned by the framework. The maximum value of a
port index is less than the number in <a class="reference external" href="#_bookmark245">CAPI_PORT_NUM_INFO</a>.</p>
</section>
</section>
<section id="get-and-set-parameters">
<h3>Get and Set Parameters<a class="headerlink" href="#get-and-set-parameters" title="Link to this heading"></a></h3>
<p>A module must define IDs and payload structures for all the
parameters it supports. H2xml annotation is also required.</p>
<section id="alignment-packing-and-get-parameter-requirements">
<h4>Alignment, Packing, and Get Parameter Requirements<a class="headerlink" href="#alignment-packing-and-get-parameter-requirements" title="Link to this heading"></a></h4>
<p>Some module parameter payloads have substructures and variable
length arrays. For example:
struct_a { int num; struct_b arr[0]}
Where arr is of length num.
If the size of struct_b is not aligned to 4 bytes and it has a
4-byte element, some processors will crash due to misalignment. For
this reason, the ARC platform ensures that all substructures are
padded for 4-byte alignment so that arrays of such structures, or
alignment of another substructure following a structure, are not
broken.
What about 8-byte alignment? In the above example, 8-byte alignment
might also be required, but it is not supported. Eight-byte numbers
must be split into two 4-byte numbers.
For packing requirements, the module payloads can be manually packed
to the correct alignment (at least 4-byte). The ARC platform always
ensures packing, but manual packing helps with parsing inside the
modules.
For example:
struct {int8 a; int8 b;}
Must be manually padded as:
struct {int8 a; int8 b; int8 reserved1; int8 reserved2}</p>
</section>
<section id="get-parameter-requirements">
<h4>Get Parameter Requirements<a class="headerlink" href="#get-parameter-requirements" title="Link to this heading"></a></h4>
<p>When a client of the ARE calls the APM_CMD_GET_CFG API, it is
translated into the
<a class="reference external" href="#capi-err-t-capi-vtbl-t-get-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr">capi_vtbl_t::get_param()</a>
function on CAPI modules. The client does not know how much memory a
parameter requires when the parameter is of variable size.</p>
<p>The h2xmlp_maxSize annotation can be used for annotating parameter
size requirements for
<a class="reference external" href="#capi-err-t-capi-vtbl-t-get-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr">capi_vtbl_t::get_param()</a>.</p>
<p>The modules must implement the following: if the provided size is
not sufficient, the module must return the
<a class="reference external" href="#define-capi-eneedmore-uint32-t-1-4">CAPI_ENEEDMORE</a> error and
update the actual length with the required size (including the
memory required for alignment, if any).</p>
</section>
<section id="property-for-persistent-parameters">
<h4>Property for Persistent Parameters<a class="headerlink" href="#property-for-persistent-parameters" title="Link to this heading"></a></h4>
<p>Typically, when a set_param() is issued, the module copies the
payload. However, when a parameter’s payload (calibration) is huge,
copying data is not preferred. A module can define certain
parameters as persistent (via the h2xml tags in the header file)
and, when the set_param() is issued, the module can store the
pointer to the blob.
Before such a set_param() is done, a
<a class="reference external" href="#capi-err-t-capi-vtbl-t-set-properties-capi-t-pif-capi-proplist-t-proplist-ptr">capi_vtbl_t::set_properties()</a>
is done to indicate that the module must copy the pointer. If the
module does not expect the parameter to be persistent or vice versa,
an error might be thrown or the appropriate handling might be
implemented. For details, see
<a class="reference external" href="#_bookmark259">CAPI_PARAM_PERSISTENCE_INFO</a>.</p>
<p>Older modules are to return
<a class="reference external" href="#define-capi-eunsupported-uint32-t-1-2">CAPI_EUNSUPPORTED</a> for
unsupported properties; such errors are ignored. This ensures
backward compatibility.</p>
</section>
</section>
<section id="events">
<h3>Events<a class="headerlink" href="#events" title="Link to this heading"></a></h3>
<p>A mechanism is provided for the module to notify the framework of
events that occur. Events are identified by predefined event IDs.
The interface also describes the payload corresponding to each event
ID.
The module provides the following information to the framework when
the callback function is called:</p>
<ul class="simple">
<li><p>An opaque state token that is provided by the framework when the
module is created.</p></li>
<li><p>The event ID.</p></li>
<li><p>The port number associated with this event (optional).</p></li>
<li><p>A buffer containing the payload associated with this event. The
module must allocate the buffer, and it can free the buffer after the
callback function returns.</p></li>
</ul>
<p>All event IDs and their payloads are described in file <a class="reference internal" href="../api/spf_capi.html#capi-events-h"><span class="std std-ref">capi_events.h</span></a>.</p>
<p>Following is a typical call flow for raising events to the
framework.</p>
<figure class="fig-center align-default" id="id80">
<a class="reference internal image-reference" href="../_images/capi_image8.png"><img alt="../_images/capi_image8.png" src="../_images/capi_image8.png" style="width: 6.01490in; height: 3.97698in;" />
</a>
<figcaption>
<p><span class="caption-text">Typical call flow for raising events</span><a class="headerlink" href="#id80" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>In the diagram, two events are raised in a call to
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>.
The framework takes the appropriate action within the callback
function.
<strong>NOTE</strong> The module can raise an event in any of the CAPI calls from
<a class="reference external" href="#struct-capi-vtbl-t">capi_vtbl_t</a>: init(), get_properties(),
set_properties(), get_param(), set_param(), process(), and end().</p>
<section id="thread-safety">
<h4>Thread Safety<a class="headerlink" href="#thread-safety" title="Link to this heading"></a></h4>
<p>The callback function implementation is not thread safe. If the
module uses separate threads internally for processing, it can only
call the function within a function call made by the framework. The
following call flow diagram illustrates this point.</p>
<figure class="fig-center align-default" id="id81">
<a class="reference internal image-reference" href="../_images/capi_image9.png"><img alt="../_images/capi_image9.png" src="../_images/capi_image9.png" style="width: 6.05062in; height: 7.92094in;" />
</a>
<figcaption>
<p><span class="caption-text">Thread safety call flow</span><a class="headerlink" href="#id81" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>In the diagram, Module 1 uses a background thread to process data.
If this thread is to raise an event, it cannot call the callback
function of the framework directly. The framework thread might be in
the middle of doing some other processing at that time, so this
would corrupt its data.
The correct approach in this case is for the background thread to
internally store this event as a pending event (the data structure
used here must be thread safe). When the framework calls
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
(or any other function), the module can query this data structure
from the context of the framework thread and then raise any pending
events.</p>
</section>
<section id="raise-events-to-are-clients">
<h4>Raise Events to ARE Clients<a class="headerlink" href="#raise-events-to-are-clients" title="Link to this heading"></a></h4>
<p>CAPI provides a special event
(<a class="reference external" href="#_bookmark331">CAPI_EVENT_DATA_TO_DSP_CLIENT</a> or
<a class="reference external" href="#_bookmark343">CAPI_EVENT_DATA_TO_DSP_CLIENT_V2</a>) that can
be used to send data to the client processor of the ARE. The module
must raise this event when it is to send data and provide the
following information:</p>
<ul class="simple">
<li><p>Parameter ID – Indicates the type of the payload. The values of the
parameter IDs and the corresponding payloads are defined by the
module developer, and the destination service on the ARE client
processor must understand them.</p></li>
<li><p>Token – Identifier that can be used to provide additional
instance-related information. The destination service should be able
to interpret this token.</p></li>
<li><p>Payload – The payload that is to be sent.</p></li>
</ul>
<p>CAPI events to the ARE client are supported using
<a class="reference external" href="#_bookmark257">CAPI_REGISTER_EVENT_DATA_TO_DSP_CLIENT</a> and
<a class="reference external" href="#_bookmark331">CAPI_EVENT_DATA_TO_DSP_CLIENT</a>. However,
with this method, the framework must take care of the event
information.</p>
<p>To remove this overhead and make event handling more transparent,
use the following events instead:</p>
<ul class="simple">
<li><p><a class="reference external" href="#_bookmark258">CAPI_REGISTER_EVENT_DATA_TO_DSP_CLIENT_V2</a>
and CAPI_EVENT_DATA_TO_DSP_CLIENT_V2 are introduced</p></li>
<li><p><a class="reference external" href="#_bookmark258">CAPI_REGISTER_EVENT_DATA_TO_DSP_CLIENT_V2</a>
takes the destination address, token, and any event configuration</p></li>
</ul>
<p>The differences provided by v2 of these events are:</p>
<ul class="simple">
<li><p>Modules must manage the client address.</p></li>
<li><p>The client can register with different configurations for the same
event. For example, one client can register with one set of watermark
levels compared to another.</p></li>
</ul>
<p>In both versions, multiple clients per event is possible.</p>
</section>
<section id="common-events">
<h4>Common Events<a class="headerlink" href="#common-events" title="Link to this heading"></a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Event</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Algorithmic delay</p></td>
<td><p>Group delay of a filter, for example, is reported as algorithmic delay.</p></td>
</tr>
<tr class="row-odd"><td><p>KPPS/BW</p></td>
<td><p>Million instruction per second (MIPS) is a standard term used for</p>
<p>algorithm complexity.</p>
<p>In Hexagon processor terminology, because a packet of instructions</p>
<p>(containing at most 4 instructions) can be executed in one cycle (ideal</p>
<p>cache), kilo packets per second (KPPS) is typically used.</p>
<p>Bandwidth represents the amount of bus traffic the module generates.</p>
</td>
</tr>
<tr class="row-even"><td><p>Output media format</p></td>
<td><p>See section <a class="reference internal" href="#media-format"><span class="std std-ref">Media Format</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>Process state</p></td>
<td><p>Describes whether the module is enabled or disabled.</p>
<p>A module might want to disable itself based on a UI setting (such as</p>
<p>equalizer disable), calibration, or other condition. When a module is</p>
<p>disabled, it is removed from processing.</p>
<p>For single-port modules, the framework bypasses the module and the</p>
<p>rest of the graph can still run.</p>
<p>Disabling a multiport module might render an entire graph unusable</p>
<p>(depending on the shape of the graph).</p>
</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="process-call">
<h3>Process Call<a class="headerlink" href="#process-call" title="Link to this heading"></a></h3>
<p>The
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
call is the most important function because it is repeatedly called
for signal and data processing:
capi_err_t (*process)(capi_t* _pif,
capi_stream_data_v2_t* input[], capi_stream_data_v2_t*
output[]);
There are two stream data versions (v1 and v2); the difference is
that v2 supports metadata.
To access v2, cast the
<a class="reference external" href="#struct-capi-stream-data-v2-t">capi_stream_data_v2_t</a>
pointers to
<a class="reference external" href="#struct-capi-stream-data-v2-t">capi_stream_data_v2_t</a>
pointers for stream_data_version == 1 (in
<a class="reference external" href="#union-capi-stream-flags-t">capi_stream_flags_t</a>).</p>
<p><strong>NOTES:</strong></p>
<ul>
<li><p>There might be holes (NULL pointers) in the
<a class="reference external" href="#struct-capi-stream-data-v2-t">capi_stream_data_v2_t</a> array
for inactive (closed) ports.</p></li>
<li><p>The process() function might be called with NULL input buffers
(input[i] == NULL || input[ i].buf_ptr == NULL ||
input[i].buf_ptr[j].data_ptr == NULL) or buffers with actual_len =
0.</p>
<p>This is useful if any internal memory of the CAPI module is to be
given out without any new input. Modules must make the necessary
NULL checks before accessing pointers.</p>
</li>
<li><p>If a call to process() results in an event, the output buffer must
not be filled in some cases. Check the event definition to see which
events belong to this category.</p></li>
</ul>
<section id="stream-data">
<h4>Stream Data<a class="headerlink" href="#stream-data" title="Link to this heading"></a></h4>
<p>For each port, stream data contains the following:</p>
<ul class="simple">
<li><p>Flags – timestamp validity, end-of-frame (EOF), end-of-stream (EOS),
erasure, stream data version</p></li>
<li><p>Timestamp</p></li>
<li><p>Buffers:</p>
<ul>
<li><p>Only one buffer for interleaved and deinterleaved packed data</p></li>
<li><p>Multiple buffers for deinterleaved unpacked data</p></li>
</ul>
</li>
</ul>
<p>In stream data version 1, a doubly linked list of metadata per port is present.</p>
</section>
<section id="timestamp-propagation">
<h4>Timestamp Propagation<a class="headerlink" href="#timestamp-propagation" title="Link to this heading"></a></h4>
<p>For SISO modules, the framework assigns an output timestamp and
flags (in
<a class="reference external" href="#struct-capi-stream-data-v2-t">capi_stream_data_v2_t</a>)
before calling
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>.</p>
<p>For SISO modules, the framework assigns the output timestamp and
flags before calling process() as follows: output timestamp = input
timestamp - algorithmic delay, where algorithmic delay is reported
by the module using
<a class="reference external" href="#_bookmark334">CAPI_EVENT_ALGORITHMIC_DELAY</a>.</p>
<p>If a module is to change this behavior, it must assign the
appropriate value for the timestamp in the output
<a class="reference external" href="#struct-capi-stream-data-v2-t">capi_stream_data_v2_t</a>.</p>
<p>For multiport modules, the association of output to input is not
known to the framework. The module is responsible for routing
<a class="reference external" href="#struct-capi-stream-data-v2-t">capi_stream_data_v2_t</a>
correctly.</p>
</section>
<section id="return-capi-eneedmore-in-a-process-call">
<h4>Return CAPI_ENEEDMORE in a Process Call<a class="headerlink" href="#return-capi-eneedmore-in-a-process-call" title="Link to this heading"></a></h4>
<p>If the input data is not sufficient for processing a frame (in fixed
frame modules), a CAPI module must check and return
<a class="reference external" href="#define-capi-eneedmore-uint32-t-1-4">CAPI_ENEEDMORE</a>.</p>
<p>If the EOF is set (see section <a class="reference internal" href="#eof-handling"><span class="std std-ref">EOF Handling</span></a>), the
module must try to process the frame with whatever it has or drop
the data.</p>
</section>
<section id="eof-handling">
<span id="id2"></span><h4>EOF Handling<a class="headerlink" href="#eof-handling" title="Link to this heading"></a></h4>
<p>An EOF is set by the framework when it is to force process a frame
(that is, the module must process the frame with whatever data it
has or drop the data).</p>
<p>For example, when processing in 5 ms frames, suppose 2 ms of data is
left. It is possible to wait for 3 ms more data, but a media format
might be received indicating that subsequent data is of a different
media format. The old 2 ms and 3 ms cannot be concatenated and sent
in one buffer due to the media format change. The framework sets the
EOF and asks the module to process the 2 ms of data, if possible.
The module can then process the 2 ms data or drop it.</p>
<p><strong>NOTE:</strong> Do not pad 3 ms of data because it will increase the
signal length and hence cause a subsequent delay in draining the
data.</p>
<p>For another example, some decoders might wait for the next frame’s
synchronization word before processing given data. To force a module
to decode existing data without waiting for subsequent data, the EOF
is set.</p>
<p>When the EOS flag is set, an EOF is also set because
force-processing is implicitly required.</p>
<p>Timestamp discontinuities also cause an EOF to be set because two
buffers with discontinuous timestamps might not be concatenated.</p>
<p>A module that propagates metadata must also handle an EOF by itself.
Typically, an EOF is propagated when the module cannot produce any
more outputs with the given input. It is preferable to output EOF at
the same time as the last batch of output is sent instead of waiting
for one more process call.</p>
</section>
<section id="eos-handling">
<h4>EOS Handling<a class="headerlink" href="#eos-handling" title="Link to this heading"></a></h4>
<p>An EOS is indicated through the marker_eos flag
(<a class="reference external" href="#union-capi-stream-flags-t">capi_stream_flags_t</a>)and also
through MODULE_CMN_MD_ID_EOS in
<a class="reference external" href="#_bookmark180">capi_stream_data_v2_t::metadata_list_ptr</a>
(<a class="reference external" href="#_bookmark184">CAPI_STREAM_V2</a><em>&gt;</em>=1). A module that
handles metadata must also propagate an EOS.</p>
<p>An EOS indicates that the stream is ending:</p>
<ul class="simple">
<li><p>Flushing – Any memory in the algorithms must be flushed</p></li>
<li><p>Non-flushing – Any memory in the algorithms must not be flushed and
the EOS must suffer the delay.</p></li>
</ul>
<p>For example, consider two streams being mixed into one speaker. The
stream-side processing must be flushed when an EOS flows so that any
data left inside the algorithms can be sent out. But, when the EOS
flows through the mixer, it changes to non-flushing. If it is to
remain flushing, the rendered data will have gaps in the second
stream’s audio as well. By keeping the EOS as non-flushing, it still
flows in the path until the speaker sends a notification about EOS
rendering. At this point, the application can close stream one.</p>
<p>An EOS sent by the ARE client is called an <em>external EOS</em>. An EOS
generated by the framework for certain cases is called an <em>internal
EOS</em>.</p>
<ul class="simple">
<li><p>An internal EOS is used to indicate the data flow state due to an
upstream data flow stop (for example, upstream data flow of a mixer
stops, the EOS is sent by the upstream data flow, and the mixer can
stop waiting on that stream).</p></li>
<li><p>An external EOS also indicates a data flow stop. An external EOS
results in an event to the ARE client when it reaches a sink endpoint
(or when it is dropped).</p></li>
</ul>
<p>For more details about data flow states, see <a class="reference internal" href="#data-flow-states"><span class="std std-ref">Data Flow States</span></a>.</p>
</section>
<section id="erasure-handling">
<h4>Erasure Handling<a class="headerlink" href="#erasure-handling" title="Link to this heading"></a></h4>
<p>Erasure is set when input is not available. This can happen when a
certain amount of data is expected at a certain time but, due to
delays in the upstream, data was not available on time. Erasure
tells the module about the absence of data. Some modules, such as
decoders, can trigger packet loss concealment. Some other modules
can trigger ramp down on buffered data to smooth out under-run. Most
modules may not use this flag but, if they propagate metadata, then
they must propagate this flag as well.</p>
</section>
<section id="metadata-propagation">
<h4>Metadata Propagation<a class="headerlink" href="#metadata-propagation" title="Link to this heading"></a></h4>
<p>Metadata including EOS propagation is performed using the
<a class="reference external" href="#define-intf-extn-metadata-0x0a00101f">INTF_EXTN_METADATA</a>
extension.</p>
</section>
<section id="raise-events-in-process-context">
<h4>Raise Events in Process Context<a class="headerlink" href="#raise-events-in-process-context" title="Link to this heading"></a></h4>
<p>When the following events are to be raised in a
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
context, modules must not output data:</p>
<ul class="simple">
<li><p><a class="reference external" href="#_bookmark332">CAPI_EVENT_OUTPUT_MEDIA_FORMAT_UPDATED</a> or
<a class="reference external" href="#_bookmark341">CAPI_EVENT_OUTPUT_MEDIA_FORMAT_UPDATED_V2</a></p></li>
<li><p><a class="reference external" href="#_bookmark333">CAPI_EVENT_PROCESS_STATE</a></p></li>
<li><p><a class="reference external" href="#_bookmark336">CAPI_EVENT_PORT_DATA_THRESHOLD_CHANGE</a></p></li>
</ul>
<p>For example, if a process() call causes the media format to change
and it outputs data, there might be some data in the old media
format and some data in the new media format. It will take at most
three process calls to handle this case:</p>
<ul class="simple">
<li><p>In the first process() call, output the data in the old media format.</p></li>
<li><p>In the second call, raise the new media format.</p></li>
</ul>
<p>The framework handles the media format event (resizes the buffers, if necessary) and calls the module back to see if it can output some data.</p>
<ul class="simple">
<li><p>In the third call, output the data in the new media format.</p></li>
</ul>
</section>
</section>
<section id="key-framework-extensions">
<h3>Key Framework Extensions<a class="headerlink" href="#key-framework-extensions" title="Link to this heading"></a></h3>
<section id="signal-triggered-module">
<h4>Signal Triggered Module<a class="headerlink" href="#signal-triggered-module" title="Link to this heading"></a></h4>
<p>The <a class="reference external" href="#define-fwk-extn-stm-0x0a001003">FWK_EXTN_STM</a> framework extension is useful for modules that are triggered based on an interrupt (DMA) or timer. Only one such module can be present in a container. A signal, which can be set on a timer or interrupt, is given to the module. The entire graph is executed when this trigger occurs. Thus, the whole container is designated as signal- or timer-triggered.</p>
</section>
<section id="trigger-policy">
<h4>Trigger Policy<a class="headerlink" href="#trigger-policy" title="Link to this heading"></a></h4>
<p>The trigger policy framework extension (<a class="reference external" href="#define-fwk-extn-trigger-policy-0x0a00103a">FWK_EXTN_TRIGGER_POLICY</a>) is used to determine when to call a module based on triggers available at the module’s ports:</p>
<ul class="simple">
<li><p>For input ports — Containing data is a trigger</p></li>
<li><p>For output ports — Containing an empty buffer is a trigger</p></li>
</ul>
<p>For example, a module can be called when input or output is available, or it can be called only when both input and output are available.</p>
<p>A module that buffers data internally can use a trigger policy. Initially, it might block output and listen only to input. When the buffer threshold is reached, the module might set the trigger policy as input OR output. After the buffer is drained, it might set the policy as both input AND output.</p>
<p>For more details, see <a class="reference internal" href="#id8"><span class="std std-ref">Trigger Policy</span></a>.</p>
</section>
</section>
<section id="key-interface-extensions">
<h3>Key Interface Extensions<a class="headerlink" href="#key-interface-extensions" title="Link to this heading"></a></h3>
<section id="data-port-operation">
<h4>Data Port Operation<a class="headerlink" href="#data-port-operation" title="Link to this heading"></a></h4>
<p>The data port operation interface (<a class="reference external" href="#define-intf-extn-data-port-operation-0x0a001023">INTF_EXTN_DATA_PORT_OPERATION</a>) allows modules to know when a port is opened, started, stopped, or closed. It also provides port ID-to-index mapping.</p>
</section>
<section id="inter-module-control-link-imcl">
<h4>Inter-module Control Link (IMCL)<a class="headerlink" href="#inter-module-control-link-imcl" title="Link to this heading"></a></h4>
<p>Inter-module communication in ARE is based on the concept of control links. The graph designer connects control ports of the modules while designing the graph.</p>
<p>Modules must implement <a class="reference external" href="#define-intf-extn-imcl-0x0a001012">INTF_EXTN_IMCL</a> extension and also annotate the h2xml tags of the module with control ports. The modules must also define and implement the messages for communication between the modules.</p>
<p>IMCL allows the following:</p>
<ul class="simple">
<li><p>In-band communication within containers, across containers, and across processors.</p></li>
<li><p>Messages can be sent in any direction. The module instance ID and control port IDs are used.</p></li>
<li><p>No HLOS or framework is required to set up IMCL; it is set up in the ARC platform.</p></li>
<li><p>Recurring or one-time communication; triggerable or non-triggerable.</p></li>
</ul>
<p>For example, a keyword-detected notification can be sent to the
buffering module so it can open the gate.</p>
</section>
<section id="metadata">
<h4>Metadata<a class="headerlink" href="#metadata" title="Link to this heading"></a></h4>
<p>The metadata extension (<a class="reference external" href="#define-intf-extn-metadata-0x0a00101f">INTF_EXTN_METADATA</a>) is used to send a metadata message in the data path in sync with the data. It only flows downstream. Modules can inject, delete, and propagate metadata. For metadata to  be handled properly, modules must accurately report algorithmic delays. Garbage collection is handled in the framework.</p>
<p>There are different types of metadata, including sample-associated and buffer-associated metadata. For example:</p>
<ul class="simple">
<li><p>EOS</p></li>
<li><p>Encoded frame’s PCM duration</p></li>
<li><p>Accurate path delay measurement, which is possible by marking data with metadata (see <a class="reference internal" href="#path-delay"><span class="std std-ref">Path Delay</span></a>).</p></li>
<li><p>DTMF generation parameters</p></li>
</ul>
</section>
<section id="port-property-propagation">
<h4>Port Property Propagation<a class="headerlink" href="#port-property-propagation" title="Link to this heading"></a></h4>
<p>Some modules use the following interface extensions to propagate two port properties:</p>
<ul class="simple">
<li><p><a class="reference external" href="#define-intf-extn-prop-is-rt-port-property-0x0a001048">INTF_EXTN_PROP_IS_RT_PORT_PROPERTY</a>
– Propagate the is_rt port property: real time or non-real time
(<a class="reference external" href="#_bookmark639">intf_extn_param_id_is_rt_port_property_t</a>)</p></li>
<li><p><a class="reference external" href="#define-intf-extn-prop-port-ds-state-0x0a001040">INTF_EXTN_PROP_PORT_DS_STATE</a>
– Propagate the downstream port state: stopped, prepared started
(<a class="reference external" href="#_bookmark646">intf_extn_param_id_port_ds_state_t</a>)</p></li>
</ul>
<p>For details, see <a class="reference internal" href="#id11"><span class="std std-ref">Port Property Propagation</span></a>.</p>
</section>
</section>
<section id="supporting-libraries">
<h3>Supporting Libraries<a class="headerlink" href="#supporting-libraries" title="Link to this heading"></a></h3>
<p><strong>NOTE:</strong> Supporting CAPI libraries are deprecated in the ARE.</p>
<p>Supporting libraries for CAPI modules are provided as header files
that define the library interfaces as virtual function tables. To
use a library, the module must get an object that implements that
library interface. Each interface has a GUID associated with it.</p>
<section id="query-for-a-library">
<h4>Query for a Library<a class="headerlink" href="#query-for-a-library" title="Link to this heading"></a></h4>
<p>A module can get an instance of a library by raising the
<a class="reference external" href="#_bookmark339">CAPI_EVENT_GET_LIBRARY_INSTANCE</a>. The
framework returns an object that implements this interface. When the
module is finished using this object, it calls the
<a class="reference external" href="#_bookmark373">capi_library_base_t::end()</a> function of the
object to destroy it.
Following is a typical call flow for getting an instance of a
library.</p>
<figure class="fig-center align-default" id="id82">
<a class="reference internal image-reference" href="../_images/capi_image10.png"><img alt="../_images/capi_image10.png" src="../_images/capi_image10.png" style="width: 3.80208in; height: 3.94656in;" />
</a>
<figcaption>
<p><span class="caption-text">Library instance call flow</span><a class="headerlink" href="#id82" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="standard-functions-in-libraries">
<h4>Standard Functions in Libraries<a class="headerlink" href="#standard-functions-in-libraries" title="Link to this heading"></a></h4>
<p>All CAPI supporting library interfaces have the
<a class="reference external" href="#_bookmark372">capi_library_base_t::get_interface_id()</a>
function as the first function and the
<a class="reference external" href="#_bookmark373">capi_library_base_t::end()</a> function as the
second function. These functions can be called without knowledge of
the rest of the interface.</p>
<ul class="simple">
<li><p>get_interface_id() – Returns the GUID of the interface implemented
by the object.</p></li>
</ul>
<p>This function can be used to identify the interface of the object without knowing its type.</p>
<ul class="simple">
<li><p>end() – Destroys the object. After this function is called, the
object pointer is no longer valid.</p></li>
</ul>
</section>
</section>
<section id="data-flow-states">
<span id="id3"></span><h3>Data Flow States<a class="headerlink" href="#data-flow-states" title="Link to this heading"></a></h3>
<p>A module such as a mixer might need to decide whether to wait for
certain input. If the upstream data flow of a mixer is stopped or if
the stream sends an EOS, there is no need to wait for that input.
This case is handled through data flow states. There are two states:</p>
<ul class="simple">
<li><p>Data is Flowing</p></li>
<li><p>Data Flow is at Gap (DFG)</p></li>
</ul>
<p>Initially, all ports are at DFG. When the
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
function is called with data on the port, it moves to the Data is
Flowing state. When an internal EOS, external EOS, or explicit
<a class="reference external" href="#define-module-cmn-md-tracking-event-policy-each-1">MODULE_CMN_MD_ID_DFG</a>
is received on the port, the data flow state switches to DFG.
Most modules are not required to consider the data flow state in
their implementation; the framework takes care of it. Multi-port
modules might need to consider the state in their implementation.</p>
</section>
</section>
<section id="id4">
<span id="id5"></span><h2>Data Port Operation<a class="headerlink" href="#id4" title="Link to this heading"></a></h2>
<p>The Data Port Operation interface extension
(<a class="reference external" href="#define-intf-extn-data-port-operation-0x0a001023">INTF_EXTN_DATA_PORT_OPERATION</a>)
defines port operations (open, start, stop, close).
Most simple PP modules might not be required to implement this
extension. Modules such as EC, buffering modules, mixer, splitter,
and so on might be required to implement it.</p>
<section id="open">
<h3>Open<a class="headerlink" href="#open" title="Link to this heading"></a></h3>
<p>The open operation
(<a class="reference external" href="#intf-extn-data-port-open">INTF_EXTN_DATA_PORT_OPEN</a>) communicates the
port ID-to-index mapping that the modules might want to cache for
future use.
When a new data connection is made to a module, a data port is
opened. This operation is set for ports that were opened immediately
when the module was created as well as for any ports that are opened
after module creation.</p>
</section>
<section id="start">
<h3>Start<a class="headerlink" href="#start" title="Link to this heading"></a></h3>
<p>The start operation
(<a class="reference external" href="#intf-extn-data-port-start">INTF_EXTN_DATA_PORT_START</a>) indicates that
the framework started providing buffers on the given ports. On an input port, the start operation indicates that the subgraph
containing the module and the upstream operations of the module on
this port are all started. On an output port, the start operation indicates that the subgraph
containing the module and the downstream operations of the module on
this port are all started.</p>
</section>
<section id="stop">
<h3>Stop<a class="headerlink" href="#stop" title="Link to this heading"></a></h3>
<p>The start operation
(<a class="reference external" href="#intf-extn-data-port-stop">INTF_EXTN_DATA_PORT_STOP</a>) indicates that
the framework stopped providing buffers on the stopped port. On an input port, the stop operation indicates that the subgraph
containing the module is stopped. Upstream stop is indicated through
metadata (EOS), not through port operation. The metadata method
helps to drain data instead of dropping it at once. On an output port, the stop operation indicates that the subgraph
containing the module or any downstream operations of the module on
this port are stopped.</p>
</section>
<section id="close">
<h3>Close<a class="headerlink" href="#close" title="Link to this heading"></a></h3>
<p>The close operation
(<a class="reference external" href="#intf-extn-data-port-close">INTF_EXTN_DATA_PORT_CLOSE</a>) is issued when a
module is closing or when the connection to an input or output port
is removed. If a stop was not issued before this close, a stop is
also issued before the close.
When an input port in the data flowing state is closed, modules that
handle metadata must insert an internal EOS on all corresponding
outputs. This tells downstream operations about the upstream gap.
Open ports are not required to be closed for symmetry. For example,
<a class="reference external" href="#intf-extn-data-port-open">INTF_EXTN_DATA_PORT_OPEN</a> need not be
completed by <a class="reference external" href="#intf-extn-data-port-close">INTF_EXTN_DATA_PORT_CLOSE</a>.
When the input port of a metadata handling module (which implements
<a class="reference external" href="#define-intf-extn-metadata-0x0a00101f">INTF_EXTN_METADATA</a>) is
closed, and if the data flow state of the port is not already
at-gap, an internal EOS might be required to be inserted at this
input port and eventually propagated to corresponding outputs. This
internal EOS serves as a way to indicate upstream data flow gap. The
framework takes care of this for modules that do not handle
metadata.</p>
</section>
<section id="data-flow-state-vs-port-state">
<h3>Data Flow State vs Port State<a class="headerlink" href="#data-flow-state-vs-port-state" title="Link to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Port state</strong></p></th>
<th class="head"><p><strong>Data flow state</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Related to the data port operations: closed,</p>
<p>opened, started, stopped, suspended.</p>
</td>
<td><p>States are: Data is Flowing and Data Flow is at Gap</p>
<p>(DFG).</p>
</td>
</tr>
<tr class="row-odd"><td><p>Directly related to the port operations.</p></td>
<td><p>State change is due to data arrival at a port, or EOS</p>
<p>or DFG metadata departure from a port.</p>
</td>
</tr>
<tr class="row-even"><td><p>State change is due to an ARE client sending a</p>
<p>subgraph management command on the self or</p>
<p>downstream peers.</p>
</td>
<td><p>State change is due to any gap in the data flow. For</p>
<p>example: an ARE client sends a subgraph management</p>
<p>command on the self or upstream peers; or an EOS either</p>
<p>comes from the client or is due to an upstream pause.</p>
</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="intermodule-control-link-imcl">
<span id="intermodule-control-link"></span><h2>Intermodule Control Link (IMCL)<a class="headerlink" href="#intermodule-control-link-imcl" title="Link to this heading"></a></h2>
<p>The <a class="reference external" href="#define-intf-extn-imcl-0x0a001012">INTF_EXTN_IMCL</a>
interface extension allows two modules to talk to each other. Any
module that requires a control link must implement INTF_EXTN_IMCL.
The framework can use this information to perform control port
ID-based link handling, buffer management, queue management, and so
on.
IMCL is bidirectional and point-to-point.</p>
<section id="intents">
<h3>Intents<a class="headerlink" href="#intents" title="Link to this heading"></a></h3>
<p>Although IMCL provides the pipe for communication, it does not
design the parameters or protocol to be used between the modules. It
is up to the modules to determine the information they want to
exchange with each other.
A control link can support multiple intents. An intent is an
abstract concept that groups a set of interactions between two
modules. Module developers can define their own intents. Intent IDs
are GUIDs.
For example, a timer drift intent defines the APIs required for some
modules to query drifts from other modules. The protocols (when,
what API is called, and so on) are completely defined within the
intent. As long as the connection exists, the modules can talk to
each other.</p>
</section>
<section id="types-of-ports">
<h3>Types of Ports<a class="headerlink" href="#types-of-ports" title="Link to this heading"></a></h3>
<p>Static control ports are labeled and have fixed meaning. They
support only a fixed list of intents defined in the
h2xmlm_ctrlStaticPort tag.
Other ports are defined through h2xmlm_ctrlDynamicPortIntent, where
intents and the maximum number of possible usages of that intent are
provided. Graph designers assign the appropriate intents to the
links in the ARC GUI.</p>
</section>
<section id="control-link-port-operations">
<h3>Control Link Port Operations<a class="headerlink" href="#control-link-port-operations" title="Link to this heading"></a></h3>
<p>Like data port operations, control port operations are associated
with connections being created, connected, disconnected, or closed.
For more information, see <a class="reference internal" href="#intermodule-control-link"><span class="std std-ref">Intermodule Control Link (IMCL)</span></a>.</p>
</section>
<section id="types-of-messages">
<h3>Types of Messages<a class="headerlink" href="#types-of-messages" title="Link to this heading"></a></h3>
<section id="one-time-vs-repeating">
<h4>One Time vs. Repeating<a class="headerlink" href="#one-time-vs-repeating" title="Link to this heading"></a></h4>
<p>Repeating messages use a queue to create a pool of buffers up front.</p>
</section>
<section id="triggerable-or-polling">
<h4>Triggerable or Polling<a class="headerlink" href="#triggerable-or-polling" title="Link to this heading"></a></h4>
<p>Most messages are required to be read only once per frame. Such
messages are handled through polling. Occasionally, messages might
be sent when data processing is not occurring. For such scenarios,
triggerable messages are suitable.
For every message, a flag can be set to help route messages
appropriately.</p>
</section>
</section>
<section id="typical-operation">
<h3>Typical Operation<a class="headerlink" href="#typical-operation" title="Link to this heading"></a></h3>
<ol class="arabic">
<li><p>Create control ports with
<a class="reference external" href="#intf-extn-imcl-port-open">INTF_EXTN_IMCL_PORT_OPEN</a>, where the number of
ports and required intents are mentioned.</p>
<blockquote>
<div><p>If necessary, the module raises
<a class="reference external" href="#define-intf-extn-event-id-imcl-recurring-buf-info-0x0a001013">INTF_EXTN_EVENT_ID_IMCL_RECURRING_BUF_INFO</a>
to the framework to create recurring buffers.</p>
</div></blockquote>
</li>
<li><p>The module creates the memory for the control ports after any
validations.</p>
<blockquote>
<div><p>When the peer is connected, the container notifies the module
through <a class="reference external" href="#intf-extn-imcl-port-peer-connected">INTF_EXTN_IMCL_PORT_PEER_CONNECTED</a>.</p>
</div></blockquote>
</li>
<li><p>After the peer is connected, the module does the following:</p>
<ol class="loweralpha simple">
<li><p>Sends messages by first getting recurring buffers (<a class="reference external" href="#define-intf-extn-event-id-imcl-get-recurring-buf-0x0a001014">INTF_EXTN_EVENT_ID_IMCL_GET_RECURRING_BUF</a>) or one-time buffers (<a class="reference external" href="#define-intf-extn-event-id-imcl-get-one-time-buf-0x0a001015">INTF_EXTN_EVENT_ID_IMCL_GET_ONE_TIME_BUF</a>).</p></li>
<li><p>Uses <a class="reference external" href="#define-intf-extn-event-id-imcl-outgoing-data-0x0a001016">INTF_EXTN_EVENT_ID_IMCL_OUTGOING_DATA</a> to send messages to the peer.</p></li>
<li><p>Uses <a class="reference external" href="#define-intf-extn-param-id-imcl-incoming-data-0x0a001019">INTF_EXTN_PARAM_ID_IMCL_INCOMING_DATA</a> to receive parameters from the peer.</p></li>
</ol>
</li>
<li><p>The framework issues <a class="reference external" href="#intf-extn-imcl-port-peer-disconnected">INTF_EXTN_IMCL_PORT_PEER_DISCONNECTED</a> to indicate that the peer is disconnected.</p>
<blockquote>
<div><p>The module must not send any more messages. If the module is holding any buffers, they must be returned (<a class="reference external" href="#define-intf-extn-event-id-imcl-outgoing-data-0x0a001016">INTF_EXTN_EVENT_ID_IMCL_OUTGOING_DATA</a> must be sent as FALSE).</p>
</div></blockquote>
</li>
<li><p>When <a class="reference external" href="#intf-extn-imcl-port-close">INTF_EXTN_IMCL_PORT_CLOSE</a> is issued to the module, memory can be freed. All the intents cease to exist.</p></li>
</ol>
</section>
</section>
<section id="id6">
<h2>Metadata<a class="headerlink" href="#id6" title="Link to this heading"></a></h2>
<p>Metadata is information about the data in a buffer. The Metadata
interface extension
(<a class="reference external" href="#define-intf-extn-metadata-0x0a00101f">INTF_EXTN_METADATA</a>)
must be implemented by modules that are required to inject, modify,
use, or propagate metadata:</p>
<ul class="simple">
<li><p>All multi-port modules</p></li>
<li><p>All buffering modules</p></li>
<li><p>Any single-port modules</p></li>
</ul>
<p>The framework does not help to propagate metadata for modules that
implement this extension. A module implementing this extension is
responsible for all metadata, not just metadata the module might be
interested in. It is responsible for propagating metadata from input
to output, including all flags in
<a class="reference external" href="#union-capi-stream-flags-t">capi_stream_flags_t</a>
(end_of_frame, timestamp, EOS, and so on).
After a
<a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a>
call, a vtable and context pointer are passed to the module that is
implementing this extension. The vtable includes callback functions
that help in common metadata operations.
Metadata transfer is performed using doubly linked lists
(<a class="reference external" href="#struct-module-cmn-md-list-t">module_cmn_md_list_t</a>).
Single-port modules that implement this extension must ensure that
they send or destroy all the internally held metadata when they
disable themselves.
Sink modules that implement this extension must destroy all metadata
after the metadata goes through internal algorithm delays.
For most SISO modules, the framework’s default implementation should
be sufficient. A SISO module implementing this extension must clear
the internally held metadata before moving to the Disable Process
state. When such a module is disabled, the framework propagates the
metadata.</p>
<section id="common-metadata-interfaces">
<h3>Common Metadata Interfaces<a class="headerlink" href="#common-metadata-interfaces" title="Link to this heading"></a></h3>
<p>The module_cmn_metadata.h header file defines the common metadata
structures.
All metadata must use the
<a class="reference external" href="#struct-module-cmn-md-t">module_cmn_md_t</a> structure. It
contains a metadata ID (GUID), flags, size, offset, and either
in-band or out-band data for the actual metadata.</p>
<section id="flags">
<h4>Flags<a class="headerlink" href="#flags" title="Link to this heading"></a></h4>
<p>Metadata flags are defined in
<a class="reference external" href="#struct-module-cmn-md-flags-t">module_cmn_md_flags_t</a>.</p>
<section id="out-of-band">
<h5>Out-of-band<a class="headerlink" href="#out-of-band" title="Link to this heading"></a></h5>
<p>The following figure illustrates in-band and out-of-band flags.</p>
<figure class="fig-center align-default" id="id83">
<a class="reference internal image-reference" href="../_images/capi_image11.png"><img alt="../_images/capi_image11.png" src="../_images/capi_image11.png" style="width: 3.52135in; height: 1.52448in;" />
</a>
<figcaption>
<p><span class="caption-text">In-band and out-of-band flags</span><a class="headerlink" href="#id83" title="Link to this image"></a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>For in-band, <a class="reference external" href="#struct-module-cmn-md-t">module_cmn_md_t</a> and the
metadata-specific payload are in one contiguous memory buffer).</p></li>
<li><p>For out-of-band, metadata-specific memory is elsewhere and
<a class="reference external" href="#struct-module-cmn-md-t">module_cmn_md_t</a> has a pointer to it.</p></li>
</ul>
<p>Metadata-specific memory cannot contain any pointers.</p>
</section>
<section id="buffer-association">
<h5>Buffer Association<a class="headerlink" href="#buffer-association" title="Link to this heading"></a></h5>
<p>Metadata can be sample- or buffer-associated (via <a class="reference external" href="#struct-module-cmn-md-flags-t">module_cmn_md_flags_t</a>).</p>
<ul class="simple">
<li><p>Sample-associated metadata always sticks to the same position in the
signal, even when the signal is processed by an algorithm with delay.
Thus, when the signal is processed by a module, the offset is
adjusted by algorithmic delay.</p></li>
</ul>
<p>Sample-associated metadata suffers both algorithmic and buffering delay.</p>
<p>Example: EOS is sample-associated because EOS cannot be propagated ahead of the last sample. The following diagram shows metadata propagation for sample-associated metadata.</p>
<figure class="fig-center align-default">
<a class="reference internal image-reference" href="../_images/capi_image12.png"><img alt="../_images/capi_image12.png" src="../_images/capi_image12.png" style="width: 4.88187in; height: 2.16437in;" />
</a>
</figure>
<ul class="simple">
<li><p>Buffer-associated metadata does not suffer algorithmic delay, but it
does suffer from any buffering delay. Buffering delay is typically
zero for simple PP modules.</p></li>
</ul>
<p>Some modules might have internal data buffered, which might be used to delay some metadata. In the absence of a buffering delay, even when a signal suffers delay, metadata comes out quicker.</p>
<p>For example, a DFG is buffer-associated metadata because it must propagate even if data is delayed by an algorithmic delay.</p>
</section>
</section>
<section id="offset">
<h4>Offset<a class="headerlink" href="#offset" title="Link to this heading"></a></h4>
<p>An offset in <a class="reference external" href="#struct-module-cmn-md-t">module_cmn_md_t</a>
indicates the position in the data buffer from or at which metadata
is applicable. For example, when a stream gain metadata is
applicable from the 50th sample onwards, the offset is 50.</p>
</section>
<section id="lists">
<h4>Lists<a class="headerlink" href="#lists" title="Link to this heading"></a></h4>
<p>Metadata transfers are done using doubly linked lists (via <a class="reference external" href="#struct-module-cmn-md-list-t">module_cmn_md_list_t</a>).</p>
</section>
</section>
<section id="eos-metadata">
<h3>EOS Metadata<a class="headerlink" href="#eos-metadata" title="Link to this heading"></a></h3>
<section id="id7">
<h4>Flags<a class="headerlink" href="#id7" title="Link to this heading"></a></h4>
<section id="flushing-eos">
<h5>Flushing EOS<a class="headerlink" href="#flushing-eos" title="Link to this heading"></a></h5>
<p>Flushing EOS causes all stream data to be rendered, as shown in the
following figure. To send all the signals to the output, zeroes
worth of algorithmic delay are pushed through the module: zeroes
worth = zero samples equal to the amount of algorithmic delay.</p>
<figure class="fig-center align-default" id="id84">
<a class="reference internal image-reference" href="../_images/capi_image13.png"><img alt="../_images/capi_image13.png" src="../_images/capi_image13.png" style="width: 3.85062in; height: 4.07375in;" />
</a>
<figcaption>
<p><span class="caption-text">Stream data rendered due to flushing EOS</span><a class="headerlink" href="#id84" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>When data follows the external EOS, the EOS stops it from being
flushed. The incoming data itself can send data. Hence, a flushing
EOS is converted to non-flushing if there is any data follows the
EOS.</p>
</section>
<section id="internal-eos">
<h5>Internal EOS<a class="headerlink" href="#internal-eos" title="Link to this heading"></a></h5>
<p>Internal EOS is used to indicate data flow stoppage due to upstream
stops or flushes. If any data follows the internal EOS, the internal
EOS is not useful and can be dropped.</p>
</section>
</section>
<section id="eos-payload">
<h4>EOS Payload<a class="headerlink" href="#eos-payload" title="Link to this heading"></a></h4>
<p>The modules that propagate metadata must keep
<a class="reference external" href="#struct-module-cmn-md-eos-t">module_cmn_md_eos_t</a> intact.</p>
</section>
</section>
<section id="dfg-metadata">
<h3>DFG Metadata<a class="headerlink" href="#dfg-metadata" title="Link to this heading"></a></h3>
<p>DFG metadata indicates that the upstream data flow has a data flow
gap (possibly due to a stream pause operation).</p>
</section>
<section id="virtual-function-table">
<h3>Virtual Function Table<a class="headerlink" href="#virtual-function-table" title="Link to this heading"></a></h3>
<p>After initialization, a virtual function table (vtable) and context
pointer (both in
<a class="reference external" href="#struct-intf-extn-param-id-metadata-handler-t">intf_extn_param_id_metadata_handler_t</a>)
are passed to the module that is implementing this extension. The
vtable includes callback functions that help in common metadata
operations: create, clone, destroy, propagate, and modify at DFG.</p>
</section>
</section>
<section id="id8">
<span id="id9"></span><h2>Trigger Policy<a class="headerlink" href="#id8" title="Link to this heading"></a></h2>
<p>The Trigger Policy framework extension
(<a class="reference external" href="#define-fwk-extn-trigger-policy-0x0a00103a">FWK_EXTN_TRIGGER_POLICY</a>)
determines when the
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
function is called for a module. Most modules are called when all
input ports have data and output ports have buffers (the default
policy of the framework). Input data and output buffers are defined
as follows:</p>
<ul class="simple">
<li><p>Data buffer, or data, refers to a buffer that has some data. In the
context of a process() call, input ports have data.</p></li>
<li><p>Empty buffer, or buffer, refers to a buffer that is ready to accept
data. In the context of a process() call, output ports have a buffer.</p></li>
</ul>
<p>For multiport and buffering modules, complex triggers are possible (for example, when process() is called because input data is available, or because an output buffer is available).</p>
<section id="types-of-triggers">
<span id="trigger-types"></span><h3>Types of Triggers<a class="headerlink" href="#types-of-triggers" title="Link to this heading"></a></h3>
<p>Containers are triggered in two ways:</p>
<ul class="simple">
<li><p>Data or buffer trigger – If a container thread is awakened by data or
a buffer, the current trigger for processing is called a <em>data
trigger</em>.</p></li>
<li><p>Signal trigger – Certain containers can have signal-triggered
(timer-triggered) modules. If a container is awakened by a signal,
the current trigger is called a <em>signal trigger</em>.</p></li>
</ul>
<p>The policy used to call the module is based on the current trigger.
If the current trigger is based on signals, the signal trigger
policy is used; otherwise, the data trigger policy is used.</p>
<p><strong>NOTE</strong> A trigger policy is only one of the conditions for calling
modules. Other conditions for calling the modules (such as meeting a
threshold or if ports are started) must also be satisfied
independently.</p>
<p>A module can leave either or both policies as NULL. In this case,
the default policy is used, which means all ports are mandatory:</p>
<ul class="simple">
<li><p>All input ports get input data</p></li>
<li><p>All output ports get a buffer when the timer trigger causes a graph
to be processed.</p></li>
</ul>
<p>If input data is not present, an underrun (underflow) occurs
(erasure flag is set). If output is not present, an overrun
(overflow) occurs.</p>
<p>A signal trigger policy is not useful if there is no signal trigger
module in the container. Only under special conditions is a module
required to implement a signal trigger policy: when the module is
used in a signal-triggered container and the default policy does not work.
Typically, the default policy works for most modules, for example, a
SISO module might behave as a source during calibration time.</p>
<p>If a module requires a data trigger policy in a signal-triggered
container, the module must explicitly enable the policy through
<a class="reference external" href="#define-fwk-extn-event-id-data-trigger-in-st-cntr-0x0a00104c">FWK_EXTN_EVENT_ID_DATA_TRIGGER_IN_ST_CNTR</a>.
Data triggers are handled in the middle of signal triggers.</p>
<p>The schema for defining a trigger policy is the same for both signal
triggers and data triggers, but the actual callbacks are different.</p>
</section>
<section id="triggerable-ports">
<span id="id10"></span><h3>Triggerable Ports<a class="headerlink" href="#triggerable-ports" title="Link to this heading"></a></h3>
<p>The trigger policy is described in two levels, ports and group of
ports.</p>
<p><strong>NOTE</strong> A port in a triggerable group can belong to multiple
groups.</p>
<section id="mandatory-policy">
<h4>Mandatory Policy<a class="headerlink" href="#mandatory-policy" title="Link to this heading"></a></h4>
<p>For the mandatory policy
(<a class="reference external" href="#_bookmark477">FWK_EXTN_PORT_TRIGGER_POLICY_MANDATORY</a>),
ports in each group are ANDed. That is, all ports in the group must
satisfy the trigger condition (present or absent).</p>
<p>Multiple groups are ORed. That is, a module process() is called as
long as at least one group has a trigger. Using the ports/groups and
present/absent notion, any Boolean expression can be satisfied. For
example:</p>
<ul class="simple">
<li><p>The module process() might be called when either of the inputs (a or
b) and output (c) are present: ac + bc, where ac forms the first
group, and bc forms the second group.</p></li>
<li><p>The module process() might be called in an XOR condition of inputs
a^b = (!a)b + a(!b), where (!a) indicates the absence of
input a.</p></li>
<li><p>The module process() might be called when either inputs (a, b) or
output (c) is present. There are three groups: a+b+c.</p></li>
</ul>
</section>
<section id="optional-policy">
<h4>Optional Policy<a class="headerlink" href="#optional-policy" title="Link to this heading"></a></h4>
<p>For the optional policy
(<a class="reference external" href="#_bookmark478">FWK_EXTN_PORT_TRIGGER_POLICY_OPTIONAL</a>),
ports in each group are ORed and multiple groups are ANDed. For
example, (a+c)(b+c). Thus, the module process() is called for a
module when a timer trigger occurs OR all ports in at least one
group have a trigger.</p>
<p>The framework calls
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
if any one of the OR conditions is satisfied. In this case, the
module also must check which OR condition is actually satisfied
before processing. For example, if the module asks for the (abc +
def) trigger policy, when process() is called, the module must check
that either abc or def is satisfied.</p>
</section>
</section>
<section id="non-triggerable-ports-and-blocked-ports">
<span id="non-triggerable-and-blocked-ports"></span><h3>Non-triggerable Ports and Blocked Ports<a class="headerlink" href="#non-triggerable-ports-and-blocked-ports" title="Link to this heading"></a></h3>
<p>Apart from groups, there are optional non-triggerable ports and
blocked ports. Both non-triggerable and blocked ports belong to a
non-triggerable group that is ignored when the framework determines
whether to call
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
on a module.</p>
<p><strong>NOTE</strong> A port cannot belong to both triggerable and
non-triggerable groups.</p>
<section id="non-triggerable-ports">
<h4>Non-triggerable Ports<a class="headerlink" href="#non-triggerable-ports" title="Link to this heading"></a></h4>
<p>Optional non-triggerable ports never trigger a
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
call. However, if a module is triggered due to other ports, and if
these ports also have a trigger at that time, the ports carry the
data and output.</p>
</section>
<section id="blocked-ports">
<h4>Blocked Ports<a class="headerlink" href="#blocked-ports" title="Link to this heading"></a></h4>
<p>An input or output port must not be given when calling
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
on the module, even though buffer or data might be present.</p>
<p><strong>NOTE</strong> Blocked ports do not apply for timer (signal) triggers.</p>
</section>
</section>
<section id="default-trigger-policy">
<h3>Default Trigger Policy<a class="headerlink" href="#default-trigger-policy" title="Link to this heading"></a></h3>
<p>The default data or buffer trigger policy for all modules is <em>All
ports must have triggers</em>. This policy is the same as having all
groups in one group.</p>
<p>Upon an algorithm reset, port reset, or other resets, the trigger
policy is not reset. Also, for module enable and disable operations,
modules must explicitly issue a callback.</p>
<p>In a group, if a port is mandatory but it is stopped, the module
will not get a call unless the stopped port is removed from the
group.</p>
</section>
</section>
<section id="id11">
<span id="id12"></span><h2>Port Property Propagation<a class="headerlink" href="#id11" title="Link to this heading"></a></h2>
<p>Certain modules must propagate two port properties:</p>
<ul class="simple">
<li><p>Real-time flag</p></li>
<li><p>Downstream state</p></li>
</ul>
<p>Typically, multi-port modules must propagate these properties if the
framework default does not work for the module.</p>
<section id="real-time-flag">
<h3>Real-time Flag<a class="headerlink" href="#real-time-flag" title="Link to this heading"></a></h3>
<p>The
<a class="reference external" href="#define-intf-extn-prop-is-rt-port-property-0x0a001048">INTF_EXTN_PROP_IS_RT_PORT_PROPERTY</a>
interface extension allows propagation of port properties across
modules in real time or non-real time. An event from a module
indicates that the upstream port is in either real time or non-real
time.</p>
<p>When a module implements this interface extension, the framework
does not automatically propagate the port property, even for SISO
modules.</p>
<section id="for-input-ports">
<h4>For Input Ports<a class="headerlink" href="#for-input-ports" title="Link to this heading"></a></h4>
<p>A <a class="reference external" href="#capi-err-t-capi-vtbl-t-set-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr">capi_vtbl_t::set_param()</a> call indicates that the upstream port is in either real time or non-real time. An event from a module indicates that the downstream port is in either real time or non-real time.</p>
<p>The following figure shows upstream (US) and downstream (DS) real-time (RT)/non-real-time (NRT) values. Practical graphs can have branches, which means propagation might not be straightforward.</p>
<figure class="fig-center align-default" id="id85">
<a class="reference internal image-reference" href="../_images/capi_image14.png"><img alt="../_images/capi_image14.png" src="../_images/capi_image14.png" style="width: 6.09417in; height: 2.38250in;" />
</a>
<figcaption>
<p><span class="caption-text">Upstream and downstream values in real time or non-real time</span><a class="headerlink" href="#id85" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="for-output-ports">
<h4>For Output Ports<a class="headerlink" href="#for-output-ports" title="Link to this heading"></a></h4>
<p>A <a class="reference external" href="#capi-err-t-capi-vtbl-t-set-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr">capi_vtbl_t::set_param()</a> call indicates that the downstream port is in either real time or non-real time. An event from the module indicates that the upstream port is either real time or non-real time.</p>
</section>
<section id="usage-examples">
<h4>Usage Examples<a class="headerlink" href="#usage-examples" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>Modules such as multi-port modules might need to propagate this flag
because the container is not aware of routing from input to output.</p></li>
</ul>
<p>Also, the container is not aware of the trigger policy of the module (see <a class="reference internal" href="#port-properties-and-trigger-policy-interaction"><span class="std std-ref">Interaction Between Port Properties and Trigger Policy</span></a>).</p>
<ul class="simple">
<li><p>A module that changes from real time to non-real time (such as a buffering module or a timer-triggered module) must also implement this flag.</p></li>
</ul>
<p>For example, introducing a buffering module in an otherwise real-time path changes the real-time flag to FALSE. Introducing a timer-driven module in a non-real-time path changes the flag to TRUE.</p>
</section>
<section id="framework-default-settings">
<h4>Framework Default Settings<a class="headerlink" href="#framework-default-settings" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>Initially, all ports are non-real time.</p></li>
<li><p>If a started input port of a module is marked as real time upstream
(through propagation), all the output ports should be marked as real
time upstream. Otherwise, they are marked as non-real time.</p></li>
<li><p>If a started output port of a module is marked as real time
downstream (through propagation), all the input ports should be
marked as real time downstream. Otherwise, they are marked as
non-real time.</p></li>
</ul>
</section>
</section>
<section id="downstream-state">
<h3>Downstream State<a class="headerlink" href="#downstream-state" title="Link to this heading"></a></h3>
<p>The <a class="reference external" href="#define-intf-extn-prop-port-ds-state-0x0a001040">INTF_EXTN_PROP_PORT_DS_STATE</a> interface extension is used to propagate the downstream state of a
port across modules. The downstream state is different from the
port’s own state. The framework first propagates the downstream
state and then applies the downgraded state on the port.
State propagation is only from downstream to upstream. A container
sets the state on the output port. A module can then propagate this
state to the connected input ports (connected from that output port
only for which a set parameter was done). When an event is raised
from a module, it is raised on the input port, and it can be raised
only in the
<a class="reference external" href="#define-intf-extn-param-id-port-ds-state-0x0a001041">INTF_EXTN_PARAM_ID_PORT_DS_STATE</a> context.
A port’s downstream state can only be Prepare, Start, Suspend, or
Stop. This state is different from the port state itself. For
example, you can propagate a Stop state and the port itself might be
stopped.</p>
<section id="multi-port-modules">
<h4>Multi-port Modules<a class="headerlink" href="#multi-port-modules" title="Link to this heading"></a></h4>
<p>All multi-port modules must implement the downstream state because a
container does not know the routing inside the module (unless the
framework default works for the module). Unlike the real-time flag,
which depends on trigger policy grouping or ports being marked as
non-triggerable, the port state depends only on the connection
inside the module.
For example, consider a splitter that outputs data on two ports. If
one of the output paths is stopped somewhere, ideally, the other
path should not be affected. In this case, the stopped downstream
state is propagated backwards, which indicates to the splitter that
it no longer needs to wait for buffers to become available on the
corresponding output port.
For modules that implement the <a class="reference external" href="#_bookmark241">CAPI_MIN_PORT_NUM_INFO</a> property and set minimum_output_port to zero, refer to the <a class="reference external" href="#_bookmark241">CAPI_MIN_PORT_NUM_INFO</a> property
documentation.</p>
</section>
<section id="id13">
<h4>Framework Default Settings<a class="headerlink" href="#id13" title="Link to this heading"></a></h4>
<p>The framework default assumes that all the inputs are connected to
all the outputs.</p>
<ul class="simple">
<li><p>If all the output ports of a module are in the Stop state, propagate
this state backwards on all the input ports.</p></li>
<li><p>If an output port of a module is in the Start state, propagate this
state on all the input ports.</p></li>
<li><p>If an output port of a module is in the Prepare state and none of the
output ports is in the Start state, propagate the Prepare state to
all input ports.</p></li>
</ul>
<p>The downstream state is handled through this <a class="reference external" href="#define-intf-extn-prop-port-ds-state-0x0a001040">INTF_EXTN_PROP_PORT_DS_STATE</a> extension, but the modules are notified of the upstream state
through an internal EOS, which indicates that data flow is stopped.
Availability of the data indicates that data flow started. Data flow
state propagation is discussed in section <a class="reference internal" href="#data-flow-states"><span class="std std-ref">Data Flow States</span></a>.</p>
</section>
</section>
<section id="interaction-between-port-properties-and-trigger-policy">
<span id="port-properties-and-trigger-policy-interaction"></span><h3>Interaction Between Port Properties and Trigger Policy<a class="headerlink" href="#interaction-between-port-properties-and-trigger-policy" title="Link to this heading"></a></h3>
<p>At a multi-port module, there is an interaction between trigger
policy, port state, and real-time flag.</p>
<ul class="simple">
<li><p>The port state is an independent variable. It can dictate changes in
trigger policy and real-time flags.</p></li>
<li><p>The trigger policy and real-time flags are interdependent.</p></li>
</ul>
<p>For example, one input port of a mixer is real time and another port
is non-real time. A reasonable trigger policy is to wait for the
real-time input port before processing. When that port has data and
because real-time data cannot wait, the mixer performs processing even if
other input ports and the output port do not have data. If the
real-time input port is stopped (data flow stop), the mixer must
wait for both input and output ports before processing, and the
output port will be non-real time.</p>
<p>Similarly, when one output port of a splitter is real-time and other
ports are non-real time, the input port can consider downstream data
as real time. However, if the real-time port is stopped, the input
port must consider the downstream data as non-real time. Like the
mixer, trigger policies can also change.</p>
<p>If a module implements the trigger policy extension
(<a class="reference external" href="#define-fwk-extn-trigger-policy-0x0a00103a">FWK_EXTN_TRIGGER_POLICY</a>),
it must also implement this
<a class="reference external" href="#define-intf-extn-prop-is-rt-port-property-0x0a001048">INTF_EXTN_PROP_IS_RT_PORT_PROPERTY</a>
extension to propagate the real-time/non-real-time port property. This requirement is because
the way ports are grouped can change the real-time nature on other
side. In the following figure, ab and d are one group, and c and e
are another group. Processing triggers when (abd + ce) is TRUE. If a
has real-time upstream data, the d is real-time upstream, but e is
not because it depends only on c.</p>
<figure class="fig-center align-default" id="id86">
<a class="reference internal image-reference" href="../_images/capi_image15.png"><img alt="../_images/capi_image15.png" src="../_images/capi_image15.png" style="width: 1.59687in; height: 0.66375in;" />
</a>
<figcaption>
<p><span class="caption-text">Example of port property propagation</span><a class="headerlink" href="#id86" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="frame-duration-and-threshold-related-extensions">
<h2>Frame Duration and Threshold-related Extensions<a class="headerlink" href="#frame-duration-and-threshold-related-extensions" title="Link to this heading"></a></h2>
<section id="threshold-configuration">
<h3>Threshold Configuration<a class="headerlink" href="#threshold-configuration" title="Link to this heading"></a></h3>
<p>In the ARE, every module belongs to a subgraph. The subgraph is characterized by a performance mode that helps to achieve power vs. latency tradeoffs. Certain modules might need to know the duration that corresponds to the performance mode. The     <a class="reference external" href="#define-fwk-extn-threshold-configuration-0x0a00104d">FWK_EXTN_THRESHOLD_CONFIGURATION</a> extension helps to achieve these tradeoffs.</p>
<p>During initialization, a module is notified (via a set parameter) about the threshold configuration, which is the duration that corresponds to the performance mode. Based on the media format, the module can raise a threshold event after the set parameter. For  example, a module that wants to run a timer can use this extension to configure the timer.</p>
</section>
<section id="container-frame-duration">
<h3>Container Frame Duration<a class="headerlink" href="#container-frame-duration" title="Link to this heading"></a></h3>
<p>A container hosts modules that can have different thresholds. The
container aggregates all the thresholds to arrive at a composite
frame duration, typically the least common multiple (LCM). For
example, if a module is required to determine the container frame
duration in order to decide a buffer length, it can implement the
<a class="reference external" href="#define-fwk-extn-container-frame-duration-0x0a001021">FWK_EXTN_CONTAINER_FRAME_DURATION</a>
extension. A set parameter is issued whenever the container frame
duration changes.</p>
<p>The module must not raise a threshold event in response to this set
parameter because container frame duration is typically a byproduct
of a threshold event. Raising a threshold event in response can
trigger an infinite loop.</p>
</section>
<section id="container-processing-duration">
<h3>Container Processing Duration<a class="headerlink" href="#container-processing-duration" title="Link to this heading"></a></h3>
<p>Typically, a container takes as much processing time as the
container frame duration itself (the worst case). However, if clock
voting is bumped up, the processing duration decreases by a factor.
A module can use the
<a class="reference external" href="#define-fwk-extn-container-proc-duration-0x0a001043">FWK_EXTN_CONTAINER_PROC_DURATION</a>
extension to obtain the container processing duration through a set
parameter.</p>
</section>
</section>
<section id="data-duration-modifying-modules-and-container-handling">
<h2>Data Duration Modifying Modules and Container Handling<a class="headerlink" href="#data-duration-modifying-modules-and-container-handling" title="Link to this heading"></a></h2>
<section id="dm-modules">
<h3>DM Modules<a class="headerlink" href="#dm-modules" title="Link to this heading"></a></h3>
<p>Duration Modifying (DM) modules are modules which can change the
duration of data from input to output by a small amount while
processing a frame.</p>
<p>For example, a module that corrects clock jitter may drop one sample
from input or may add an extra sample at output. Similarly, a module
that converts data from one sample rate to another sample rate may
not be able to generate the exact duration of output data which it
consumes from input.</p>
</section>
<section id="dm-handling-in-are">
<h3>DM handling in ARE<a class="headerlink" href="#dm-handling-in-are" title="Link to this heading"></a></h3>
<p>In the ARE, containers need to handle such modules carefully to
avoid any unnecessary buffering within the topology. If there is a
threshold module connected at the output of the DM module, then the
framework must ensure that the fixed amount of output (which is the
same as the threshold of the connected module) is generated from the
DM module. Similarly, if the threshold module is connected at the
input of the DM module, then the framework must ensure that the DM
module consumes all the data provided by the input (from threshold
module) to avoid any buffering in topology.
Therefore, based on the topology and the positioning of
threshold/STM/MIMO modules, DM modules should either work in
Fixed-Input mode where they consume all input data provided by the
framework and can generate a variable amount of output or work in
Fixed-Output mode where they generate fixed amount of output samples
requested by the container and can consume a variable amount of
input data.
Along with the mode of operation (Fixed-In or Fixed-Out) the module
should also report the maximum buffer size requirement on the
variable path so the container can size the topo buffers correctly.
Since DM modules will either consume input at a variable rate or
generate output at a variable rate the framework may need to add
prebuffering (buffers with zero prefill) in the variable path so
upstream or downstream is not impacted by the variable rate of
operation.
DM modules are required to use
<a class="reference external" href="#define-fwk-extn-dm-0x0a001027">FWK_EXTN_DM</a> . This ensures
the framework sizes the topo buffers correctly, configures the mode
of operation (fixed-in or fixed-out) properly, and sends the
prebuffer.
Mode of operation is set to the DM module via
<a class="reference external" href="#define-fwk-extn-dm-param-id-change-mode-0x0a001028">FWK_EXTN_DM_PARAM_ID_CHANGE_MODE</a>
. To ensure that the output/input buffer is allocated with
sufficient size, framework sets the maximum amount of input/output
data which can be given/requested at a time to/from the DM module
via
<a class="reference external" href="#define-fwk-extn-dm-param-id-set-max-samples-0x0a00102b">FWK_EXTN_DM_PARAM_ID_SET_MAX_SAMPLES</a>
and then the DM module should inform about the maximum amount of
output/input data which it may generate or consume via
<a class="reference external" href="#define-fwk-extn-dm-event-id-report-max-samples-0x0a00102c">FWK_EXTN_DM_EVENT_ID_REPORT_MAX_SAMPLES</a>
.</p>
</section>
<section id="special-handling-for-fixed-output-mode-of-operation">
<h3>Special handling for Fixed-Output mode of operation<a class="headerlink" href="#special-handling-for-fixed-output-mode-of-operation" title="Link to this heading"></a></h3>
<p>Based on the current internal buffering, the amount of data which a
Fixed-Output DM module should generate may vary from process to
process. The goal is to reduce or avoid internal buffering of the
data. If there is already some data stuck between a Fixed-Output DM
module and a threshold module, then the framework can try to request
less than container-frame-size amount of output data from the DM
module. This requires the framework to set the expected amount of
output data before every process to the DM module which is done via
<a class="reference external" href="#define-fwk-extn-dm-param-id-set-samples-0x0a001029">FWK_EXTN_DM_PARAM_ID_SET_SAMPLES</a>
. In turn, the DM module must inform the amount of input data it
needs to generate the expected amount of output data, this is done
by the DM module via <a class="reference external" href="#define-fwk-extn-dm-event-id-report-samples-0x0a00102a">FWK_EXTN_DM_EVENT_ID_REPORT_SAMPLES</a>.</p>
</section>
</section>
<section id="typical-recommendations">
<h2>Typical Recommendations<a class="headerlink" href="#typical-recommendations" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>Encoder input is expected to receive interleaved fixed-point data in
Q15 format (for 16-bit data) and Q31 format (for 24-bit or 32-bit
data). Thus, a driver can control all encoders in a uniform way.</p></li>
<li><p>Pre/postprocessing modules are expected to operate on deinterleaved
unpacked data in Q15 or Q27 format, which aids interoperability with
other PP modules.</p></li>
<li><p>Decoders are expected to implement the
PARAM_ID_PCM_OUTPUT_FORMAT_CFG parameter to output PCM data in a
specified format.</p></li>
<li><p>If multiple versions of an operation code (opcode) are present, use
the latest version (highest version number). An opcode version
indicates that functionalities or features have been added to the
main operation performed by that opcode.</p></li>
</ul>
<p>A version is identified by a suffix, such as _V2. For example:</p>
<ul class="simple">
<li><p>Use CAPI_EVENT_OUTPUT_MEDIA_FORMAT_UPDATED_V2 instead of
CAPI_EVENT_OUTPUT_MEDIA_FORMAT_UPDATED.</p></li>
<li><p>Use capi_stream_data_v2_t instead of capi_stream_data_t.</p></li>
</ul>
</section>
<section id="optimization">
<h2>Optimization<a class="headerlink" href="#optimization" title="Link to this heading"></a></h2>
<p>Some features of CAPI useful for MIPS and memory optimization are:</p>
<ul class="simple">
<li><p>Use “inplace” processing when possible. Inplace can be statically set
using CAPI properties ( <a class="reference external" href="#_bookmark235">CAPI_IS_INPLACE</a> ) or
dynamically changed using
<a class="reference external" href="#_bookmark344">CAPI_EVENT_DYNAMIC_INPLACE_CHANGE</a> . When a
module is “inplace”, the input and output buffers can be the same.
This reduces memory requirements and extra copies.</p></li>
<li><p><a class="reference external" href="#_bookmark240">CAPI_IS_ELEMENTARY</a> is a property that can be
used to recognize “elementary” modules such as data-logging or gain.
Elementary modules are handled differently by the framework which
helps reduce MIPS.</p></li>
<li><p>In general, modules with zero port-threshold and
requires-data-buffering set as FALSE are better from MIPS and memory
perspectives. Modules that require the framework to do buffering
(that is CAPI property
<a class="reference external" href="#_bookmark236">CAPI_REQUIRES_DATA_BUFFERING</a> = True) usually
take higher MIPS overhead (e.g., decoders, rate matching modules,
fractional resampling cases).</p></li>
</ul>
</section>
<section id="capi-interfaces">
<h2>CAPI Interfaces<a class="headerlink" href="#capi-interfaces" title="Link to this heading"></a></h2>
<section id="id14">
<h3>Virtual Function Table<a class="headerlink" href="#id14" title="Link to this heading"></a></h3>
<section id="data-structure-documentation">
<h4>Data Structure Documentation<a class="headerlink" href="#data-structure-documentation" title="Link to this heading"></a></h4>
</section>
<section id="struct-capi-vtbl-t">
<h4>struct capi_vtbl_t<a class="headerlink" href="#struct-capi-vtbl-t" title="Link to this heading"></a></h4>
<p>Function table for plain C implementations of CAPI-compliant objects.</p>
<p>Objects must have a pointer to a function table as the first element in their instance structure. This structure is the function table type for all such objects.</p>
<blockquote>
<div><p><strong>Data Fields</strong></p>
</div></blockquote>
<ul class="simple">
<li><p><a class="reference external" href="#typedef-uint32-t-capi-err-t">capi_err_t</a>(∗
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">process</a>
)(<a class="reference external" href="#struct-capi-t">capi_t</a> ∗_pif,
<a class="reference external" href="#struct-capi-stream-data-t">capi_stream_data_t</a> ∗input[ ],
<a class="reference external" href="#struct-capi-stream-data-t">capi_stream_data_t</a> ∗output[ ])</p></li>
<li><p><a class="reference external" href="#typedef-uint32-t-capi-err-t">capi_err_t</a>(∗
<a class="reference external" href="#capi-err-t-capi-vtbl-t-end-capi-t-pif">end</a>
)(<a class="reference external" href="#struct-capi-t">capi_t</a> ∗_pif)</p></li>
<li><p><a class="reference external" href="#typedef-uint32-t-capi-err-t">capi_err_t</a>(∗
<a class="reference external" href="#capi-err-t-capi-vtbl-t-set-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr">set_param</a>
)(<a class="reference external" href="#struct-capi-t">capi_t</a> ∗_pif, uint32_t param_id, const
<a class="reference external" href="#struct-capi-port-info-t">capi_port_info_t</a> ∗port_info_ptr,
<a class="reference external" href="#struct-capi-buf-t">capi_buf_t</a> ∗params_ptr)</p></li>
<li><p><a class="reference external" href="#typedef-uint32-t-capi-err-t">capi_err_t</a>(∗
<a class="reference external" href="#capi-err-t-capi-vtbl-t-get-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr">get_param</a>
)(<a class="reference external" href="#struct-capi-t">capi_t</a> ∗_pif, uint32_t param_id, const
<a class="reference external" href="#struct-capi-port-info-t">capi_port_info_t</a> ∗port_info_ptr,
<a class="reference external" href="#struct-capi-buf-t">capi_buf_t</a> ∗params_ptr)</p></li>
<li><p><a class="reference external" href="#typedef-uint32-t-capi-err-t">capi_err_t</a>(∗
<a class="reference external" href="#capi-err-t-capi-vtbl-t-set-properties-capi-t-pif-capi-proplist-t-proplist-ptr">set_properties</a>
)(<a class="reference external" href="#struct-capi-t">capi_t</a> ∗_pif,
<a class="reference external" href="#struct-capi-proplist-t">capi_proplist_t</a> ∗proplist_ptr)</p></li>
<li><p><a class="reference external" href="#typedef-uint32-t-capi-err-t">capi_err_t</a>(∗
<a class="reference external" href="#capi-err-t-capi-vtbl-t-get-properties-capi-t-pif-capi-proplist-t-proplist-ptr">get_properties</a>
)(<a class="reference external" href="#struct-capi-t">capi_t</a> ∗_pif,
<a class="reference external" href="#struct-capi-proplist-t">capi_proplist_t</a> ∗proplist_ptr)</p></li>
</ul>
</section>
<section id="struct-capi-t">
<h4>struct capi_t<a class="headerlink" href="#struct-capi-t" title="Link to this heading"></a></h4>
<p>Plain C interface wrapper for the virtual function table,
<a class="reference external" href="#struct-capi-vtbl-t">capi_vtbl_t</a>.
This <a class="reference external" href="#struct-capi-t">capi_t</a> structure appears to the caller as
a virtual function table. The virtual function table in the instance
structure is followed by other structure elements, but those are
invisible to the users of the CAPI object. This
<a class="reference external" href="#struct-capi-t">capi_t</a> structure is all that is publicly
visible.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>const <a class="reference external" href="#struct-capi-vtbl-t">capi_vtbl_t</a> ∗</p></td>
<td><p>vtbl_ptr</p></td>
<td><p>Pointer to the virtual function table.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="process">
<h3>process()<a class="headerlink" href="#process" title="Link to this heading"></a></h3>
<section id="variable-documentation">
<h4>Variable Documentation<a class="headerlink" href="#variable-documentation" title="Link to this heading"></a></h4>
</section>
<section id="capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">
<h4>capi_err_t(∗ capi_vtbl_t::process)(capi_t ∗_pif, capi_stream_data_t ∗input[ ], capi_stream_data_t ∗output[ ])<a class="headerlink" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output" title="Link to this heading"></a></h4>
<p>Generic function that processes input data on all input ports and
provides output on all output ports.</p>
<p><strong>Associated data types</strong></p>
<p><a class="reference external" href="#struct-capi-t">capi_t</a>
<a class="reference external" href="#struct-capi-stream-data-t">capi_stream_data_t</a></p>
<p><strong>Parameters</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>in,out</p></th>
<th class="head"><p><em>_pif</em></p></th>
<th class="head"><p>Pointer to the module object.</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>in,out</p></td>
<td><p><em>input</em></p></td>
<td><p>Array of pointers to the input data for each input port.</p>
<p>The length of the array is the number of input ports. The client sets the number of input ports using the <a class="reference external" href="#_bookmark245">CAPI_PORT_NUM_INFO</a> property.</p>
<p>The function must modify the actual_data_len field to indicate how many bytes were consumed.</p>
<p>Depending on stream_data_version (in <a class="reference external" href="#union-capi-stream-flags-t">capi_stream_flags_t</a>), the actual structure can be a version of <a class="reference external" href="#struct-capi-stream-data-t">capi_stream_data_t</a> (like <a class="reference external" href="#struct-capi-stream-data-t">capi_stream_data_t</a> or <a class="reference external" href="#struct-capi-stream-data-v2-t">capi_stream_data_v2_t</a>).</p>
<p>Some elements of input[] can be NULL. This occurs when there is mismatch between <a class="reference external" href="#_bookmark245">CAPI_PORT_NUM_INFO</a> and the currently active ports. NULL elements must be ignored.</p>
</td>
</tr>
<tr class="row-odd"><td><p>out</p></td>
<td><p><em>output</em></p></td>
<td><p>Array of pointers to the output data for each output port.</p>
<p>The client sets the number of output ports using the <a class="reference external" href="#_bookmark245">CAPI_PORT_NUM_INFO</a> property.</p>
<p>The function sets the actual_data_len field to indicate how many bytes were generated.</p>
<p>Depending on stream_data_version (in <a class="reference external" href="#union-capi-stream-flags-t">capi_stream_flags_t</a>), the actual structure can be a version of <a class="reference external" href="#struct-capi-stream-data-t">capi_stream_data_t</a> (like <a class="reference external" href="#struct-capi-stream-data-t">capi_stream_data_t</a> or <a class="reference external" href="#struct-capi-stream-data-v2-t">capi_stream_data_v2_t</a>).</p>
<p>For single input/single output modules, the framework typically assigns the output flags, timestamp, and metadata with input flags, timestamp, and metadata before calling process.</p>
<p>Metadata is only available in <a class="reference external" href="#struct-capi-stream-data-v2-t">capi_stream_data_v2_t</a> and later. If the module has delay, it must reset the output <a class="reference external" href="#struct-capi-stream-data-t">capi_stream_data_t</a> (or <a class="reference external" href="#struct-capi-stream-data-v2-t">capi_stream_data_v2_t</a>) and set it back</p>
<p>after the delay is over.</p>
<p>Some elements of output[] can be NULL. This occurs when there is mismatch between <a class="reference external" href="#_bookmark245">CAPI_PORT_NUM_INFO</a> and the currently active ports. NULL elements must be ignored.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Detailed description</strong></p>
<p>On each call to
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>,
the behavior of the module depends on the value it returned for the
<a class="reference external" href="#_bookmark236">CAPI_REQUIRES_DATA_BUFFERING</a> property. For a
description of the behavior, see the comments for
CAPI_REQUIRES_DATA_BUFFERING.</p>
<p>No debug messages are allowed in this function.</p>
<p>Modules must make a NULL check for the following and use them only
if they are not NULL:</p>
<ul class="simple">
<li><p>input</p></li>
<li><p>output</p></li>
<li><p><a class="reference external" href="#struct-capi-buf-t">capi_buf_t</a> in
<a class="reference external" href="#struct-capi-stream-data-t">capi_stream_data_t</a></p></li>
<li><p>data buffer in <a class="reference external" href="#struct-capi-buf-t">capi_buf_t</a></p></li>
</ul>
<p>For some events that result from a
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
call, the output buffer must not be filled. Check the event
definition for this restriction.</p>
<p><strong>Returns</strong></p>
<p><a class="reference external" href="#define-capi-eok-0">CAPI_EOK</a> – Success</p>
<p>Error code – Failure (see <a class="reference internal" href="#capi-error-codes"><span class="std std-ref">Error Codes</span></a>)</p>
<p><strong>Dependencies</strong></p>
<p>A valid input media type must have been set on each input port using
the <a class="reference external" href="#_bookmark247">CAPI_INPUT_MEDIA_FORMAT</a> property.</p>
</section>
</section>
<section id="end">
<h3>end()<a class="headerlink" href="#end" title="Link to this heading"></a></h3>
<section id="id15">
<h4>Variable Documentation<a class="headerlink" href="#id15" title="Link to this heading"></a></h4>
</section>
<section id="capi-err-t-capi-vtbl-t-end-capi-t-pif">
<h4>capi_err_t(∗ capi_vtbl_t::end)(capi_t ∗_pif)<a class="headerlink" href="#capi-err-t-capi-vtbl-t-end-capi-t-pif" title="Link to this heading"></a></h4>
<p>Frees any memory allocated by the module.</p>
<p><strong>Associated data types</strong></p>
<p><a class="reference external" href="#struct-capi-t">capi_t</a></p>
<p><strong>Parameters</strong></p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>in,out</p></td>
<td><p><em>_pif</em></p></td>
<td><p>Pointer to the module object.</p></td>
</tr>
</tbody>
</table>
<p><strong>NOTE</strong> After calling this function, _pif is no longer a valid
CAPI object. Do not call any CAPI functions after using it.</p>
<p><strong>Returns</strong></p>
<p><a class="reference external" href="#define-capi-eok-0">CAPI_EOK</a> – Success</p>
<p>Error code – Failure (see <a class="reference internal" href="#capi-error-codes"><span class="std std-ref">Error Codes</span></a>)</p>
<p><strong>Dependencies</strong></p>
<p>None.</p>
</section>
</section>
<section id="set-param">
<h3>set_param()<a class="headerlink" href="#set-param" title="Link to this heading"></a></h3>
<section id="id16">
<h4>Variable Documentation<a class="headerlink" href="#id16" title="Link to this heading"></a></h4>
</section>
<section id="capi-err-t-capi-vtbl-t-set-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr">
<h4>capi_err_t(∗ capi_vtbl_t::set_param)(capi_t ∗_pif, uint32_t param_id, const capi_port_info_t ∗port_info_ptr, capi_buf_t ∗params_ptr)<a class="headerlink" href="#capi-err-t-capi-vtbl-t-set-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr" title="Link to this heading"></a></h4>
<p>Sets a parameter value based on a unique parameter ID.</p>
<p><strong>Associated data types</strong>
<a class="reference external" href="#struct-capi-t">capi_t</a>
<a class="reference external" href="#struct-capi-port-info-t">capi_port_info_t</a>
<a class="reference external" href="#struct-capi-buf-t">capi_buf_t</a></p>
<p><strong>Parameters</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>in,out</p></th>
<th class="head"><p><em>_pif</em></p></th>
<th class="head"><p>Pointer to the module object.</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>param_id</em></p></td>
<td><p>ID of the parameter whose value is to be set.</p></td>
</tr>
<tr class="row-odd"><td><p>in</p></td>
<td><p><em>port_info_ptr</em></p></td>
<td><p>Pointer to the information about the port on which this function must operate.</p>
<p>If a valid port index is not provided, the port index does not matter for the</p>
<p>param_id, the param_id is applicable to all ports, or the port index might be</p>
<p>part of the parameter payload.</p>
</td>
</tr>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>params_ptr</em></p></td>
<td><p>Pointer to the buffer containing the value of the parameter.</p>
<p>The format of the data in the buffer depends on the implementation.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Detailed description</strong></p>
<p>The actual_data_len field of the parameter pointer must be at
least the size of the parameter structure. Therefore, the following
check must be performed for each tuning parameter ID:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">params_ptr</span><span class="o">-&gt;</span><span class="n">actual_data_len</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">gain_struct_t</span><span class="p">))</span>
<span class="p">{</span>
<span class="o">:</span>
<span class="o">:</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="n">MSG_1</span><span class="p">(</span><span class="n">MSG_SSID_QDSP6</span><span class="p">,</span><span class="w"> </span><span class="n">DBG_ERROR_PRIO</span><span class="p">,</span><span class="s">&quot;CAPI Libname Set, Bad param size</span>
<span class="o">%</span><span class="n">lu</span><span class="s">&quot;,params_ptr-&gt;actual_data_len);</span>
<span class="k">return</span><span class="w"> </span><span class="n">AR_ENEEDMORE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Optionally, some parameter values can be printed for tuning
verification.</p>
<p><strong>NOTE</strong> In this code sample, gain_struct is an example only. Use
the correct structure based on the parameter ID.</p>
<p><strong>Returns</strong></p>
<p><a class="reference external" href="#define-capi-eok-0">CAPI_EOK</a> – Success</p>
<p>Error code – Failure (see <a class="reference internal" href="#capi-error-codes"><span class="std std-ref">Error Codes</span></a>)</p>
<p><strong>Dependencies</strong></p>
<p>None.</p>
</section>
</section>
<section id="get-param">
<h3>get_param()<a class="headerlink" href="#get-param" title="Link to this heading"></a></h3>
<section id="id17">
<h4>Variable Documentation<a class="headerlink" href="#id17" title="Link to this heading"></a></h4>
</section>
<section id="capi-err-t-capi-vtbl-t-get-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr">
<h4>capi_err_t(∗ capi_vtbl_t::get_param)(capi_t ∗_pif, uint32_t param_id, const capi_port_info_t ∗port_info_ptr, capi_buf_t ∗params_ptr)<a class="headerlink" href="#capi-err-t-capi-vtbl-t-get-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr" title="Link to this heading"></a></h4>
<p>Gets a parameter value based on a unique parameter ID.</p>
<p><strong>Associated data types</strong>
<a class="reference external" href="#struct-capi-t">capi_t</a>
<a class="reference external" href="#struct-capi-port-info-t">capi_port_info_t</a>
<a class="reference external" href="#struct-capi-buf-t">capi_buf_t</a></p>
<p><strong>Parameters</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>in,out</p></th>
<th class="head"><p><em>_pif</em></p></th>
<th class="head"><p>Pointer to the module object.</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>param_id</em></p></td>
<td><p>Parameter ID of the parameter whose value is being passed in</p>
<p>this function. For example:</p>
<ul class="simple">
<li><p>CAPI_LIBNAME_ENABLE</p></li>
<li><p>CAPI_LIBNAME_FILTER_COEFF</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>in</p></td>
<td><p><em>port_info_ptr</em></p></td>
<td><p>Pointer to the information about the port on which this function</p>
<p>must operate.</p>
<p>If the port index is invalid, either the port index does not matter for the param_id, the param_id is applicable to all ports, or the port information might be part of the parameter payload.</p>
</td>
</tr>
<tr class="row-even"><td><p>out</p></td>
<td><p><em>params_ptr</em></p></td>
<td><p>Pointer to the buffer to be filled with the value of the parameter.</p>
<p>The format depends on the implementation.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Detailed description</strong>
The max_data_len field of the parameter pointer must be at least
the size of the parameter structure. Therefore, the following check
must be performed for each tuning parameter ID.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">params_ptr</span><span class="o">-&gt;</span><span class="n">max_data_len</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">gain_struct_t</span><span class="p">))</span>
<span class="p">{</span>
<span class="o">:</span>
<span class="o">:</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="n">MSG_1</span><span class="p">(</span><span class="n">MSG_SSID_QDSP6</span><span class="p">,</span><span class="w"> </span><span class="n">DBG_ERROR_PRIO</span><span class="p">,</span><span class="s">&quot;CAPI Libname Get, Bad param size</span>
<span class="o">%</span><span class="n">lu</span><span class="s">&quot;,params_ptr-&gt;max_data_len);</span>
<span class="k">return</span><span class="w"> </span><span class="n">AR_ENEEDMORE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Before returning, the actual_data_len field must be filled with
the number of bytes written into the buffer.
Optionally, some parameter values can be printed for tuning
verification.</p>
<p><strong>NOTE</strong> In this code sample, gain_struct is an example only. Use
the correct structure based on the parameter ID.</p>
<p><strong>Returns</strong>
<a class="reference external" href="#define-capi-eok-0">CAPI_EOK</a> – Success</p>
<p>Error code – Failure (see <a class="reference internal" href="#capi-error-codes"><span class="std std-ref">Error Codes</span></a>)</p>
<p><strong>Dependencies</strong>
None.</p>
</section>
</section>
<section id="set-properties">
<h3>set_properties()<a class="headerlink" href="#set-properties" title="Link to this heading"></a></h3>
<section id="id18">
<h4>Variable Documentation<a class="headerlink" href="#id18" title="Link to this heading"></a></h4>
</section>
<section id="capi-err-t-capi-vtbl-t-set-properties-capi-t-pif-capi-proplist-t-proplist-ptr">
<h4>capi_err_t(∗capi_vtbl_t::set_properties)(capi_t ∗_pif, capi_proplist_t ∗<strong>proplist_ptr)</strong><a class="headerlink" href="#capi-err-t-capi-vtbl-t-set-properties-capi-t-pif-capi-proplist-t-proplist-ptr" title="Link to this heading"></a></h4>
<p>Sets a list of property values. Optionally, some property values can
be printed for debugging.</p>
<p><strong>Associated data types</strong></p>
<p><a class="reference external" href="#struct-capi-t">capi_t</a>
<a class="reference external" href="#struct-capi-proplist-t">capi_proplist_t</a></p>
<p><strong>Parameters</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>in,out</p></th>
<th class="head"><p><em>_pif</em></p></th>
<th class="head"><p>Pointer to the module object.</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>proplist_ptr</em></p></td>
<td><p>Pointer to the list of property values.</p></td>
</tr>
</tbody>
</table>
<p><strong>Returns</strong></p>
<p><a class="reference external" href="#define-capi-eok-0">CAPI_EOK</a> – Success</p>
<p>Error code – Failure (see <a class="reference internal" href="#capi-error-codes"><span class="std std-ref">Error Codes</span></a>)</p>
<p>Errors that occur when setting or getting a property must be handled
in the following way:</p>
<ul class="simple">
<li><p>If the property is not supported by the module, the
CAPI_EUNSUPPORTED flag must be set in the error code and the
actual_data_len field for that property must be set to zero.</p></li>
<li><p>The rest of the properties must still be processed (rather than
exiting when an unsupported property is encountered).</p></li>
</ul>
<p><strong>Dependencies</strong></p>
<blockquote>
<div><p>None.</p>
</div></blockquote>
</section>
</section>
<section id="get-properties">
<h3>get_properties()<a class="headerlink" href="#get-properties" title="Link to this heading"></a></h3>
<section id="id19">
<h4>Variable Documentation<a class="headerlink" href="#id19" title="Link to this heading"></a></h4>
</section>
<section id="capi-err-t-capi-vtbl-t-get-properties-capi-t-pif-capi-proplist-t-proplist-ptr">
<h4>capi_err_t(∗capi_vtbl_t::get_properties)(capi_t ∗_pif, capi_proplist_t ∗<strong>proplist_ptr)</strong><a class="headerlink" href="#capi-err-t-capi-vtbl-t-get-properties-capi-t-pif-capi-proplist-t-proplist-ptr" title="Link to this heading"></a></h4>
<p>Gets a list of property values.</p>
<p><strong>Associated data types</strong>
<a class="reference external" href="#struct-capi-t">capi_t</a>
<a class="reference external" href="#struct-capi-proplist-t">capi_proplist_t</a></p>
<p><strong>Parameters</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>in,out</p></th>
<th class="head"><p><em>_pif</em></p></th>
<th class="head"><p>Pointer to the module object.</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>out</p></td>
<td><p><em>proplist_ptr</em></p></td>
<td><p>Pointer to the list of empty structures that must be filled with the appropriate</p>
<p>property values, which are based on the property IDs provided.</p>
<p>The client must fill some elements of the structures as input to the module.</p>
<p>These elements must be explicitly indicated in the structure definition.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Returns</strong></p>
<p><a class="reference external" href="#define-capi-eok-0">CAPI_EOK</a> – Success
Error code – Failure (see <a class="reference internal" href="#capi-error-codes"><span class="std std-ref">Error Codes</span></a>)</p>
<p>Errors that occur when setting or getting a property must be handled
in the following way:</p>
<ul class="simple">
<li><p>If the property is not supported by the module, the
CAPI_EUNSUPPORTED flag must be set in the error code and the
actual_data_len field for that property must be set to zero.</p></li>
<li><p>The rest of the properties must still be processed (rather than
exiting when an unsupported property is encountered).</p></li>
</ul>
<p><strong>Dependencies</strong></p>
<blockquote>
<div><p>None.</p>
</div></blockquote>
</section>
</section>
<section id="capi-get-static-properties-f">
<h3>capi_get_static_properties_f()<a class="headerlink" href="#capi-get-static-properties-f" title="Link to this heading"></a></h3>
<section id="typedef-documentation">
<h4>Typedef Documentation<a class="headerlink" href="#typedef-documentation" title="Link to this heading"></a></h4>
</section>
<section id="typedef-capi-err-t-capi-get-static-properties-f-capi-proplist-t-init-set-proplist-capi-proplist-t-static-proplist">
<h4>typedef capi_err_t(∗capi_get_static_properties_f)(capi_proplist_t ∗<strong>init_set_proplist, capi_proplist_t</strong> ∗<strong>static_proplist)</strong><a class="headerlink" href="#typedef-capi-err-t-capi-get-static-properties-f-capi-proplist-t-init-set-proplist-capi-proplist-t-static-proplist" title="Link to this heading"></a></h4>
<p>Queries for properties as follows:</p>
<ul class="simple">
<li><p>Static properties of the module that are independent of the instance</p></li>
<li><p>Any property that is part of the set of properties that can be
statically queried</p></li>
</ul>
<p><strong>Associated data types</strong></p>
<p><a class="reference external" href="#struct-capi-proplist-t">capi_proplist_t</a></p>
<p><strong>Parameters</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>in</p></th>
<th class="head"><p><em>init_set_proplist</em></p></th>
<th class="head"><p>Pointer to the same properties that are sent in the call to</p>
<p><a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a>.</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>out</p></td>
<td><p><em>static_proplist</em></p></td>
<td><p>Pointer to the property list structure.</p>
<p>The client fills in the property IDs for which it needs property values. The client also allocates the memory for the payloads. The module must fill in the information in this memory.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Detailed description</strong></p>
<p>This function is used to query the memory requirements of the module
to create an instance. The function must fill in the data for the
properties in the static_proplist.</p>
<p>As an input to this function, the client must pass in the property
list that it passes to
<a class="reference external" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">capi_init_f()</a>.
The module can use the property values in init_set_proplist to
calculate its memory requirements.</p>
<p>The same properties that are sent to the module in the call to
capi_init_f() are also sent to this function to enable the module
to calculate the memory requirement.</p>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><a class="reference external" href="#define-capi-eok-0">CAPI_EOK</a> – Success</p>
<p>Error code – Failure (see <a class="reference internal" href="#capi-error-codes"><span class="std std-ref">Error Codes</span></a>)</p>
<p>Errors that occur when setting or getting a property must be handled
in the following way:</p>
</div></blockquote>
<ul class="simple">
<li><p>If the property is not supported by the module, the
CAPI_EUNSUPPORTED flag must be set in the error code and the
actual_data_len field for that property must be set to zero.</p></li>
<li><p>The rest of the properties must still be processed (rather than
exiting when an unsupported property is encountered).</p></li>
</ul>
<p><strong>Dependencies</strong></p>
<p>None.</p>
</section>
</section>
<section id="capi-init-f">
<h3>capi_init_f()<a class="headerlink" href="#capi-init-f" title="Link to this heading"></a></h3>
<section id="id20">
<h4>Typedef Documentation<a class="headerlink" href="#id20" title="Link to this heading"></a></h4>
</section>
<section id="typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist">
<h4>typedef capi_err_t(∗ capi_init_f)(capi_t ∗_pif, capi_proplist_t ∗init_set_proplist)<a class="headerlink" href="#typedef-capi-err-t-capi-init-f-capi-t-pif-capi-proplist-t-init-set-proplist" title="Link to this heading"></a></h4>
<blockquote>
<div><p>Instantiates the module to set up the virtual function table, and
also allocates any memory required by the module.</p>
</div></blockquote>
<dl class="simple">
<dt><strong>Associated data types</strong></dt><dd><p><a class="reference external" href="#struct-capi-t">capi_t</a>
<a class="reference external" href="#struct-capi-proplist-t">capi_proplist_t</a></p>
</dd>
</dl>
<p><strong>Parameters</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>in,out</p></th>
<th class="head"><p><em>_pif</em></p></th>
<th class="head"><p>Pointer to the module object.</p>
<p>The memory has been allocated by the client based on the size returned in the <a class="reference external" href="#_bookmark232">CAPI_INIT_MEMORY_REQUIREMENT</a> property.</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>init_set_proplist</em></p></td>
<td><p>Pointer to the properties set by the service to be used while</p>
<p>initializing.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Detailed description</strong></p>
<p>States within the module must be initialized at the same time.
For any unsupported property ID passed in the init_set_proplist
parameter, the function prints a message and continues processing
other property IDs.
All return codes returned by this function, except
<a class="reference external" href="#define-capi-eok-0">CAPI_EOK</a>, are considered to be FATAL.</p>
<dl class="simple">
<dt><strong>Returns</strong></dt><dd><p><a class="reference external" href="#define-capi-eok-0">CAPI_EOK</a> – Success
Error code – Failure (see <a class="reference internal" href="#capi-error-codes"><span class="std std-ref">Error Codes</span></a>)</p>
</dd>
</dl>
<p><strong>Dependencies</strong></p>
<blockquote>
<div><p>None.</p>
</div></blockquote>
</section>
</section>
<section id="data-types-and-payloads">
<h3>Data Types and Payloads<a class="headerlink" href="#data-types-and-payloads" title="Link to this heading"></a></h3>
<p>Refer to <a class="reference internal" href="../api/spf_capi.html#capi-types-h"><span class="std std-ref">capi_types.h</span></a> for more details  on data types and payloads.</p>
</section>
<section id="capi-error-codes">
<span id="id21"></span><h3>Error Codes<a class="headerlink" href="#capi-error-codes" title="Link to this heading"></a></h3>
<section id="define-documentation">
<h4>Define Documentation<a class="headerlink" href="#define-documentation" title="Link to this heading"></a></h4>
<section id="define-capi-eok-0">
<h5>#define CAPI_EOK 0<a class="headerlink" href="#define-capi-eok-0" title="Link to this heading"></a></h5>
<p>Success. The operation completed with no errors.</p>
</section>
<section id="define-capi-efailed-uint32-t-1">
<h5>#define CAPI_EFAILED ((uint32_t)1)<a class="headerlink" href="#define-capi-efailed-uint32-t-1" title="Link to this heading"></a></h5>
<p>General failure.</p>
</section>
<section id="define-capi-ebadparam-uint32-t-1-1">
<h5>#define CAPI_EBADPARAM (((uint32_t)1) <em>&lt;&lt;</em> 1)<a class="headerlink" href="#define-capi-ebadparam-uint32-t-1-1" title="Link to this heading"></a></h5>
<p>Invalid parameter value set.</p>
</section>
<section id="define-capi-eunsupported-uint32-t-1-2">
<h5>#define CAPI_EUNSUPPORTED (((uint32_t)1) <em>&lt;&lt;</em> 2)<a class="headerlink" href="#define-capi-eunsupported-uint32-t-1-2" title="Link to this heading"></a></h5>
<p>Unsupported routine or operation.</p>
</section>
<section id="define-capi-enomemory-uint32-t-1-3">
<h5>#define CAPI_ENOMEMORY (((uint32_t)1) <em>&lt;&lt;</em> 3)<a class="headerlink" href="#define-capi-enomemory-uint32-t-1-3" title="Link to this heading"></a></h5>
<p>Operation does not have memory.</p>
</section>
<section id="define-capi-eneedmore-uint32-t-1-4">
<h5>#define CAPI_ENEEDMORE (((uint32_t)1) <em>&lt;&lt;</em> 4)<a class="headerlink" href="#define-capi-eneedmore-uint32-t-1-4" title="Link to this heading"></a></h5>
<p>Operation needs more data or buffer space.</p>
</section>
<section id="define-capi-enotready-uint32-t-1-5">
<h5>#define CAPI_ENOTREADY (((uint32_t)1) <em>&lt;&lt;</em> 5)<a class="headerlink" href="#define-capi-enotready-uint32-t-1-5" title="Link to this heading"></a></h5>
<p>CAPI currently cannot perform this operation because necessary
properties and parameters are not set or because of any internal
state.</p>
</section>
<section id="define-capi-ealready-uint32-t-1-6">
<h5>#define CAPI_EALREADY (((uint32_t)1) <em>&lt;&lt;</em> 6)<a class="headerlink" href="#define-capi-ealready-uint32-t-1-6" title="Link to this heading"></a></h5>
<p>CAPI currently cannot perform this operation. There might be
restrictions on overwriting calibration after a certain operation.
For example, recalibrating the hardware interface after it is
started.</p>
</section>
<section id="define-capi-failed-x-capi-eok-x">
<h5>#define CAPI_FAILED( <em>x</em> ) (CAPI_EOK != (x))<a class="headerlink" href="#define-capi-failed-x-capi-eok-x" title="Link to this heading"></a></h5>
<p>Macro that checks whether a CAPI error code has any error bits set.</p>
</section>
<section id="define-capi-succeeded-x-capi-eok-x">
<h5>#define CAPI_SUCCEEDED( <em>x</em> ) (CAPI_EOK == (x))<a class="headerlink" href="#define-capi-succeeded-x-capi-eok-x" title="Link to this heading"></a></h5>
<p>Macro that checks whether a CAPI error code represents a success
case.</p>
</section>
<section id="define-capi-set-error-error-flags-return-code-error-flags-return-code">
<h5>#define CAPI_SET_ERROR( error_flags, return_code ) ((error_flags) |= (return_code))<a class="headerlink" href="#define-capi-set-error-error-flags-return-code-error-flags-return-code" title="Link to this heading"></a></h5>
<p>Macro that sets an error flag in a CAPI error code.</p>
</section>
<section id="define-capi-is-error-code-set-error-flags-error-code-error-flags-error-code-capi-eok">
<h5>#define CAPI_IS_ERROR_CODE_SET( error_flags, error_code) (((error_flags) &amp; (error_code)) != CAPI_EOK)<a class="headerlink" href="#define-capi-is-error-code-set-error-flags-error-code-error-flags-error-code-capi-eok" title="Link to this heading"></a></h5>
<p>Macro that checks whether a specific error flag is set in a CAPI
error code.</p>
</section>
</section>
<section id="id22">
<h4>Typedef Documentation<a class="headerlink" href="#id22" title="Link to this heading"></a></h4>
<section id="typedef-uint32-t-capi-err-t">
<h5>typedef uint32_t capi_err_t<a class="headerlink" href="#typedef-uint32-t-capi-err-t" title="Link to this heading"></a></h5>
<p>Error code type for CAPI.</p>
</section>
</section>
</section>
<section id="property-ids">
<h3>Property IDs<a class="headerlink" href="#property-ids" title="Link to this heading"></a></h3>
<p>Properties are used to set and get information to and from the
module. Properties are identified by IDs and have corresponding
payloads. Their usage is similar to parameters, but parameters are
module specific:</p>
<ul class="simple">
<li><p>Parameters are defined by the implementer of the module</p></li>
<li><p>Parameters are used to control aspects that are specific to the
underlying algorithm</p></li>
<li><p>Properties are generic and are defined in the CAPI interface.</p></li>
</ul>
<p><strong>Categories of properties</strong></p>
<ul class="simple">
<li><p>Properties that can be queried statically using
<a class="reference external" href="#typedef-capi-err-t-capi-get-static-properties-f-capi-proplist-t-init-set-proplist-capi-proplist-t-static-proplist">capi_get_static_properties_f()</a>:</p>
<ul>
<li><p><a class="reference external" href="#_bookmark232">CAPI_INIT_MEMORY_REQUIREMENT</a></p></li>
<li><p><a class="reference external" href="#_bookmark233">CAPI_STACK_SIZE</a></p></li>
<li><p><a class="reference external" href="#_bookmark234">CAPI_MAX_METADATA_SIZE</a></p></li>
<li><p><a class="reference external" href="#_bookmark235">CAPI_IS_INPLACE</a></p></li>
<li><p><a class="reference external" href="#_bookmark236">CAPI_REQUIRES_DATA_BUFFERING</a></p></li>
<li><p><a class="reference external" href="#_bookmark237">CAPI_NUM_NEEDED_FRAMEWORK_EXTENSIONS</a></p></li>
<li><p><a class="reference external" href="#_bookmark238">CAPI_NEEDED_FRAMEWORK_EXTENSIONS</a></p></li>
<li><p><a class="reference external" href="#_bookmark239">CAPI_INTERFACE_EXTENSIONS</a></p></li>
<li><p><a class="reference external" href="#_bookmark243">CAPI_MAX_STATIC_PROPERTIES</a></p></li>
<li><p><a class="reference external" href="#_bookmark240">CAPI_IS_ELEMENTARY</a></p></li>
<li><p><a class="reference external" href="#_bookmark241">CAPI_MIN_PORT_NUM_INFO</a></p></li>
</ul>
</li>
<li><p>Properties that can be set at initialization and at any time after
initialization:</p>
<ul>
<li><p><a class="reference external" href="#_bookmark244">CAPI_EVENT_CALLBACK_INFO</a></p></li>
<li><p><a class="reference external" href="#_bookmark245">CAPI_PORT_NUM_INFO</a></p></li>
<li><p><a class="reference external" href="#_bookmark246">CAPI_HEAP_ID</a></p></li>
<li><p><a class="reference external" href="#_bookmark247">CAPI_INPUT_MEDIA_FORMAT</a></p></li>
<li><p><a class="reference external" href="#_bookmark248">CAPI_LOG_CODE</a></p></li>
<li><p><a class="reference external" href="#_bookmark249">CAPI_CUSTOM_INIT_DATA</a></p></li>
<li><p><a class="reference external" href="#_bookmark250">CAPI_SESSION_IDENTIFIER</a></p></li>
<li><p><a class="reference external" href="#_bookmark251">CAPI_INPUT_MEDIA_FORMAT_V2</a></p></li>
<li><p><a class="reference external" href="#_bookmark254">CAPI_MAX_INIT_PROPERTIES</a></p></li>
</ul>
</li>
<li><p>Properties that can be set only after initialization:</p>
<ul>
<li><p><a class="reference external" href="#_bookmark255">CAPI_ALGORITHMIC_RESET</a></p></li>
<li><p><a class="reference external" href="#_bookmark256">CAPI_EXTERNAL_SERVICE_ID</a></p></li>
<li><p><a class="reference external" href="#_bookmark257">CAPI_REGISTER_EVENT_DATA_TO_DSP_CLIENT</a></p></li>
<li><p><a class="reference external" href="#_bookmark258">CAPI_REGISTER_EVENT_DATA_TO_DSP_CLIENT_V2</a></p></li>
<li><p><a class="reference external" href="#_bookmark259">CAPI_PARAM_PERSISTENCE_INFO</a></p></li>
<li><p><a class="reference external" href="#_bookmark260">CAPI_MAX_SET_PROPERTIES</a></p></li>
</ul>
</li>
<li><p>Properties that can be queried using
<a class="reference external" href="#capi-err-t-capi-vtbl-t-get-properties-capi-t-pif-capi-proplist-t-proplist-ptr">capi_vtbl_t::get_properties()</a>:</p>
<ul>
<li><p><a class="reference external" href="#_bookmark261">CAPI_METADATA</a></p></li>
<li><p><a class="reference external" href="#_bookmark262">CAPI_PORT_DATA_THRESHOLD</a></p></li>
<li><p><a class="reference external" href="#_bookmark263">CAPI_OUTPUT_MEDIA_FORMAT_SIZE</a></p></li>
<li><p><a class="reference external" href="#_bookmark264">CAPI_MAX_GET_PROPERTIES</a></p></li>
</ul>
</li>
<li><p>Properties that can be set using
<a class="reference external" href="#capi-err-t-capi-vtbl-t-set-properties-capi-t-pif-capi-proplist-t-proplist-ptr">capi_vtbl_t::set_properties()</a>
and queried using
<a class="reference external" href="#capi-err-t-capi-vtbl-t-get-properties-capi-t-pif-capi-proplist-t-proplist-ptr">capi_vtbl_t::get_properties()</a>:</p>
<ul>
<li><p><a class="reference external" href="#_bookmark265">CAPI_OUTPUT_MEDIA_FORMAT</a></p></li>
<li><p><a class="reference external" href="#_bookmark266">CAPI_CUSTOM_PROPERTY</a></p></li>
<li><p><a class="reference external" href="#_bookmark267">CAPI_OUTPUT_MEDIA_FORMAT_V2</a></p></li>
<li><p><a class="reference external" href="#_bookmark268">CAPI_MAX_SET_GET_PROPERTIES</a></p></li>
<li><p><a class="reference external" href="#_bookmark269">CAPI_MAX_PROPERTY</a></p></li>
</ul>
</li>
</ul>
<p>Refer to <a class="reference internal" href="../api/spf_capi.html#capi-properties-h"><span class="std std-ref">capi_properties.h</span></a> for more details on CAPI properties.</p>
</section>
<section id="id23">
<h3>Events<a class="headerlink" href="#id23" title="Link to this heading"></a></h3>
<p>Modules use events to send asynchronous notifications to the
framework. During initialization, the framework provides a callback
function and a context pointer. The module can call this function
any time to raise an event. The appropriate payload must be sent
based on the event ID.</p>
<p>The callback function is not thread safe, so it must be called from
the same thread context as the interface functions unless mentioned
otherwise in the event description. The payload data is copied
before the function returns.</p>
<p>For example, raising the kilo packets per second (KPPS) change
event:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">capi_event_KPPS_t</span><span class="w"> </span><span class="n">payload</span><span class="p">;</span>
<span class="n">payload</span><span class="p">.</span><span class="n">KPPS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10000</span><span class="p">;</span>

<span class="n">capi_event_info_t</span><span class="w"> </span><span class="n">payload_buffer</span><span class="p">;</span>
<span class="n">payload_buffer</span><span class="p">.</span><span class="n">port_info</span><span class="p">.</span><span class="n">is_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FALSE</span><span class="p">;</span>
<span class="n">payload_buffer</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">data_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int8_t</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">payload</span><span class="p">);</span>
<span class="n">payload_buffer</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">actual_data_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">payload_buffer</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">max_data_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>

<span class="n">capi_err_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">event_cb_ptr</span><span class="p">(</span><span class="n">context_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">CAPI_EVENT_KPPS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">payload_buffer</span><span class="p">);</span>
</pre></div>
</div>
<p>Refer to <a class="reference internal" href="../api/spf_capi.html#capi-events-h"><span class="std std-ref">capi_events.h</span></a> for more details on CAPI events.</p>
</section>
</section>
<section id="id24">
<h2>Framework Extensions<a class="headerlink" href="#id24" title="Link to this heading"></a></h2>
<p>CAPI provides framework extensions that extend the functionality of the interface.</p>
<p>A framework extension is typically defined using a header file that is included by both the module and the client (the application that runs on the HLOS and invokes the DSP services). Each extension is identified by a GUID. The header file then describes how the service and module that use the extensions behave. The header file also has any set parameter IDs and payloads, constant definitions, and function declarations required for this extension. The service uses <a class="reference external" href="#typedef-capi-err-t-capi-get-static-properties-f-capi-proplist-t-init-set-proplist-capi-proplist-t-static-proplist">capi_get_static_properties_f()</a> to query the module for the list of extensions that it needs. If the client supports these extensions, it can create the module and proceed. If the client does not support these extensions, it must not create the module.</p>
<section id="example-of-using-a-framework-extension">
<h3>Example of Using a Framework Extension<a class="headerlink" href="#example-of-using-a-framework-extension" title="Link to this heading"></a></h3>
<p>A module performs sample removal or insertion to match the audio
that goes from one clock domain to another. The module requires the
clock drift information to be passed to it.</p>
<p>Create a framework extension for this purpose. The extension header
includes the following information:</p>
<ul class="simple">
<li><p>The GUID that identifies this extension</p></li>
<li><p>The parameter ID and payload format the client uses to pass the drift
information to the module</p></li>
</ul>
<p>A module that implements the rate matching functionality can include
this header and return the GUID in the list of framework extensions
it needs. The client can then perform the required set parameters to
pass the drift information.</p>
</section>
<section id="bluetooth-codec">
<h3>Bluetooth Codec<a class="headerlink" href="#bluetooth-codec" title="Link to this heading"></a></h3>
<p>The Bluetooth framework extension (FWK_EXTN_BT_CODEC) provides special events that are required to enable Bluetooth codecs.</p>
<section id="id25">
<h4>Define Documentation<a class="headerlink" href="#id25" title="Link to this heading"></a></h4>
<section id="define-fwk-extn-bt-codec-0x000132e4">
<h5>#define FWK_EXTN_BT_CODEC 0x000132e4<a class="headerlink" href="#define-fwk-extn-bt-codec-0x000132e4" title="Link to this heading"></a></h5>
<p>Unique identifier of the Bluetooth framework extension for a module. This extension supports the following events:</p>
<ul class="simple">
<li><p><a class="reference external" href="#_bookmark387">CAPI_BT_CODEC_EXTN_EVENT_ID_DISABLE_PREBUFFER</a></p></li>
<li><p><a class="reference external" href="#define-capi-bt-codec-extn-event-id-kpps-scale-factor-0x000132e7">CAPI_BT_CODEC_EXTN_EVENT_ID_KPPS_SCALE_FACTOR</a></p></li>
</ul>
</section>
<section id="define-capi-bt-codec-extn-event-id-disable-prebuffer-0x000132e5">
<h5>#define CAPI_BT_CODEC_EXTN_EVENT_ID_DISABLE_PREBUFFER 0x000132e5<a class="headerlink" href="#define-capi-bt-codec-extn-event-id-disable-prebuffer-0x000132e5" title="Link to this heading"></a></h5>
<blockquote>
<div><p>ID of the event the encoder module uses to disable pre-buffering.
This event must be raised during CAPI initialization before data
processing.
<strong>Message payload (capi_bt_codec_extn_event_disable_prebuffer_t)</strong></p>
</div></blockquote>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>disable_prebuffering</p></td>
<td><p>Specifies whether to disable pre-buffering.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>≥ 1 – Disable pre-buffering</p></li>
<li><p>0 – Enable pre-buffering</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>See also</strong></p>
<p><cite>CAPI_EVENT_DATA_TO_DSP_SERVICE</cite></p>
</section>
<section id="define-capi-bt-codec-extn-event-id-kpps-scale-factor-0x000132e7">
<h5>#define CAPI_BT_CODEC_EXTN_EVENT_ID_KPPS_SCALE_FACTOR 0x000132e7<a class="headerlink" href="#define-capi-bt-codec-extn-event-id-kpps-scale-factor-0x000132e7" title="Link to this heading"></a></h5>
<p>ID of the event the encoder module uses to set the KPPS scale
factor.</p>
<p>This scale factor increases the clock speed so the processing time
of the encoder catches up with the real time. It is the factor by
which the clock speed must be increased.</p>
<p>This event can be raised by the module any time.</p>
<p><strong>NOTE</strong> KPPS scaling does not scale the processing by the exact value. It will be lower than the factor due to thread pre-emptions and relative thread priorities in the system.</p>
<p><strong>Message payload (capi_bt_codec_etxn_event_kpps_scale_factor_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>scale_factor</p></td>
<td><p>Scale factor for KPPS voting (it can be a decimal number).</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>Bits 31 to 4 – Integral part of the decimal number</p></li>
<li><p>Bits 0 to 3 – Fractional part of the decimal number</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>See also</strong></p>
<p><a class="reference external" href="#_bookmark338">CAPI_EVENT_DATA_TO_DSP_SERVICE</a></p>
</section>
</section>
</section>
<section id="id26">
<h3>Container Frame Duration<a class="headerlink" href="#id26" title="Link to this heading"></a></h3>
<section id="id27">
<h4>Define Documentation<a class="headerlink" href="#id27" title="Link to this heading"></a></h4>
<section id="define-fwk-extn-container-frame-duration-0x0a001021">
<h5>#define FWK_EXTN_CONTAINER_FRAME_DURATION 0x0A001021<a class="headerlink" href="#define-fwk-extn-container-frame-duration-0x0a001021" title="Link to this heading"></a></h5>
<p>Unique identifier of the framework extension that modules use to get
the container frame duration from the framework (see <a class="reference external" href="#define-fwk-extn-threshold-configuration-0x0a00104d">FWK_EXTN_THRESHOLD_CONFIGURATION</a>).</p>
</section>
<section id="define-fwk-extn-param-id-container-frame-duration-0x0a001022">
<h5>#define FWK_EXTN_PARAM_ID_CONTAINER_FRAME_DURATION 0x0A001022<a class="headerlink" href="#define-fwk-extn-param-id-container-frame-duration-0x0a001022" title="Link to this heading"></a></h5>
<p>ID of the parameter used to set the container frame duration to
modules. This parameter can help with internal buffer allocations.</p>
<p>The modules must not raise a threshold event in response to a <a class="reference external" href="#capi-err-t-capi-vtbl-t-set-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr">capi_vtbl_t::set_param()</a> call of this parameter.</p>
<p><strong>Message payload (fwk_extn_param_id_container_frame_duration_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>duration_us</p></td>
<td><p>Container frame duration in microseconds based on aggregation</p>
<p>across all threshold modules.</p>
</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="id28">
<h3>Container Processing Duration<a class="headerlink" href="#id28" title="Link to this heading"></a></h3>
<section id="id29">
<h4>Define Documentation<a class="headerlink" href="#id29" title="Link to this heading"></a></h4>
<section id="define-fwk-extn-container-proc-duration-0x0a001043">
<h5>#define FWK_EXTN_CONTAINER_PROC_DURATION 0x0A001043<a class="headerlink" href="#define-fwk-extn-container-proc-duration-0x0a001043" title="Link to this heading"></a></h5>
<p>Unique identifier of the interface extension that modules use to
receive container processing duration. The modules use this
extension to get the container processing delay from the framework
(see <a class="reference external" href="#define-fwk-extn-container-frame-duration-0x0a001021">FWK_EXTN_CONTAINER_FRAME_DURATION</a>).</p>
<p>Typically, the container processing duration and container frame
duration are the same except when a floor clock is being voted for
faster processing.</p>
</section>
<section id="define-fwk-extn-param-id-container-proc-duration-0x0a001044">
<h5>#define FWK_EXTN_PARAM_ID_CONTAINER_PROC_DURATION 0x0A001044<a class="headerlink" href="#define-fwk-extn-param-id-container-proc-duration-0x0a001044" title="Link to this heading"></a></h5>
<p>ID of the parameter that sets the container processing delay to the modules.</p>
<p><strong>Message payload (fwk_extn_param_id_container_proc_duration_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>proc_duration_us</p></td>
<td><p>Container processing delay in microseconds.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="data-duration-modifying-modules">
<h3>Data Duration Modifying Modules<a class="headerlink" href="#data-duration-modifying-modules" title="Link to this heading"></a></h3>
<p>The data duration modifying (DM) framework extension
(<a class="reference external" href="#define-fwk-extn-dm-0x0a001027">FWK_EXTN_DM</a>) is used to take
care of data duration modifying modules with variable input
consumption rates or output production rates.</p>
<p>DM modules change the duration of input data by a small amount
relative to output, or vice versa. These modules do not act as
buffering modules, and they always produce one output for one input.
Examples include sample slipping, Asynchronous Sample Rate Converter
(ASRC), and fractional resampling.</p>
<p>This DM extension, used for rate corrections through sample
slipping/stuffing or fractional sample rate conversion, has the
following requirements:</p>
<ul class="simple">
<li><p>Prebuffering</p></li>
<li><p>Setting of fixed input or output mode</p></li>
<li><p>Allocation of appropriately sized input and output buffers after
querying the module</p></li>
</ul>
<section id="id30">
<h4>Define Documentation<a class="headerlink" href="#id30" title="Link to this heading"></a></h4>
<section id="define-fwk-extn-dm-0x0a001027">
<h5>#define FWK_EXTN_DM 0x0A001027<a class="headerlink" href="#define-fwk-extn-dm-0x0a001027" title="Link to this heading"></a></h5>
<p>Unique identifier of the framework extension used to specify a data
duration modifying module. This extension supports the following
parameter and event IDs:</p>
<ul class="simple">
<li><p><a class="reference external" href="#define-fwk-extn-dm-param-id-change-mode-0x0a001028">FWK_EXTN_DM_PARAM_ID_CHANGE_MODE</a></p></li>
<li><p><a class="reference external" href="#define-fwk-extn-dm-param-id-set-samples-0x0a001029">FWK_EXTN_DM_PARAM_ID_SET_SAMPLES</a></p></li>
<li><p><a class="reference external" href="#define-fwk-extn-dm-event-id-report-samples-0x0a00102a">FWK_EXTN_DM_EVENT_ID_REPORT_SAMPLES</a></p></li>
<li><p><a class="reference external" href="#define-fwk-extn-dm-param-id-set-max-samples-0x0a00102b">FWK_EXTN_DM_PARAM_ID_SET_MAX_SAMPLES</a></p></li>
<li><p><a class="reference external" href="#define-fwk-extn-dm-event-id-report-max-samples-0x0a00102c">FWK_EXTN_DM_EVENT_ID_REPORT_MAX_SAMPLES</a></p></li>
<li><p><a class="reference external" href="#define-fwk-extn-dm-event-id-disable-dm-0x0a00102d">FWK_EXTN_DM_EVENT_ID_DISABLE_DM</a></p></li>
</ul>
</section>
<section id="define-fwk-extn-dm-param-id-consume-partial-input-0x080012ee">
<h5>#define FWK_EXTN_DM_PARAM_ID_CONSUME_PARTIAL_INPUT 0x080012EE<a class="headerlink" href="#define-fwk-extn-dm-param-id-consume-partial-input-0x080012ee" title="Link to this heading"></a></h5>
<blockquote>
<div><p>ID of the parameter used to inform the DM module whether it should
consume partial input or keep it unconsumed while configured for
Fixed Output mode.</p>
<p>This parameter doesn’t need to be implemented if this module won’t
be placed in the same container upstream of a module implementing
FWK_EXTN_SYNC.</p>
<p>When a DM module is placed upstream of a module implementing
FWK_EXTN_SYNC, it must be configured to Fixed Output mode and it
is expected to be able to process data even when less than the
expected input amount is provided. When less than the expected input
is provided, this module is allowed to produce for any amount of
output to be generated (less than the fixed output threshold). This
extra requirement is necessary for proper sync module behavior when
the threshold is disabled.</p>
<p>This parameter allows the framework to inform the DM module of
whether it should or should not consume data when less than the
expected input is provided.</p>
<p><strong>Message payload
(fwk_extn_dm_param_id_consume_partial_input_t)</strong></p>
</div></blockquote>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>should_consume_partial_input</p></td>
<td><p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>1 – The module should consume data even if less than expected input is provided.</p></li>
<li><p>0 – The module should not consume data if less than expected input is provided.</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-fwk-extn-dm-param-id-change-mode-0x0a001028">
<h5>#define FWK_EXTN_DM_PARAM_ID_CHANGE_MODE 0x0A001028<a class="headerlink" href="#define-fwk-extn-dm-param-id-change-mode-0x0a001028" title="Link to this heading"></a></h5>
<blockquote>
<div><p>ID of the parameter used to configure a module to run in Fixed Input
or Fixed Output mode.</p>
<p>In Fixed Input mode, the module consumes all data on the input side
but it does not necessarily fill the entire output buffer. If the
output buffer passed for processing is not large enough to contain
all data that is produced when consuming the entire input, the
module fills the output buffer entirely, although it does not
consume the entire input.</p>
<p>In Fixed Output mode, the module produces enough data to completely
fill the output buffer but does not necessarily consume all the
input data. If the input buffer passed for processing is not large
enough such that enough data is produced to fill the output buffer,
the module consumes all input, although it does not fill the entire
output buffer.</p>
<p><strong>Message payload (fwk_extn_dm_param_id_change_mode_t)</strong></p>
</div></blockquote>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>dm_mode</p></td>
<td><p>Type of data duration modifying mode.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="#_bookmark411">FWK_EXTN_DM_FIXED_INPUT_MODE</a></p></li>
<li><p><a class="reference external" href="#_bookmark412">FWK_EXTN_DM_FIXED_OUTPUT_MODE</a></p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-fwk-extn-dm-param-id-set-samples-0x0a001029">
<h5>#define FWK_EXTN_DM_PARAM_ID_SET_SAMPLES 0x0A001029<a class="headerlink" href="#define-fwk-extn-dm-param-id-set-samples-0x0a001029" title="Link to this heading"></a></h5>
<blockquote>
<div><p>ID of the parameter used to set the number of samples that are
either required on output or are provided on input to the module.</p>
<p>The module responds to this parameter ID with
<a class="reference external" href="#define-fwk-extn-dm-event-id-report-samples-0x0a00102a">FWK_EXTN_DM_EVENT_ID_REPORT_SAMPLES</a>.</p>
</div></blockquote>
<p><strong>Message payload (fwk_extn_dm_param_id_req_samples_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint16_t</p></td>
<td><p>is_input</p></td>
<td><p>Indicates whether samples are being set for input or output ports.</p></td>
</tr>
<tr class="row-odd"><td><p>uint16_t</p></td>
<td><p>num_ports</p></td>
<td><p>Number of ports for which samples are being set.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#_bookmark404">fwk_extn_dm_-</a></p>
<p><a class="reference external" href="#_bookmark404">port_samples_t</a></p>
</td>
<td><p>req_samples</p></td>
<td><p>Array that contains the required samples.</p>
<p>For <a class="reference external" href="#define-fwk-extn-dm-param-id-set-max-samples-0x0a00102b">FWK_EXTN_DM_PARAM_ID_SET_MAX_SAMPLES</a>, input port samples are samples to be provided to the module,</p>
<p>and output port samples are samples that are required from the module.</p>
<p>For <a class="reference external" href="#define-fwk-extn-dm-event-id-report-max-samples-0x0a00102c">FWK_EXTN_DM_EVENT_ID_REPORT_MAX_SAMPLES</a>, input port samples are samples required by the module,</p>
<p>and output port samples indicate that output buffer space is required.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Message payload (fwk_extn_dm_port_samples_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>port_index</p></td>
<td><p>Port index for which samples are being set.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>samples_per_channel</p></td>
<td><p>Number of samples per channel for the port.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="define-fwk-extn-dm-event-id-report-samples-0x0a00102a">
<h5>#define FWK_EXTN_DM_EVENT_ID_REPORT_SAMPLES 0x0A00102A<a class="headerlink" href="#define-fwk-extn-dm-event-id-report-samples-0x0a00102a" title="Link to this heading"></a></h5>
<blockquote>
<div><p>ID of the event raised in response to
<a class="reference external" href="#define-fwk-extn-dm-param-id-set-samples-0x0a001029">FWK_EXTN_DM_PARAM_ID_SET_SAMPLES</a>
or when the sample requirement of a module changes.</p>
<p>For modules configured in Fixed Input mode, this event is raised for
output ports. For modules configured in Fixed Output mode, this
event is raised for input ports.</p>
<p><strong>Message payload (fwk_extn_dm_param_id_req_samples_t)</strong></p>
</div></blockquote>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint16_t</p></td>
<td><p>is_input</p></td>
<td><p>Indicates whether samples are being set for input or output ports.</p></td>
</tr>
<tr class="row-odd"><td><p>uint16_t</p></td>
<td><p>num_ports</p></td>
<td><p>Number of ports for which samples are being set.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#_bookmark404">fwk_extn_dm_-</a></p>
<p><a class="reference external" href="#_bookmark404">port_samples_t</a></p>
</td>
<td><p>req_samples</p></td>
<td><p>Array that contains the required samples.</p>
<p>For <a class="reference external" href="#define-fwk-extn-dm-param-id-set-max-samples-0x0a00102b">FWK_EXTN_DM_PARAM_ID_SET_MAX_SAMPLES</a>, input port samples are samples to be provided to the module,</p>
<p>and output port samples are samples that are required from the module.</p>
<p>For <a class="reference external" href="#define-fwk-extn-dm-event-id-report-max-samples-0x0a00102c">FWK_EXTN_DM_EVENT_ID_REPORT_MAX_SAMPLES</a>, input port samples are samples required by the module,</p>
<p>and output port samples indicate that output buffer space is required.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Message payload (fwk_extn_dm_port_samples_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>port_index</p></td>
<td><p>Port index for which samples are being set.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>samples_per_channel</p></td>
<td><p>Number of samples per channel for the port.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="define-fwk-extn-dm-param-id-set-max-samples-0x0a00102b">
<h5>#define FWK_EXTN_DM_PARAM_ID_SET_MAX_SAMPLES 0x0A00102B<a class="headerlink" href="#define-fwk-extn-dm-param-id-set-max-samples-0x0a00102b" title="Link to this heading"></a></h5>
<p>ID of the parameter used to set either the maximum number of samples
that a module can provide when required on input, or the maximum
space required on output. Usage depends on the mode.</p>
<p>The module responds to this setting with <a class="reference external" href="#define-fwk-extn-dm-event-id-report-max-samples-0x0a00102c">FWK_EXTN_DM_EVENT_ID_REPORT_MAX_SAMPLES</a>.</p>
<p><strong>Message payload (fwk_extn_dm_param_id_req_samples_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint16_t</p></td>
<td><p>is_input</p></td>
<td><p>Indicates whether samples are being set for input or output ports.</p></td>
</tr>
<tr class="row-odd"><td><p>uint16_t</p></td>
<td><p>num_ports</p></td>
<td><p>Number of ports for which samples are being set.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#_bookmark404">fwk_extn_dm_-</a></p>
<p><a class="reference external" href="#_bookmark404">port_samples_t</a></p>
</td>
<td><p>req_samples</p></td>
<td><p>Array that contains the required samples.</p>
<p>For <a class="reference external" href="#define-fwk-extn-dm-param-id-set-max-samples-0x0a00102b">FWK_EXTN_DM_PARAM_ID_SET_MAX_SAMPLES</a>, input port samples are samples to be provided to the module,</p>
<p>and output port samples are samples that are required from the module.</p>
<p>For <a class="reference external" href="#define-fwk-extn-dm-event-id-report-max-samples-0x0a00102c">FWK_EXTN_DM_EVENT_ID_REPORT_MAX_SAMPLES</a>, input port samples are samples required by the module,</p>
<p>and output port samples indicate that output buffer space is required.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-fwk-extn-dm-event-id-report-max-samples-0x0a00102c">
<h5>#define FWK_EXTN_DM_EVENT_ID_REPORT_MAX_SAMPLES 0x0A00102C<a class="headerlink" href="#define-fwk-extn-dm-event-id-report-max-samples-0x0a00102c" title="Link to this heading"></a></h5>
<p>ID of the event used in response to <a class="reference external" href="#define-fwk-extn-dm-param-id-set-max-samples-0x0a00102b">FWK_EXTN_DM_PARAM_ID_SET_MAX_SAMPLES</a>.</p>
<p><strong>Message payload (fwk_extn_dm_param_id_req_samples_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint16_t</p></td>
<td><p>is_input</p></td>
<td><p>Indicates whether samples are being set for input or output ports.</p></td>
</tr>
<tr class="row-odd"><td><p>uint16_t</p></td>
<td><p>num_ports</p></td>
<td><p>Number of ports for which samples are being set.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#_bookmark404">fwk_extn_dm_-</a></p>
<p><a class="reference external" href="#_bookmark404">port_samples_t</a></p>
</td>
<td><p>req_samples</p></td>
<td><p>Array that contains the required samples.</p>
<p>For <a class="reference external" href="#define-fwk-extn-dm-param-id-set-max-samples-0x0a00102b">FWK_EXTN_DM_PARAM_ID_SET_MAX_SAMPLES</a>, input port samples are samples to be provided to the module,</p>
<p>and output port samples are samples that are required from the module.</p>
<p>For <a class="reference external" href="#define-fwk-extn-dm-event-id-report-max-samples-0x0a00102c">FWK_EXTN_DM_EVENT_ID_REPORT_MAX_SAMPLES</a>, input port samples are samples required by the module,</p>
<p>and output port samples indicate that output buffer space is required.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-fwk-extn-dm-event-id-disable-dm-0x0a00102d">
<h5>#define FWK_EXTN_DM_EVENT_ID_DISABLE_DM 0x0A00102D<a class="headerlink" href="#define-fwk-extn-dm-event-id-disable-dm-0x0a00102d" title="Link to this heading"></a></h5>
<p>ID of the event a module raises to disable or enable DM mode, which the framework sets with <a class="reference external" href="#define-fwk-extn-dm-param-id-change-mode-0x0a001028">FWK_EXTN_DM_PARAM_ID_CHANGE_MODE</a>.</p>
<p>Depending on the output media configuration or input media format,
the module can raise disable = 1 to indicate that it will not act as
a DM module. For example, a disabled rate matching module or a
resampler currently performing integer sample rate conversion.</p>
<p>The module can enable itself by raising disable = 0 when the it
starts fractional resampling.</p>
<p><strong>Message payload (fwk_extn_dm_event_id_disable_dm_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>disabled</p></td>
<td><p>Indicates whether the DM mode is disabled.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – <a class="reference external" href="#_bookmark414">FWK_EXTN_DM_ENABLED_DM</a></p></li>
<li><p>1 – <a class="reference external" href="#_bookmark415">FWK_EXTN_DM_DISABLED_DM</a></p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="enumeration-type-documentation">
<h4>Enumeration Type Documentation<a class="headerlink" href="#enumeration-type-documentation" title="Link to this heading"></a></h4>
<section id="enum-fwk-extn-dm-mode-t">
<h5>enum fwk_extn_dm_mode_t<a class="headerlink" href="#enum-fwk-extn-dm-mode-t" title="Link to this heading"></a></h5>
<p>Defines the data duration modifying modes.</p>
<p><strong>Enumerator:</strong></p>
<div class="line-block">
<div class="line"><strong>FWK_EXTN_DM_INVALID_MODE</strong> Invalid value.</div>
<div class="line"><strong>FWK_EXTN_DM_FIXED_INPUT_MODE</strong> Module runs in Fixed Input mode.</div>
<div class="line"><strong>FWK_EXTN_DM_FIXED_OUTPUT_MODE</strong> Module runs in Fixed Output mode.</div>
</div>
</section>
<section id="enum-event-id-disable-dm-supported-values-t">
<h5>enum event_id_disable_dm_supported_values_t<a class="headerlink" href="#enum-event-id-disable-dm-supported-values-t" title="Link to this heading"></a></h5>
<p>Defines the DM modes.</p>
<p><strong>Enumerator:</strong></p>
<div class="line-block">
<div class="line"><strong>FWK_EXTN_DM_ENABLED_DM</strong> Module can raise an event to
enable the DM mode (if it is currently in Disabled mode).</div>
</div>
<blockquote>
<div><p>By default, the module is assumed to be in Enabled mode. Once the
module is enabled, it can operate in fixed in/fixed out mode as set
by the framework.</p>
</div></blockquote>
<div class="line-block">
<div class="line"><strong>FWK_EXTN_DM_DISABLED_DM</strong> Module does not modify data
duration in the context of input media format or output media format
configuration.</div>
</div>
</section>
</section>
</section>
<section id="ecns">
<h3>ECNS<a class="headerlink" href="#ecns" title="Link to this heading"></a></h3>
<p>The ECNS framework extension (FWK_EXTN_ECNS) provides support for
the echo cancellation and noise suppression (ECNS) feature.</p>
<p>ECNS is a fundamental part of voice uplink processing. When a person
uses a phone to make a voice call, the sound played back on the
speaker is echoed back to the microphone electrically and
acoustically. This echo can be perceived by the far end and can vary
from mildly annoying to unacceptable, depending on how much coupling
exists.</p>
<p>EC algorithms cancel this echoed signal from the microphone input
with an adaptive filter that models the path taken by the echo. When
this model is combined with the signal played on the speaker, a
replica of the echo can be created, which is then subtracted from
the microphone signal. The noise suppressor suppresses the near-end
noise.</p>
<section id="id31">
<h4>Define Documentation<a class="headerlink" href="#id31" title="Link to this heading"></a></h4>
<section id="define-fwk-extn-ecns-0x0a00101e">
<h5>#define FWK_EXTN_ECNS 0x0A00101E<a class="headerlink" href="#define-fwk-extn-ecns-0x0a00101e" title="Link to this heading"></a></h5>
<p>Unique identifier of the custom framework extension used by modules that support the ECNS feature.</p>
</section>
</section>
</section>
<section id="multi-port-buffering">
<h3>Multi-port Buffering<a class="headerlink" href="#multi-port-buffering" title="Link to this heading"></a></h3>
<section id="id32">
<h4>Define Documentation<a class="headerlink" href="#id32" title="Link to this heading"></a></h4>
<section id="define-fwk-extn-multi-port-buffering-0x0a001010">
<h5>#define FWK_EXTN_MULTI_PORT_BUFFERING 0x0A001010<a class="headerlink" href="#define-fwk-extn-multi-port-buffering-0x0a001010" title="Link to this heading"></a></h5>
<p>Unique identifier of the framework extension used for multi-port buffering modules. The framework must recognize multi-port buffering.</p>
</section>
</section>
</section>
<section id="pcm">
<h3>PCM<a class="headerlink" href="#pcm" title="Link to this heading"></a></h3>
<p>The PCM framework extension (FWK_EXTN_PCM) is used for specific PCM use cases. The PCM modules (such as converter, decoder, and encoder) require the framework to support extended media formats and setting performance modes.</p>
<section id="id33">
<h4>Define Documentation<a class="headerlink" href="#id33" title="Link to this heading"></a></h4>
<section id="define-fwk-extn-pcm-0x0a001000">
<h5>#define FWK_EXTN_PCM 0x0A001000<a class="headerlink" href="#define-fwk-extn-pcm-0x0a001000" title="Link to this heading"></a></h5>
<p>Unique identifier of the framework extension for PCM modules.</p>
</section>
<section id="define-fwk-extn-pcm-param-id-media-format-extn-0x0a001001">
<h5>#define FWK_EXTN_PCM_PARAM_ID_MEDIA_FORMAT_EXTN 0x0A001001<a class="headerlink" href="#define-fwk-extn-pcm-param-id-media-format-extn-0x0a001001" title="Link to this heading"></a></h5>
<p>ID of the parameter that defines the extension to the media format. For an input media format:</p>
<ul class="simple">
<li><p>This parameter is always set before
<a class="reference external" href="#_bookmark247">CAPI_INPUT_MEDIA_FORMAT</a> or <a class="reference external" href="#_bookmark251">CAPI_INPUT_MEDIA_FORMAT_V2</a>.</p></li>
<li><p>Information from this format and the event must be handled in tandem.
For an output media format:</p></li>
<li><p>This parameter is always queried after the
<a class="reference external" href="#_bookmark332">CAPI_EVENT_OUTPUT_MEDIA_FORMAT_UPDATED</a> or
<a class="reference external" href="#_bookmark341">CAPI_EVENT_OUTPUT_MEDIA_FORMAT_UPDATED_V2</a>
event, or after the <a class="reference external" href="#_bookmark265">CAPI_OUTPUT_MEDIA_FORMAT</a>
property query.</p></li>
<li><p>Information from this format and the event or property query are
handled in tandem.</p></li>
</ul>
<p><strong>Message payload (fwk_extn_pcm_param_id_media_fmt_extn_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>bit_width</p></td>
<td><p>Width of the sample word size.</p>
<p>A CAPI media format has a bits_per_sample element (<a class="reference external" href="#struct-capi-standard-data-format-v2-t">capi_standard_data_format_v2_t</a>)</p>
<p>that stands for the sample word size. For example, if the bit_width is 24 bits, the</p>
<p>sample word size is 32 in Q27 format</p>
<ul class="simple">
<li><p>24-bit bit_width data placed in 24 bits has a sample word size of 24 (packed).</p></li>
<li><p>24-bit bit_width data placed in 32 bits has a sample word size of 32 (unpacked).</p></li>
</ul>
<p>Packing can be done in two ways: MSB aligned or LSB aligned.</p>
<ul>
<li><p>For MSB-aligned, the Q factor is 31 in <a class="reference external" href="#struct-capi-standard-data-format-v2-t">capi_standard_data_format_v2_t</a>, (set</p>
<p>q_factor to <a class="reference external" href="#define-capi-data-format-invalid-val-capi-invalid-val">CAPI_DATA_FORMAT_INVALID_VAL</a>).</p>
</li>
<li><p>For LSB aligned, the Q factor is 23.</p></li>
</ul>
<p>If the format is Q27, the actual bits_per_sample is 24.</p>
<p>32-bit bit_width data can be in Q31 format.</p>
<ul class="simple">
<li><p>The word size is always 32.</p></li>
<li><p>The alignment is <a class="reference external" href="#define-capi-data-format-invalid-val-capi-invalid-val">CAPI_DATA_FORMAT_INVALID_VAL</a>.</p></li>
</ul>
<p>16-bit bit_width data can be in Q15 format.</p>
<ul class="simple">
<li><p>The word size is 16 or 32.</p></li>
<li><p>If 16, alignment is <a class="reference external" href="#define-capi-data-format-invalid-val-capi-invalid-val">CAPI_DATA_FORMAT_INVALID_VAL</a>.</p></li>
<li><p>If 32, alignment can be MSB or LSB aligned.</p></li>
</ul>
<p>An invalid value = <a class="reference external" href="#define-capi-data-format-invalid-val-capi-invalid-val">CAPI_DATA_FORMAT_INVALID_VAL</a>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>alignment</p></td>
<td><p>Alignment of samples in a word.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>PCM_LSB_ALIGNED</p></li>
<li><p>PCM_MSB_ALIGNED</p></li>
</ul>
<p>An invalid value = <a class="reference external" href="#define-capi-data-format-invalid-val-capi-invalid-val">CAPI_DATA_FORMAT_INVALID_VAL</a></p>
</td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>endianness</p></td>
<td><p>Endianness of the data.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>PCM_LITTLE_ENDIAN</p></li>
<li><p>PCM_BIG_ENDIAN</p></li>
</ul>
<p>An invalid value = <a class="reference external" href="#define-capi-data-format-invalid-val-capi-invalid-val">CAPI_DATA_FORMAT_INVALID_VAL</a></p>
</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="id34">
<h3>Signal Triggered Module<a class="headerlink" href="#id34" title="Link to this heading"></a></h3>
<section id="id35">
<h4>Define Documentation<a class="headerlink" href="#id35" title="Link to this heading"></a></h4>
<section id="define-fwk-extn-stm-0x0a001003">
<h5>#define FWK_EXTN_STM 0x0A001003<a class="headerlink" href="#define-fwk-extn-stm-0x0a001003" title="Link to this heading"></a></h5>
<p>Unique identifier of the framework extension for the Signal Triggered Module (STM). This extension supports the following property and parameter IDs:</p>
<ul class="simple">
<li><p><a class="reference external" href="#define-fwk-extn-property-id-stm-trigger-0x0a001004">FWK_EXTN_PROPERTY_ID_STM_TRIGGER</a></p></li>
<li><p><a class="reference external" href="#define-fwk-extn-property-id-stm-ctrl-0x0a001005">FWK_EXTN_PROPERTY_ID_STM_CTRL</a></p></li>
<li><p><a class="reference external" href="#define-fwk-extn-param-id-latest-trigger-timestamp-ptr-0x0a001050">FWK_EXTN_PARAM_ID_LATEST_TRIGGER_TIMESTAMP_PTR</a></p></li>
</ul>
</section>
<section id="define-fwk-extn-property-id-stm-trigger-0x0a001004">
<h5>#define FWK_EXTN_PROPERTY_ID_STM_TRIGGER 0x0A001004<a class="headerlink" href="#define-fwk-extn-property-id-stm-trigger-0x0a001004" title="Link to this heading"></a></h5>
<p>ID of the custom property used to set a trigger.</p>
<p>Through this STM extension, the framework sends a signal to the modules. This signal is triggered as follows:</p>
<ul class="simple">
<li><p>Every interrupt for hardware endpoint modules</p></li>
<li><p>Every time the timer completes for timer-driven modules</p></li>
</ul>
<p><strong>Message payload (capi_prop_stm_trigger_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>void ∗</p></td>
<td><p>signal_ptr</p></td>
<td><p>Pointer to the signal from the framework.</p></td>
</tr>
<tr class="row-odd"><td><p>int32_t ∗</p></td>
<td><p>raised_intr_-</p>
<p>counter_ptr</p>
</td>
<td><p>The counter pointed to by this pointer is incremented by the module</p>
<p>whenever the signal is set/raised by an interrupt.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-fwk-extn-property-id-stm-ctrl-0x0a001005">
<h5>#define FWK_EXTN_PROPERTY_ID_STM_CTRL 0x0A001005<a class="headerlink" href="#define-fwk-extn-property-id-stm-ctrl-0x0a001005" title="Link to this heading"></a></h5>
<p>ID of the custom property used to set the STM to a specific state.</p>
<p>The framework uses this property ID to tell the module to start or stop.</p>
<p><strong>Message payload (capi_prop_stm_ctrl_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bool_t</p></td>
<td><p>enable</p></td>
<td><p>Specifies whether to enable the STM.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE (disable)</p></li>
<li><p>1 – TRUE (enable)</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-fwk-extn-event-id-is-signal-triggered-active-0x0a00100d">
<h5>#define FWK_EXTN_EVENT_ID_IS_SIGNAL_TRIGGERED_ACTIVE 0x0A00100D<a class="headerlink" href="#define-fwk-extn-event-id-is-signal-triggered-active-0x0a00100d" title="Link to this heading"></a></h5>
<p>ID of the event to update the module state to the framework (“is_signal_triggered_active”).</p>
<p><strong>Message payload (intf_extn_event_id_is_signal_triggered_active_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>is_signal_-</p>
<p>triggered_active</p>
</td>
<td><p>Specifies whether signal trigger is active</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE (disable)</p></li>
<li><p>1 – TRUE (enable)</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-fwk-extn-param-id-latest-trigger-timestamp-ptr-0x0a001050">
<h5>#define FWK_EXTN_PARAM_ID_LATEST_TRIGGER_TIMESTAMP_PTR 0x0A001050<a class="headerlink" href="#define-fwk-extn-param-id-latest-trigger-timestamp-ptr-0x0a001050" title="Link to this heading"></a></h5>
<p>ID of the parameter used to get the handle to query the latest latched signal trigger or interrupt timestamp from the STM module.</p>
<p>For hardware EP modules, this parameter corresponds to the pointer to the function which returns the latest latched hardware interface’s interrupt timestamp. If the trigger timestamp is not available, the module can return a NULL pointer or set the invalid  flag.</p>
<p><strong>Message payload (capi_param_id_stm_latest_trigger_ts_ptr_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="#_bookmark435">stm_latest_trigger_ts_t</a> ∗</p></td>
<td><p>ts_ptr</p></td>
<td><p>Pointer to the timestamp structure.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#typedef-ar-result-t-stm-get-ts-fn-ptr-t-void-context-ptr-uint64-t-intr-ts-ptr">stm_get_ts_fn_ptr_t</a></p></td>
<td><p>update_stm_ts_fptr</p></td>
<td><p>function pointer to get the latest STM timestamp</p></td>
</tr>
<tr class="row-even"><td><p>void ∗</p></td>
<td><p>stm_ts_ctxt_ptr</p></td>
<td><p>ptr to the dev handle of different ep-modules</p></td>
</tr>
</tbody>
</table>
<p><strong>Timestamp structure (stm_latest_trigger_ts_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bool_t</p></td>
<td><p>is_valid</p></td>
<td><p>Specifies whether the timestamp is valid.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – Not valid</p></li>
<li><p>1 – Valid</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>uint64_t</p></td>
<td><p>timestamp</p></td>
<td><p>Timestamp of the latest signal trigger or interrupt (updated in the</p>
<p><a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a> call).</p>
</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="id36">
<h4>Typedef Documentation<a class="headerlink" href="#id36" title="Link to this heading"></a></h4>
<section id="typedef-ar-result-t-stm-get-ts-fn-ptr-t-void-context-ptr-uint64-t-intr-ts-ptr">
<h5>typedef ar_result_t(∗ stm_get_ts_fn_ptr_t)(void ∗context_ptr, uint64_t ∗<strong>intr_ts_ptr)</strong><a class="headerlink" href="#typedef-ar-result-t-stm-get-ts-fn-ptr-t-void-context-ptr-uint64-t-intr-ts-ptr" title="Link to this heading"></a></h5>
<blockquote>
<div><p>Pointer to the function that updates the timestamp.</p>
</div></blockquote>
</section>
</section>
</section>
<section id="async-signal-triggered-module">
<h3>Async Signal Triggered Module<a class="headerlink" href="#async-signal-triggered-module" title="Link to this heading"></a></h3>
<section id="id37">
<h4>Define Documentation<a class="headerlink" href="#id37" title="Link to this heading"></a></h4>
<section id="define-fwk-extn-async-signal-trigger-0x0a001024">
<h5>#define FWK_EXTN_ASYNC_SIGNAL_TRIGGER 0x0A001024<a class="headerlink" href="#define-fwk-extn-async-signal-trigger-0x0a001024" title="Link to this heading"></a></h5>
<p>Unique identifier of the Async signal trigger framework extension. This extension supports the following property and parameter IDs:</p>
<ul class="simple">
<li><p><a class="reference external" href="#define-fwk-extn-property-id-async-signal-ctrl-0x0a001047">FWK_EXTN_PROPERTY_ID_ASYNC_SIGNAL_CTRL</a></p></li>
<li><p><a class="reference external" href="#define-fwk-extn-property-id-async-signal-callback-info-0x0a00105a">FWK_EXTN_PROPERTY_ID_ASYNC_SIGNAL_CALLBACK_INFO</a></p></li>
</ul>
</section>
<section id="define-fwk-extn-property-id-async-signal-ctrl-0x0a001047">
<h5>#define FWK_EXTN_PROPERTY_ID_ASYNC_SIGNAL_CTRL 0x0A001047<a class="headerlink" href="#define-fwk-extn-property-id-async-signal-ctrl-0x0a001047" title="Link to this heading"></a></h5>
<p>ID of the custom property used to share the async signal handle with the module. When the module sets this signal:</p>
<ol class="arabic simple">
<li><p>The container will be triggered with a command signal.</p></li>
<li><p>The container issues a module callback to inform the caller that the
signal is set.</p></li>
<li><p>The container calls the process after the callback is done, similar
to other commands.</p></li>
</ol>
<p>The async signal must not be used for periodic data trigger signals like the STM extension. Modules need this extension, to indicate if a module has dependency on a service that needs to trigger the module asynchronously.</p>
<p>For example:</p>
<ol class="arabic simple">
<li><p>If the module is waiting on a control interrupt from hardware, then
the module can register an ISR to set the async signal.</p></li>
<li><p>The container is woken up.</p></li>
<li><p>The container provides its context for the module to process the
async signal.</p></li>
</ol>
<p><strong>Message payload (capi_prop_async_signal_ctrl_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bool_t</p></td>
<td><p>enable</p></td>
<td><p>Specifies whether to enable the async STM .</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE (disable)</p></li>
<li><p>1 – TRUE (enable)</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>void ∗</p></td>
<td><p>async_signal_ptr</p></td>
<td><p>Pointer to the signal from the framework. Its valid only if enable=1</p></td>
</tr>
</tbody>
</table>
</section>
<section id="define-fwk-extn-property-id-async-signal-callback-info-0x0a00105a">
<h5>#define FWK_EXTN_PROPERTY_ID_ASYNC_SIGNAL_CALLBACK_INFO 0x0A00105A<a class="headerlink" href="#define-fwk-extn-property-id-async-signal-callback-info-0x0a00105a" title="Link to this heading"></a></h5>
<p>ID of the parameter used to get the callback info from the module. The framework issues the callback when the async signal triggers the container.</p>
<p>The callback must be island safe and the module is responsible to exit the island from the callback if necessary.</p>
<p><strong>Message payload (capi_prop_async_signal_callback_info_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="#typedef-ar-result-t-fwk-extn-async-signal-callback-fn-ptr-t-void-module-context-ptr">fwk_extn_async_-</a></p>
<p><a class="reference external" href="#typedef-ar-result-t-fwk-extn-async-signal-callback-fn-ptr-t-void-module-context-ptr">signal_callback_fn_ptr_t</a></p>
</td>
<td><p>module_-</p>
<p>callback_fptr</p>
</td>
<td><p>Callback function pointer called by the framework when the async</p>
<p>signal is set. The callback must be island safe and modules are</p>
<p>responsible for exiting the island from the callback if necessary.</p>
</td>
</tr>
<tr class="row-odd"><td><p>void ∗</p></td>
<td><p>module_-</p>
<p>context_ptr</p>
</td>
<td><p>The module handle passed to the callback as an argument.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="id38">
<h4>Typedef Documentation<a class="headerlink" href="#id38" title="Link to this heading"></a></h4>
<section id="typedef-ar-result-t-fwk-extn-async-signal-callback-fn-ptr-t-void-module-context-ptr">
<h5>typedef ar_result_t(∗fwk_extn_async_signal_callback_fn_ptr_t)(void ∗<strong>module_context_ptr)</strong><a class="headerlink" href="#typedef-ar-result-t-fwk-extn-async-signal-callback-fn-ptr-t-void-module-context-ptr" title="Link to this heading"></a></h5>
<p>Pointer to the function that updates the timestamp.</p>
</section>
</section>
</section>
<section id="soft-timer">
<h3>Soft Timer<a class="headerlink" href="#soft-timer" title="Link to this heading"></a></h3>
<p>The CAPI soft timer framework extension (FWK_EXTN_SOFT_TIMER) defines the soft timers that are used to start and disable timers and send a <a class="reference external" href="#capi-err-t-capi-vtbl-t-set-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr">capi_vtbl_t::set_param()</a> to the corresponding module when the timer expires.</p>
<p>In this case, <em>soft</em> means the timer is not expected to be precise because it runs in the same thread as the framework <a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a> call and it has a lower priority.</p>
<section id="id39">
<h4>Define Documentation<a class="headerlink" href="#id39" title="Link to this heading"></a></h4>
<section id="define-fwk-extn-soft-timer-0x0a001008">
<h5>#define FWK_EXTN_SOFT_TIMER 0x0A001008<a class="headerlink" href="#define-fwk-extn-soft-timer-0x0a001008" title="Link to this heading"></a></h5>
<p>Unique identifier of the framework extension for soft timers.</p>
</section>
<section id="define-fwk-extn-event-id-soft-timer-start-0x0a001009">
<h5>#define FWK_EXTN_EVENT_ID_SOFT_TIMER_START 0x0A001009<a class="headerlink" href="#define-fwk-extn-event-id-soft-timer-start-0x0a001009" title="Link to this heading"></a></h5>
<p>ID of the custom event used to notify the framework to start a timer.</p>
<p><strong>Message payload (fwk_extn_event_id_soft_timer_start_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>timer_id</p></td>
<td><p>Identifies the specific timer to be started.</p>
<p><strong>Supported values:</strong> 0 to 15000</p>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>duration_ms</p></td>
<td><p>Indicates the duration when the timer is to finish (in milliseconds).</p>
<p><strong>Supported values:</strong> 0 to 15000</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-fwk-extn-event-id-soft-timer-disable-0x0a00100a">
<h5>#define FWK_EXTN_EVENT_ID_SOFT_TIMER_DISABLE 0x0A00100A<a class="headerlink" href="#define-fwk-extn-event-id-soft-timer-disable-0x0a00100a" title="Link to this heading"></a></h5>
<p>ID of the custom event used to notify the framework to disable the timer.</p>
<p><strong>Message payload (fwk_extn_event_id_soft_timer_disable_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>timer_id</p></td>
<td><p>Identifies the specific timer to be disabled.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="define-fwk-extn-param-id-soft-timer-expired-0x0a00100b">
<h5>#define FWK_EXTN_PARAM_ID_SOFT_TIMER_EXPIRED 0x0A00100B<a class="headerlink" href="#define-fwk-extn-param-id-soft-timer-expired-0x0a00100b" title="Link to this heading"></a></h5>
<p>ID of the parameter used to notify a module that the timer expired.</p>
<p><strong>Message payload (fwk_extn_param_id_soft_timer_expired_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>timer_id</p></td>
<td><p>Identifies the specific timer that sends this parameter to the module.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="synchronization">
<h3>Synchronization<a class="headerlink" href="#synchronization" title="Link to this heading"></a></h3>
<p>The Synchronization module framework extension is required for the following purposes:</p>
<ul class="simple">
<li><p>During synchronization, the module must disable framework-layer
threshold buffering.</p>
<ul>
<li><p>The module has a synchronization error that is dependent on the
amount of time between subsequent buffer arrivals. Therefore, it
is imperative that the module receives input data immediately when
that data arrives at its host container.</p></li>
<li><p>Once the ports are synchronized, the module no longer has this
requirement and it can re-enable threshold buffering.</p></li>
<li><p>The module uses
<a class="reference external" href="#define-fwk-extn-sync-event-id-enable-threshold-buffering-0x0a00101b">FWK_EXTN_SYNC_EVENT_ID_ENABLE_THRESHOLD_BUFFERING</a>
for enabling and disabling the buffering.</p></li>
</ul>
</li>
<li><p>The framework must inform the module of the threshold by using the
FWK_EXTN_PARAM_ID_CONTAINER_FRAME_DURATION set parameter in the
<a class="reference external" href="#define-fwk-extn-container-frame-duration-0x0a001021">FWK_EXTN_CONTAINER_FRAME_DURATION</a>
extension.</p></li>
<li><p>When an external port is started, the Synchronization module receives
a
<a class="reference external" href="#define-fwk-extn-sync-param-id-port-will-start-0x0a00101d">FWK_EXTN_SYNC_PARAM_ID_PORT_WILL_START</a>
set parameter that indicates when that port will start.</p>
<ul>
<li><p>This set parameter is necessary because the mere presence of input
data implies data flow is starting. However, input data is not
sent to the Synchronization module until the entire threshold is
buffered on all ports.</p></li>
<li><p>The Synchronization module must receive this set parameter so it
can tell the container to disable the threshold. Then when the
first data buffer is received, the framework can immediately send
that buffer to the Synchronization module.</p></li>
<li><p>When the Synchronization module receives this set parameter, it is
not required to know which port was started. This command is only
handled when any of the module’s ports are stopped; otherwise, the
parameter is ignored.</p></li>
<li><p>This framework extension includes an
FWK_EXTN_SYNC_EVENT_ID_DATA_PORT_ACTIVITY_STATE event.
This event, if raised by the module, indicates that a particular
port is active/inactive. The framework can use this information to
optimally copy data between only the active ports and invoke
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
on the module.</p></li>
</ul>
</li>
<li><p>This event should only be raised on an output port of the Sync module
if and only if the input port associated with it is not opened
(closed).</p></li>
<li><p>By default, all ports are deemed active by the framework.</p></li>
<li><p>If a module has already disabled threshold buffering and a new input
port starts or an output media format is propagated then the module
must raise a duplicate threshold buffering disabled event.</p></li>
</ul>
<p><strong>NOTE</strong> The Synchronization framework extension is specific to
Synchronization module behavior. Thus, it is not expected to be
required for any custom or non-synchronization modules.</p>
<section id="id40">
<h4>Define Documentation<a class="headerlink" href="#id40" title="Link to this heading"></a></h4>
<section id="define-fwk-extn-sync-0x0a00101a">
<h5>#define FWK_EXTN_SYNC 0x0A00101A<a class="headerlink" href="#define-fwk-extn-sync-0x0a00101a" title="Link to this heading"></a></h5>
<p>Unique identifier of the framework extension for the Synchronization module, which is used to synchronize data at its inputs.</p>
<p>This extension supports the following event and parameter IDs:</p>
<ul class="simple">
<li><p><a class="reference external" href="#define-fwk-extn-sync-event-id-enable-threshold-buffering-0x0a00101b">FWK_EXTN_SYNC_EVENT_ID_ENABLE_THRESHOLD_BUFFERING</a></p></li>
<li><p><a class="reference external" href="#define-fwk-extn-sync-param-id-port-will-start-0x0a00101d">FWK_EXTN_SYNC_PARAM_ID_PORT_WILL_START</a></p></li>
<li><p><a class="reference external" href="#define-fwk-extn-sync-event-id-data-port-activity-state-0x08001372">FWK_EXTN_SYNC_EVENT_ID_DATA_PORT_ACTIVITY_STATE</a></p></li>
</ul>
</section>
<section id="define-fwk-extn-sync-event-id-enable-threshold-buffering-0x0a00101b">
<h5>#define FWK_EXTN_SYNC_EVENT_ID_ENABLE_THRESHOLD_BUFFERING 0x0A00101B<a class="headerlink" href="#define-fwk-extn-sync-event-id-enable-threshold-buffering-0x0a00101b" title="Link to this heading"></a></h5>
<p>ID of the custom event raised when the Synchronization module enables or disables threshold buffering.</p>
<p>With threshold buffering disabled, the framework invokes the topology whenever input data is received, regardless of whether the threshold amount of input data is met.</p>
<p><strong>Message payload (fwk_extn_sync_event_id_enable_threshold_buffering_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bool_t</p></td>
<td><p>enable_-</p>
<p>threshold_buffering</p>
</td>
<td><p>Indicates whether threshold buffering is to be enabled.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – Disabled</p></li>
<li><p>1 – Enabled</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-fwk-extn-sync-param-id-port-will-start-0x0a00101d">
<h5>#define FWK_EXTN_SYNC_PARAM_ID_PORT_WILL_START 0x0A00101D<a class="headerlink" href="#define-fwk-extn-sync-param-id-port-will-start-0x0a00101d" title="Link to this heading"></a></h5>
<p>ID of the custom parameter a container sends when an external input port connected to the Synchronization module moves to the Start state. The module then raises a disable threshold event to accept partial data to begin the synchronization process.</p>
</section>
<section id="define-fwk-extn-sync-event-id-data-port-activity-state-0x08001372">
<h5>#define FWK_EXTN_SYNC_EVENT_ID_DATA_PORT_ACTIVITY_STATE 0x08001372<a class="headerlink" href="#define-fwk-extn-sync-event-id-data-port-activity-state-0x08001372" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>is_inactive</p></td>
<td><p>Indicates whether the port state is inactive.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE (active)</p></li>
<li><p>1 – TRUE (inactive)</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>out_port_index</p></td>
<td><p>Output port index, depending on the value of is_input.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="id41">
<h3>Threshold Configuration<a class="headerlink" href="#id41" title="Link to this heading"></a></h3>
<section id="id42">
<h4>Define Documentation<a class="headerlink" href="#id42" title="Link to this heading"></a></h4>
<section id="define-fwk-extn-threshold-configuration-0x0a00104d">
<h5>#define FWK_EXTN_THRESHOLD_CONFIGURATION 0x0A00104D<a class="headerlink" href="#define-fwk-extn-threshold-configuration-0x0a00104d" title="Link to this heading"></a></h5>
<blockquote>
<div><p>Unique identifier of the framework extension that modules use to get
the nominal frame duration (in microseconds) from the framework.</p>
</div></blockquote>
</section>
<section id="define-fwk-extn-param-id-threshold-cfg-0x0a00104e">
<h5>#define FWK_EXTN_PARAM_ID_THRESHOLD_CFG 0x0A00104E<a class="headerlink" href="#define-fwk-extn-param-id-threshold-cfg-0x0a00104e" title="Link to this heading"></a></h5>
<blockquote>
<div><p>ID of the parameter used configure the threshold based on the
performance mode of the graph.</p>
<p><strong>Message payload (fwk_extn_param_id_threshold_cfg_t)</strong></p>
</div></blockquote>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>duration_us</p></td>
<td><p>Threshold configuration (in microseconds) based on the</p>
<p>performance mode of the graph.</p>
<p>The actual container frame duration might be different depending on other threshold modules. See <a class="reference external" href="#define-fwk-extn-container-frame-duration-0x0a001021">FWK_EXTN_CONTAINER_FRAME_DURATION</a>.</p>
</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="id43">
<h3>Trigger Policy<a class="headerlink" href="#id43" title="Link to this heading"></a></h3>
<section id="id44">
<h4>Define Documentation<a class="headerlink" href="#id44" title="Link to this heading"></a></h4>
<section id="define-fwk-extn-trigger-policy-0x0a00103a">
<h5>#define FWK_EXTN_TRIGGER_POLICY 0x0A00103A<a class="headerlink" href="#define-fwk-extn-trigger-policy-0x0a00103a" title="Link to this heading"></a></h5>
<p>Unique identifier of the framework extension that modules use to decide on a trigger policy. (For more information, see <a class="reference internal" href="#id8"><span class="std std-ref">Trigger Policy</span></a>)</p>
</section>
<section id="define-fwk-extn-param-id-trigger-policy-cb-fn-0x0a00103b">
<h5>#define FWK_EXTN_PARAM_ID_TRIGGER_POLICY_CB_FN 0x0A00103B<a class="headerlink" href="#define-fwk-extn-param-id-trigger-policy-cb-fn-0x0a00103b" title="Link to this heading"></a></h5>
<p>ID of the parameter a module uses to decide when its process() function is to be called.
<strong>Message payload (fwk_extn_param_id_trigger_policy_cb_fn_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>version</p></td>
<td><p>Version of this payload (currently 1).</p>
<p>In subsequent versions, extra fields might be present, but no fields will be removed.</p>
</td>
</tr>
<tr class="row-odd"><td><p>void ∗</p></td>
<td><p>context_ptr</p></td>
<td><p>Pointer to the argument that must be passed to</p>
<p><a class="reference external" href="#_bookmark474">fwk_extn_change_trigger_policy_fn()</a>.</p>
</td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#_bookmark474">fwk_extn_-</a></p>
<p><a class="reference external" href="#_bookmark474">change_trigger-</a></p>
<p><a class="reference external" href="#_bookmark474">_policy_fn</a></p>
</td>
<td><p>change_data_-</p>
<p>trigger_policy-</p>
<p>_cb_fn</p>
</td>
<td><p>Callback function to change the data trigger policy.</p>
<p>The policy affects future <a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a> calls. The callback can also be made from a process() call.</p>
</td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#_bookmark474">fwk_extn_-</a></p>
<p><a class="reference external" href="#_bookmark474">change_trigger-</a></p>
<p><a class="reference external" href="#_bookmark474">_policy_fn</a></p>
</td>
<td><p>change_signal-</p>
<p>_trigger_policy_cb_fn</p>
</td>
<td><p>Callback function to change the signal trigger policy.</p>
<p>The policy affects future <a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a> calls. The callback can also be made from a process() call.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-fwk-extn-event-id-data-trigger-in-st-cntr-0x0a00104c">
<h5>#define FWK_EXTN_EVENT_ID_DATA_TRIGGER_IN_ST_CNTR 0x0A00104C<a class="headerlink" href="#define-fwk-extn-event-id-data-trigger-in-st-cntr-0x0a00104c" title="Link to this heading"></a></h5>
<p>ID of the event the trigger policy module raises to enable or
disable a data trigger if the module is in a signal-triggered
container.</p>
<p>The module process() is called only when a signal trigger occurs and
its data trigger policies are ignored.</p>
<p>The signal-triggered container’s topology process cannot be called
with a data trigger unless a module that can buffer or drop the data
is before the STM module. If the module is a buffering module or if
it handles the data dropping, it can raise this event to allow
process() to be called with a data trigger in the signal-triggered container.</p>
<p>Most module are not required to raise this event, such as a module
that is to change a signal trigger policy.</p>
<p>For more details, see <a class="reference internal" href="#trigger-types"><span class="std std-ref">Types of Triggers</span></a>.</p>
<p><strong>Message payload (fwk_extn_event_id_data_trigger_in_st_cntr_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>is_enable</p></td>
<td><p>Indicates whether to allow a topology process with a data trigger to</p>
<p>be in an ST container.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE (error; do not allow topology process)</p></li>
<li><p>1 – TRUE (allow topology process)</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>needs_input_-</p>
<p>triggers</p>
</td>
<td><p>Indicates whether this module consumes input during data triggers</p>
<p>in STM containers.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE; module doesn’t consume input for data triggers in STM containers</p></li>
<li><p>1 – TRUE; module consumes input for data triggers in STM containers</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>needs_output_-</p>
<p>triggers</p>
</td>
<td><p>Indicates whether this module generates output during data triggers</p>
<p>in STM containers.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE; module doesn’t generate output for data triggers in STM containers</p></li>
<li><p>1 – TRUE; module generates output for data triggers in STM containers</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="id45">
<h4>Data Structure Documentation<a class="headerlink" href="#id45" title="Link to this heading"></a></h4>
<section id="struct-fwk-extn-port-nontrigger-group-t">
<h5>struct fwk_extn_port_nontrigger_group_t<a class="headerlink" href="#struct-fwk-extn-port-nontrigger-group-t" title="Link to this heading"></a></h5>
<p>Defines a non-triggerable group of ports.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="#enum-fwk-extn-port-nontrigger-policy-t">fwk_extn_port_nontrigger_policy_t</a> ∗</p></td>
<td><p>in_port_grp_-</p>
<p>policy_ptr</p>
</td>
<td><p>Pointer to the array that contains a value at the input port index. This</p>
<p>value indicates that the port belongs to the optional non-triggerable or blocked group.</p>
<p>The array is as big as the maximum number of input ports (as indicated in <a class="reference external" href="#_bookmark245">CAPI_PORT_NUM_INFO</a>).</p>
</td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#enum-fwk-extn-port-nontrigger-policy-t">fwk_extn_port_nontrigger_policy_t</a> ∗</p></td>
<td><p>out_port_grp_-</p>
<p>policy_ptr</p>
</td>
<td><p>Pointer to the array that contains a value at the output port index.</p>
<p>This value indicates that the port belongs to the optional non-triggerable or blocked group.</p>
<p>The array is as big as the maximum number of output ports (as indicated in <a class="reference external" href="#_bookmark245">CAPI_PORT_NUM_INFO</a>).</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="struct-fwk-extn-port-trigger-group-t">
<h5>struct fwk_extn_port_trigger_group_t<a class="headerlink" href="#struct-fwk-extn-port-trigger-group-t" title="Link to this heading"></a></h5>
<p>Defines a triggerable group of ports.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="#enum-fwk-extn-port-trigger-affinity-t">fwk_extn_port_trigger_affinity_t</a>  ∗</p></td>
<td><p>in_port_grp_-</p>
<p>affinity_ptr</p>
</td>
<td><p>Pointer to the array that contains a value at the input port index, if</p>
<p>the input port belongs to the group.</p>
<p>The array is as big as the maximum number of input ports (as indicated in <a class="reference external" href="#_bookmark245">CAPI_PORT_NUM_INFO</a>).</p>
</td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#enum-fwk-extn-port-trigger-affinity-t">fwk_extn_port_trigger_affinity_t</a> ∗</p></td>
<td><p>out_port_grp_-</p>
<p>affinity_ptr</p>
</td>
<td><p>Pointer to the array that contains a value at the output port index, if</p>
<p>the output port belongs to the group.</p>
<p>The array is as big as the maximum number of output ports (as indicated in <a class="reference external" href="#_bookmark245">CAPI_PORT_NUM_INFO</a>).</p>
</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="id46">
<h4>Typedef Documentation<a class="headerlink" href="#id46" title="Link to this heading"></a></h4>
<p><strong>typedef capi_err_t(</strong>∗ <strong>fwk_extn_change_trigger_policy_fn)(void</strong> ∗<strong>context_ptr, fwk_extn_port_nontrigger_group_t</strong> ∗<strong>nontriggerable_ports_ptr,</strong> <strong>fwk_extn_port_trigger_policy_t port_trigger_policy, uint32_t num_groups, fwk_extn_port_trigger_group_t</strong> ∗<strong>triggerable_groups_ptr)</strong></p>
<p>Callback function that changes the trigger policy.</p>
<p><strong>Associated data types</strong></p>
<p><cite>fwk_extn_port_nontrigger_group_t</cite></p>
<p><cite>fwk_extn_port_trigger_policy_t</cite></p>
<p><cite>fwk_extn_port_trigger_group_t</cite></p>
<blockquote>
<div><p><strong>Parameters</strong></p>
</div></blockquote>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>in</p></th>
<th class="head"><p><em>context_ptr</em></p></th>
<th class="head"><p>Pointer to the context given by the container in</p>
<p><a class="reference external" href="#define-fwk-extn-param-id-trigger-policy-cb-fn-0x0a00103b">FWK_EXTN_PARAM_ID_TRIGGER_POLICY_CB_FN</a>.</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>nontriggerable_-</em></p>
<p><em>ports_ptr</em></p>
</td>
<td><p>Pointer to the <a class="reference external" href="#enum-fwk-extn-port-nontrigger-policy-t">fwk_extn_port_nontrigger_policy_t</a> structure that</p>
<p>indicates which ports are optional non-triggerable and which ports are blocked.</p>
<p>The value can be NULL if there are no nontriggerable or blocked ports.</p>
</td>
</tr>
<tr class="row-odd"><td><p>in</p></td>
<td><p><em>port_trigger_policy</em></p></td>
<td><p>Type of trigger policy for a port: mandatory or optional.</p></td>
</tr>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>num_groups</em></p></td>
<td><p>Number of elements in the array.</p></td>
</tr>
<tr class="row-odd"><td><p>in</p></td>
<td><p><em>triggerable_groups_-</em></p>
<p><em>ptr</em></p>
</td>
<td><p>Pointer to the array of length num_groups, where each element</p>
<p>is of type <a class="reference external" href="#enum-fwk-extn-port-trigger-policy-t">fwk_extn_port_trigger_policy_t</a>.</p>
<p>Any call to this function replaces the previous call’s values for all ports.</p>
<p>For the signal trigger policy, nontriggerable_ports_ptr must be NULL because non-trigger policies are not yet supported.</p>
</td>
</tr>
</tbody>
</table>
<p>Modules may require trigger control only in transient states and may not require it in steady states. In that case, a module can remove custom non-trigger and trigger policies by setting the nontriggerable_ports_ptr and triggerable_groups_ptr to NULL. In   this case, the framework switches to the default policies.</p>
<p>Modules should try to remove policies as long as they can, as this removes overhead from the framework. Modules are also allowed to disable themselves after removing the trigger policy.</p>
</section>
<section id="id47">
<h4>Enumeration Type Documentation<a class="headerlink" href="#id47" title="Link to this heading"></a></h4>
<section id="enum-fwk-extn-port-trigger-policy-t">
<h5>enum fwk_extn_port_trigger_policy_t<a class="headerlink" href="#enum-fwk-extn-port-trigger-policy-t" title="Link to this heading"></a></h5>
<p>Types of trigger groups that indicate whether multiple ports in a group must be ANDED or ORed. (For more information, see <a class="reference internal" href="#triggerable-ports"><span class="std std-ref">Triggerable Ports</span></a>.)</p>
<p><strong>Enumerator:</strong></p>
<p><strong>FWK_EXTN_PORT_TRIGGER_POLICY_MANDATORY</strong> All ports in a group must satisfy the trigger specified through <a class="reference external" href="#enum-fwk-extn-port-trigger-affinity-t">fwk_extn_port_trigger_affinity_t</a>.</p>
<p><strong>FWK_EXTN_PORT_TRIGGER_POLICY_OPTIONAL</strong> Any port in a group is sufficient to trigger a <a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a> call.</p>
</section>
<section id="enum-fwk-extn-port-nontrigger-policy-t">
<h5>enum fwk_extn_port_nontrigger_policy_t<a class="headerlink" href="#enum-fwk-extn-port-nontrigger-policy-t" title="Link to this heading"></a></h5>
<p>Types of non-trigger groups. (For details, see <a class="reference internal" href="#non-triggerable-and-blocked-ports"><span class="std std-ref">Non-triggerable Ports and Blocked Ports</span></a>.)</p>
<p><strong>Enumerator:</strong></p>
<p><strong>FWK_EXTN_PORT_NON_TRIGGER_INVALID</strong> Invalid value (default).</p>
<p><strong>FWK_EXTN_PORT_NON_TRIGGER_OPTIONAL</strong> Optional non-triggerable port that never triggers a <a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a> call.</p>
<p><strong>FWK_EXTN_PORT_NON_TRIGGER_BLOCKED</strong> Blocked port that does not trigger the module even if there is data or a buffer.</p>
</section>
<section id="enum-fwk-extn-port-trigger-affinity-t">
<h5>enum fwk_extn_port_trigger_affinity_t<a class="headerlink" href="#enum-fwk-extn-port-trigger-affinity-t" title="Link to this heading"></a></h5>
<p>Types of affinity modes for a port.</p>
<p><strong>Enumerator:</strong></p>
<p><strong>FWK_EXTN_PORT_TRIGGER_AFFINITY_NONE</strong> Indicates that the port does not belong to this group.</p>
<p><strong>FWK_EXTN_PORT_TRIGGER_AFFINITY_PRESENT</strong> Indicates that the presence of a trigger on the port contributes to the group trigger.</p>
<p><strong>FWK_EXTN_PORT_TRIGGER_AFFINITY_ABSENT</strong> Currently not supported.</p>
<p>Indicates that the absence of a trigger on the port contributes to the group trigger (the port must still be started).</p>
</section>
</section>
</section>
<section id="voice-delivery">
<h3>Voice Delivery<a class="headerlink" href="#voice-delivery" title="Link to this heading"></a></h3>
<p>The voice delivery framework extension (<a class="reference external" href="#define-fwk-extn-voice-delivery-0x0a00103d">FWK_EXTN_VOICE_DELIVERY</a>) allows a module to control the timing of its host container’s topology invocations.</p>
<p>This extension is required for voice use cases when data processing must begin at a precise time each VFR cycle; but, within that VFR cycle, multiple frames might need to be processed as soon as possible. To achieve this, the container must switch between
timer-triggered and buffer-triggered topology invocation policies. This customized behavior is placed within a module that implements the FWK_EXTN_VOICE_DELIVERY extension.</p>
<p>A module that implements the FWK_EXTN_VOICE_DELIVERY extension is responsible for the following:</p>
<ul class="simple">
<li><p>Subscribing to the voice timer to receive periodic triggers when receiving the <a class="reference external" href="#define-fwk-extn-property-id-voice-proc-start-trigger-0x0a00103e">FWK_EXTN_PROPERTY_ID_VOICE_PROC_START_TRIGGER</a> property.</p></li>
<li><p>Raising the <a class="reference external" href="#define-fwk-extn-voice-delivery-event-id-change-container-trigger-policy-0x0a00103f">FWK_EXTN_VOICE_DELIVERY_EVENT_ID_CHANGE_CONTAINER_TRIGGER_POLICY</a> to tell the host container when to switch between timer-triggered and buffer-triggered policies.</p></li>
<li><p>Receiving <a class="reference external" href="#define-fwk-extn-voice-delivery-param-id-first-proc-tick-notif-0x0a00104f">FWK_EXTN_VOICE_DELIVERY_PARAM_ID_FIRST_PROC_TICK_NOTIF</a> when the first timer trigger expires. The module can use this information as a signal to begin outputting data.</p></li>
</ul>
<p><strong>NOTE</strong> This framework extension is specific to the Smart Synchronization module behavior, and thus it is not expected to be required for any other module.</p>
<section id="id48">
<h4>Define Documentation<a class="headerlink" href="#id48" title="Link to this heading"></a></h4>
<section id="define-fwk-extn-voice-delivery-0x0a00103d">
<h5>#define FWK_EXTN_VOICE_DELIVERY 0x0A00103D<a class="headerlink" href="#define-fwk-extn-voice-delivery-0x0a00103d" title="Link to this heading"></a></h5>
<p>Unique identifier of the framework extension used for the Voice Delivery module. This extension supports the following property, event, and parameter IDs:</p>
<ul class="simple">
<li><p><a class="reference external" href="#define-fwk-extn-property-id-voice-proc-start-trigger-0x0a00103e">FWK_EXTN_PROPERTY_ID_VOICE_PROC_START_TRIGGER</a></p></li>
<li><p><a class="reference external" href="#define-fwk-extn-voice-delivery-event-id-change-container-trigger-policy-0x0a00103f">FWK_EXTN_VOICE_DELIVERY_EVENT_ID_CHANGE_CONTAINER_TRIGGER_POLICY</a></p></li>
<li><p><a class="reference external" href="#define-fwk-extn-voice-delivery-param-id-first-proc-tick-notif-0x0a00104f">FWK_EXTN_VOICE_DELIVERY_PARAM_ID_FIRST_PROC_TICK_NOTIF</a></p></li>
</ul>
</section>
<section id="define-fwk-extn-property-id-voice-proc-start-trigger-0x0a00103e">
<h5>#define FWK_EXTN_PROPERTY_ID_VOICE_PROC_START_TRIGGER 0x0A00103E<a class="headerlink" href="#define-fwk-extn-property-id-voice-proc-start-trigger-0x0a00103e" title="Link to this heading"></a></h5>
<p>ID of the custom property used to set the trigger for voice processing to start.</p>
<p>The framework sends a signal to the Voice Delivery module to register the voice timer for any VFR tick.</p>
<p><strong>Message payload (capi_prop_voice_proc_start_trigger_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>void ∗</p></td>
<td><p>proc_start_-</p>
<p>signal_ptr</p>
</td>
<td><p>Pointer to a posal_signal_t that is owned by the framework.</p>
<p>This signal should be set when the timer trigger expires. The framework timer trigger handling will occur when this signal is set.</p>
<p>The pointer is set via the <a class="reference external" href="#define-fwk-extn-property-id-voice-proc-start-trigger-0x0a00103e">FWK_EXTN_PROPERTY_ID_VOICE_-</a></p>
<p><a class="reference external" href="#define-fwk-extn-property-id-voice-proc-start-trigger-0x0a00103e">PROC_START_TRIGGER</a></p>
<p>property.</p>
</td>
</tr>
<tr class="row-odd"><td><p>void ∗</p></td>
<td><p>resync_signal_-</p>
<p>ptr</p>
</td>
<td><p>Resync signal to the framework posal_signal_t.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="define-fwk-extn-voice-delivery-event-id-change-container-trigger-policy-0x0a00103f">
<h5>#define FWK_EXTN_VOICE_DELIVERY_EVENT_ID_CHANGE_CONTAINER_TRIGGER_POLICY 0x0A00103F<a class="headerlink" href="#define-fwk-extn-voice-delivery-event-id-change-container-trigger-policy-0x0a00103f" title="Link to this heading"></a></h5>
<p>ID of the event the Voice Delivery module raises to set the container trigger policy. The container determines when to start processing based on the trigger policy.</p>
<ul class="simple">
<li><p>The module raises this event with the VOICE_TIMER_TRIGGER policy to request that the host container triggers processing based on timer expiration.</p></li>
<li><p>The module raises this event with the OUTPUT_BUFFER_TRIGGER policy to request that the host container triggers processing based on the arrival of an output buffer.</p></li>
</ul>
<p><strong>Message payload (capi_event_change_container_trigger_policy_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="#enum-container-trigger-policy-t">container_-</a></p>
<p><a class="reference external" href="#enum-container-trigger-policy-t">trigger_policy_t</a></p>
</td>
<td><p>container_-</p>
<p>trigger_policy</p>
</td>
<td><p>Trigger policy the container uses to determine when to invoke the</p>
<p>topology.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-fwk-extn-voice-delivery-param-id-first-proc-tick-notif-0x0a00104f">
<h5>#define FWK_EXTN_VOICE_DELIVERY_PARAM_ID_FIRST_PROC_TICK_NOTIF 0x0A00104F<a class="headerlink" href="#define-fwk-extn-voice-delivery-param-id-first-proc-tick-notif-0x0a00104f" title="Link to this heading"></a></h5>
<p>ID of the custom parameter used to notify the Voice Delivery module that the container received the first processing tick.</p>
<p>This parameter is set to the module when the first processing tick is received after any of the following occur:</p>
<ul class="simple">
<li><p>The Voice Delivery module’s subgraph switches from the Stop state to
the Start state.</p></li>
<li><p>The Voice Delivery module’s subgraph switches from the Suspend state
to the Start state.</p></li>
<li><p>A resynchronization occurs.</p></li>
</ul>
</section>
<section id="define-fwk-extn-voice-delivery-param-id-resync-notif-0x0a001055">
<h5>#define FWK_EXTN_VOICE_DELIVERY_PARAM_ID_RESYNC_NOTIF 0x0A001055<a class="headerlink" href="#define-fwk-extn-voice-delivery-param-id-resync-notif-0x0a001055" title="Link to this heading"></a></h5>
<p>Custom parameter ID to inform the voice delivery module of the container’s reception of the VFR resync. This parameter has no payload.</p>
</section>
<section id="define-fwk-extn-voice-delivery-param-id-data-drop-during-sync-0x0a001007">
<h5>#define FWK_EXTN_VOICE_DELIVERY_PARAM_ID_DATA_DROP_DURING_SYNC 0x0A001007<a class="headerlink" href="#define-fwk-extn-voice-delivery-param-id-data-drop-during-sync-0x0a001007" title="Link to this heading"></a></h5>
<p>Custom parameter ID to inform the voice delivery module that there was upstream data drop which occurred while the voice delivery module is in the Syncing state.</p>
</section>
<section id="define-fwk-extn-voice-delivery-param-id-topo-process-notif-0x0a001017">
<h5>#define FWK_EXTN_VOICE_DELIVERY_PARAM_ID_TOPO_PROCESS_NOTIF 0x0A001017<a class="headerlink" href="#define-fwk-extn-voice-delivery-param-id-topo-process-notif-0x0a001017" title="Link to this heading"></a></h5>
<p>Custom parameter ID to inform the voice delivery module that topo-process is being invoked from the container. The module is only supposed to generate one cntr-frame-len worth of data per topo-process.</p>
</section>
<section id="define-fwk-extn-voice-delivery-event-id-update-sync-state-0x0800137e">
<h5>#define FWK_EXTN_VOICE_DELIVERY_EVENT_ID_UPDATE_SYNC_STATE 0x0800137E<a class="headerlink" href="#define-fwk-extn-voice-delivery-event-id-update-sync-state-0x0800137e" title="Link to this heading"></a></h5>
<p>ID of the event the Voice Delivery module raises to inform VCPM if its inputs are synced or not.</p>
<p><strong>Message payload (fwk_extn_voice_delivery_event_update_sync_state_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>is_synced</p></td>
<td><p>Indicates if the inputs to the voice delivery module are synced or out</p>
<p>of sync.</p>
</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="id49">
<h4>Enumeration Type Documentation<a class="headerlink" href="#id49" title="Link to this heading"></a></h4>
<section id="enum-container-trigger-policy-t">
<h5>enum container_trigger_policy_t<a class="headerlink" href="#enum-container-trigger-policy-t" title="Link to this heading"></a></h5>
<p>Defines the trigger policy types.</p>
<p><strong>Enumerator:</strong></p>
<div class="line-block">
<div class="line"><strong>VOICE_TIMER_TRIGGER</strong> Container starts a topology process with the voice timer trigger.</div>
<div class="line"><strong>OUTPUT_BUFFER_TRIGGER</strong> Container starts a topology process with the output buffer trigger.</div>
<div class="line"><strong>INVALID_TRIGGER</strong> Invalid value.</div>
</div>
</section>
</section>
</section>
<section id="island-handling">
<h3>Island Handling<a class="headerlink" href="#island-handling" title="Link to this heading"></a></h3>
<section id="id50">
<h4>Define Documentation<a class="headerlink" href="#id50" title="Link to this heading"></a></h4>
<section id="define-fwk-extn-island-0x0a001057">
<h5>#define FWK_EXTN_ISLAND 0x0A001057<a class="headerlink" href="#define-fwk-extn-island-0x0a001057" title="Link to this heading"></a></h5>
<p>Unique identifier of the framework extension that modules use to exit from island.</p>
</section>
<section id="define-fwk-extn-event-id-island-exit-0x0a001058">
<h5>#define FWK_EXTN_EVENT_ID_ISLAND_EXIT 0x0A001058<a class="headerlink" href="#define-fwk-extn-event-id-island-exit-0x0a001058" title="Link to this heading"></a></h5>
<p>ID of the event a module uses to trigger island exit.</p>
</section>
</section>
</section>
</section>
<section id="id51">
<h2>Interface Extensions<a class="headerlink" href="#id51" title="Link to this heading"></a></h2>
<section id="data-port-operations">
<h3>Data Port Operations<a class="headerlink" href="#data-port-operations" title="Link to this heading"></a></h3>
<p>The Data Port Operation interface extension (INTF_EXTN_DATA_PORT_OPERATION) allows modules to tell the framework that they require data port state information from the framework.</p>
<section id="id52">
<h4>Define Documentation<a class="headerlink" href="#id52" title="Link to this heading"></a></h4>
<section id="define-intf-extn-data-port-operation-0x0a001023">
<h5>#define INTF_EXTN_DATA_PORT_OPERATION 0x0A001023<a class="headerlink" href="#define-intf-extn-data-port-operation-0x0a001023" title="Link to this heading"></a></h5>
<p>Unique identifier of the Data Port Operation interface extension.</p>
</section>
<section id="define-intf-extn-param-id-data-port-operation-0x0a001031">
<h5>#define INTF_EXTN_PARAM_ID_DATA_PORT_OPERATION 0x0A001031<a class="headerlink" href="#define-intf-extn-param-id-data-port-operation-0x0a001031" title="Link to this heading"></a></h5>
<p>ID of the parameter the framework uses to inform the module if there is a port state change.</p>
<p><strong>Message payload (intf_extn_data_port_operation_t)</strong></p>
<p>Following this structure is the port ID-index mapping array of size num_ports.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bool_t</p></td>
<td><p>is_input_port</p></td>
<td><p>Indicates the type of port.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>TRUE – Input port</p></li>
<li><p>FALSE – Output port</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#enum-intf-extn-data-port-opcode-t">intf_extn_data-</a></p>
<p><a class="reference external" href="#enum-intf-extn-data-port-opcode-t">_port_opcode_t</a></p>
</td>
<td><p>opcode</p></td>
<td><p>Indicates the type of operation to be done on the input or output</p>
<p>port: open, close, start, stop, suspend.</p>
</td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#struct-capi-buf-t">capi_buf_t</a></p></td>
<td><p>opcode_-</p>
<p>payload_buf</p>
</td>
<td><p>CAPI buffer element specific to the opcode. One buffer is to be used</p>
<p>per opcode for the entire port ID-to-index map.</p>
<p>This element can contain a NULL data pointer if the operation does not require a specific payload.</p>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>num_ports</p></td>
<td><p>Number of elements in the array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#struct-intf-extn-data-port-id-idx-map-t">intf_extn_data-</a></p>
<p><a class="reference external" href="#struct-intf-extn-data-port-id-idx-map-t">_port_id_idx_map_t</a></p>
</td>
<td><p>id_idx</p></td>
<td><p>Array of port ID-to-index mappings.</p>
<p>This array is of variable length and depends on the number of ports to operate on. This payload has the ID-to-index couplet for each of the elements in num_ports.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-intf-extn-port-opcode-invalid-val-ar-non-guid-0xffffffff">
<h5>#define INTF_EXTN_PORT_OPCODE_INVALID_VAL AR_NON_GUID(0xFFFFFFFF)<a class="headerlink" href="#define-intf-extn-port-opcode-invalid-val-ar-non-guid-0xffffffff" title="Link to this heading"></a></h5>
<p>Operation code (opcode) used in any field of <a class="reference external" href="#enum-intf-extn-data-port-opcode-t">intf_extn_data_port_opcode_t</a> to indicate that the value is unspecified.</p>
</section>
</section>
<section id="id53">
<h4>Data Structure Documentation<a class="headerlink" href="#id53" title="Link to this heading"></a></h4>
<section id="struct-intf-extn-data-port-id-idx-map-t">
<h5>struct intf_extn_data_port_id_idx_map_t<a class="headerlink" href="#struct-intf-extn-data-port-id-idx-map-t" title="Link to this heading"></a></h5>
<p>ID-to-index map used in any <a class="reference external" href="#_bookmark502">intf_extn_data_port_operation_t</a> instance.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>port_id</p></td>
<td><p>Identifies the port.</p>
<p><strong>Supported values:</strong> Port IDs exposed by the module that is visible to the ARC tools</p>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>port_index</p></td>
<td><p>Index that is mapped to the port ID.</p>
<p><strong>Supported values:</strong> Between 0 and the maximum number of ports as sent to the module using <a class="reference external" href="#_bookmark245">CAPI_PORT_NUM_INFO</a></p>
</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="id54">
<h4>Enumeration Type Documentation<a class="headerlink" href="#id54" title="Link to this heading"></a></h4>
<section id="enum-intf-extn-data-port-opcode-t">
<h5>enum intf_extn_data_port_opcode_t<a class="headerlink" href="#enum-intf-extn-data-port-opcode-t" title="Link to this heading"></a></h5>
<p>Valid values for the port operation code. For more information, see <a class="reference internal" href="#id4"><span class="std std-ref">Data Port Operation</span></a>.</p>
<p><strong>Enumerator:</strong></p>
</section>
<section id="intf-extn-data-port-open">
<h5><strong>INTF_EXTN_DATA_PORT_OPEN</strong><a class="headerlink" href="#intf-extn-data-port-open" title="Link to this heading"></a></h5>
<p>Port open operation on specific ID-to-index mappings.</p>
<p>This operation does not require a payload.</p>
</section>
<section id="intf-extn-data-port-start">
<h5><strong>INTF_EXTN_DATA_PORT_START</strong><a class="headerlink" href="#intf-extn-data-port-start" title="Link to this heading"></a></h5>
<p>Port start operation on specific ID-to-index mappings. This operation indicates that the framework starts providing buffers on the given ports.</p>
<blockquote>
<div><p>This operation does not require a payload.</p>
</div></blockquote>
</section>
<section id="intf-extn-data-port-stop">
<h5><strong>INTF_EXTN_DATA_PORT_STOP</strong><a class="headerlink" href="#intf-extn-data-port-stop" title="Link to this heading"></a></h5>
<p>Port stop operation on specific ID-to-index mappings. This operation indicates that the framework stops providing buffers on the stopped port.</p>
<blockquote>
<div><p>This operation does not require a payload.</p>
</div></blockquote>
</section>
<section id="intf-extn-data-port-close">
<h5><strong>INTF_EXTN_DATA_PORT_CLOSE</strong><a class="headerlink" href="#intf-extn-data-port-close" title="Link to this heading"></a></h5>
<p>Port close operation on specific ID-to-index mappings.</p>
<p>Open ports are not required to be closed for symmetry. For example, INTF_EXTN_DATA_PORT_CLOSE is not required to close INTF_EXTN_DATA_PORT_OPEN.</p>
<p>When the input port of a metadata handling module (that is, it implements <a class="reference external" href="#define-intf-extn-metadata-0x0a00101f">INTF_EXTN_METADATA</a>) is closed, and if the data flow state of the port is not already at-gap, an internal EOS might need to be inserted at this input port and eventually propagated to the corresponding outputs. This internal EOS is a way to indicate the upstream data flow gap. The framework takes care of this EOS for modules that do not handle metadata.</p>
<p>This operation does not require a payload.</p>
</section>
<section id="intf-extn-data-port-suspend">
<h5><strong>INTF_EXTN_DATA_PORT_SUSPEND</strong><a class="headerlink" href="#intf-extn-data-port-suspend" title="Link to this heading"></a></h5>
<p>Port suspend operation on specific IDs-Indices.</p>
<p>This operation indicates that data flow is paused and the framework will not provide buffers on the suspended ports. The module must not reset the port state at suspend.</p>
<p>This operation does not require a payload.</p>
</section>
<section id="intf-extn-data-port-op-invalid">
<h5><strong>INTF_EXTN_DATA_PORT_OP_INVALID</strong><a class="headerlink" href="#intf-extn-data-port-op-invalid" title="Link to this heading"></a></h5>
<p>Port operation code is not valid.</p>
</section>
<section id="enum-intf-extn-data-port-state-t">
<h5>enum intf_extn_data_port_state_t<a class="headerlink" href="#enum-intf-extn-data-port-state-t" title="Link to this heading"></a></h5>
<p>Types of port states.</p>
<p><strong>Enumerator:</strong></p>
<div class="line-block">
<div class="line"><strong>DATA_PORT_STATE_CLOSED</strong> Data port is destroyed and there is no further data flow.</div>
<div class="line"><strong>DATA_PORT_STATE_OPENED</strong> Data port is opened.</div>
<div class="line"><strong>DATA_PORT_STATE_STARTED</strong> Data port is started. It can expect incoming data or it can output data on this port.</div>
<div class="line"><strong>DATA_PORT_STATE_STOPPED</strong> Data port is stopped.</div>
<div class="line"><strong>DATA_PORT_STATE_SUSPENDED</strong> Data port is suspended.</div>
<div class="line"><strong>DATA_PORT_STATE_INVALID</strong> Data port state is not valid.</div>
</div>
</section>
</section>
</section>
<section id="imcl">
<h3>IMCL<a class="headerlink" href="#imcl" title="Link to this heading"></a></h3>
<p>The Intermodule Control Link interface extension (INTF_EXTN_IMCL) allows modules to tell the framework that they support communication via IMCL.</p>
<p>Modules use <a class="reference external" href="#_bookmark338">CAPI_EVENT_DATA_TO_DSP_SERVICE</a> to communicate with the framework. The param_id field is populated with one of the event IDs and the capi_bufs data pointer to the corresponding event payload.</p>
<section id="id55">
<h4>Define Documentation<a class="headerlink" href="#id55" title="Link to this heading"></a></h4>
<section id="define-intf-extn-imcl-0x0a001012">
<h5>#define INTF_EXTN_IMCL 0x0A001012<a class="headerlink" href="#define-intf-extn-imcl-0x0a001012" title="Link to this heading"></a></h5>
<p>Unique identifier of the IMCL interface extension.</p>
<p>This extension supports the following events and parameter IDs:</p>
<ul class="simple">
<li><p><a class="reference external" href="#define-intf-extn-event-id-imcl-recurring-buf-info-0x0a001013">INTF_EXTN_EVENT_ID_IMCL_RECURRING_BUF_INFO</a></p></li>
<li><p><a class="reference external" href="#define-intf-extn-event-id-imcl-get-recurring-buf-0x0a001014">INTF_EXTN_EVENT_ID_IMCL_GET_RECURRING_BUF</a></p></li>
<li><p><a class="reference external" href="#define-intf-extn-event-id-imcl-get-one-time-buf-0x0a001015">INTF_EXTN_EVENT_ID_IMCL_GET_ONE_TIME_BUF</a></p></li>
<li><p><a class="reference external" href="#define-intf-extn-event-id-imcl-outgoing-data-0x0a001016">INTF_EXTN_EVENT_ID_IMCL_OUTGOING_DATA</a></p></li>
<li><p><a class="reference external" href="#define-intf-extn-param-id-imcl-port-operation-0x0a001018">INTF_EXTN_PARAM_ID_IMCL_PORT_OPERATION</a></p></li>
<li><p><a class="reference external" href="#define-intf-extn-param-id-imcl-incoming-data-0x0a001019">INTF_EXTN_PARAM_ID_IMCL_INCOMING_DATA</a></p></li>
</ul>
</section>
<section id="define-intf-extn-event-id-imcl-recurring-buf-info-0x0a001013">
<h5>#define INTF_EXTN_EVENT_ID_IMCL_RECURRING_BUF_INFO 0x0A001013<a class="headerlink" href="#define-intf-extn-event-id-imcl-recurring-buf-info-0x0a001013" title="Link to this heading"></a></h5>
<p>ID of the event a module raises to tell the framework that it requires a recurring buffer of a specific size on a specific control port. The framework will allocate the queues accordingly.</p>
<p><strong>Message payload (event_id_imcl_recurring_buf_info_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>port_id</p></td>
<td><p>Identifies the port.</p>
<p><strong>Supported values:</strong> Control port IDs exposed by the module that is visible to the ARC tools</p>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>buf_size</p></td>
<td><p>Size (in bytes) of the recurring packet that the module expects on the</p>
<p>specified port ID.</p>
</td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>num_bufs</p></td>
<td><p>Number of recurring packets that the module expects on the</p>
<p>specified port ID.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-intf-extn-event-id-imcl-get-recurring-buf-0x0a001014">
<h5>#define INTF_EXTN_EVENT_ID_IMCL_GET_RECURRING_BUF 0x0A001014<a class="headerlink" href="#define-intf-extn-event-id-imcl-get-recurring-buf-0x0a001014" title="Link to this heading"></a></h5>
<p>ID of the event a module raises to ask the framework for a recurring buffer. The parameter provides a pointer that the framework populates from the appropriate queue.</p>
<p><strong>Message payload (event_id_imcl_get_recurring_buf_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>port_id</p></td>
<td><p>Identifies the port.</p>
<p><strong>Supported values:</strong> Control port IDs exposed by the module that is visible to the ARC tools</p>
</td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#struct-capi-buf-t">capi_buf_t</a></p></td>
<td><p>buf</p></td>
<td><p>CAPI buffer for the requested buffer.</p>
<p>The framework populates the pointer to the buffer in data_ptr, in which the module then copies the data. The framework also populates max_data_len when the buffer is returned.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-intf-extn-event-id-imcl-get-one-time-buf-0x0a001015">
<h5>#define INTF_EXTN_EVENT_ID_IMCL_GET_ONE_TIME_BUF 0x0A001015<a class="headerlink" href="#define-intf-extn-event-id-imcl-get-one-time-buf-0x0a001015" title="Link to this heading"></a></h5>
<p>ID of the event a module raises to ask the framework for a one-time buffer. This parameter provides a pointer that the framework populates from the appropriate source, like a buffer manager.</p>
<p><strong>Message payload (event_id_imcl_get_one_time_buf_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>port_id</p></td>
<td><p>Identifies the port.</p>
<p><strong>Supported values:</strong> Control port IDs exposed by the module that is visible to the ARC tools</p>
</td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#struct-capi-buf-t">capi_buf_t</a></p></td>
<td><p>buf</p></td>
<td><p>CAPI buffer for the requested buffer.</p>
<p>The actual_data_len field contains the requested size of the one-time buffer.</p>
<p>The framework populates data_ptr, into which the module then copies the data.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-intf-extn-event-id-imcl-outgoing-data-0x0a001016">
<h5>#define INTF_EXTN_EVENT_ID_IMCL_OUTGOING_DATA 0x0A001016<a class="headerlink" href="#define-intf-extn-event-id-imcl-outgoing-data-0x0a001016" title="Link to this heading"></a></h5>
<p>ID of the event a module raises to inform the framework that it is ready to send data to its peer. The framework pushes the data to the module on the other end of the control link.</p>
<p><strong>Message payload (event_id_imcl_outgoing_data_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>port_id</p></td>
<td><p>Identifies the port.</p>
<p><strong>Supported values:</strong> Control port IDs exposed by the module that is visible to the ARC tools</p>
</td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#struct-capi-buf-t">capi_buf_t</a></p></td>
<td><p>buf</p></td>
<td><p>CAPI buffer for the requested buffer.</p>
<p>The module must populate the data_ptr and actual_data_len fields.</p>
</td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#_bookmark521">imcl_outgoing-</a></p>
<p><a class="reference external" href="#_bookmark521">_data_flag_t</a></p>
</td>
<td><p>flags</p></td>
<td><p>Flags that control the buffer destination and type of message.</p></td>
</tr>
</tbody>
</table>
<p><strong>Outgoing data control flags (imcl_outgoing_data_flag_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>should_send: 1</p></td>
<td><p>Indicates to the framework whether the buffer is to be sent to the</p>
<p>peer.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE; the buffer returns to the buffer source</p></li>
<li><p>1 – TRUE; the buffer is sent to the peer</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>is_trigger: 1</p></td>
<td><p>Indicates whether the module is to send a trigger or polling message.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE; a polling message is pushed to the destination control port buffer queue, which is handled at the processed boundary</p></li>
<li><p>1 – TRUE; a trigger message is pushed to the command queue of the destination container</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-intf-extn-param-id-imcl-port-operation-0x0a001018">
<h5>#define INTF_EXTN_PARAM_ID_IMCL_PORT_OPERATION 0x0A001018<a class="headerlink" href="#define-intf-extn-param-id-imcl-port-operation-0x0a001018" title="Link to this heading"></a></h5>
<p>ID of the parameter a module uses to control port operations associated with connections being created, connected, disconnected, or closed.</p>
<p><strong>Message payload (intf_extn_param_id_imcl_port_operation_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="#enum-intf-extn-imcl-port-opcode-t">intf_extn_imcl-</a></p>
<p><a class="reference external" href="#enum-intf-extn-imcl-port-opcode-t">_port_opcode_t</a></p>
</td>
<td><p>opcode</p></td>
<td><p>Operation code that indicates the type of operation to be done on the</p>
<p>control ports.</p>
</td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#struct-capi-buf-t">capi_buf_t</a></p></td>
<td><p>op_payload</p></td>
<td><p>CAPI buffer element specific to the operation code. One buffer is to</p>
<p>be used per opcode.</p>
<p>This element can contain a NULL data pointer if the operation does not require a specific payload.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-intf-extn-param-id-imcl-incoming-data-0x0a001019">
<h5>#define INTF_EXTN_PARAM_ID_IMCL_INCOMING_DATA 0x0A001019<a class="headerlink" href="#define-intf-extn-param-id-imcl-incoming-data-0x0a001019" title="Link to this heading"></a></h5>
<p>ID of the parameter a module uses to receive the IMCL buffer from its peer.</p>
<p>The framework uses this ID and does a <a class="reference external" href="#capi-err-t-capi-vtbl-t-set-param-capi-t-pif-uint32-t-param-id-const-capi-port-info-t-port-info-ptr-capi-buf-t-params-ptr">capi_vtbl_t::set_param()</a> on the destination port ID. The module then parses the payload based on the intent code, which the IMCL peers understand.</p>
<p>This parameter follows the typical set_param() routine with the payload pointing to the data buffer sent by the IMCL Peer.</p>
<p><strong>Message payload (intf_extn_param_id_imcl_incoming_data_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>port_id</p></td>
<td><p>Identifies the port that is receiving data.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>reserved</p></td>
<td><p>Maintains 8-byte alignment.</p></td>
</tr>
<tr class="row-even"><td><p>uint64_t</p></td>
<td><p>buf</p></td>
<td><p>Array of buffers.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="id56">
<h4>Data Structure Documentation<a class="headerlink" href="#id56" title="Link to this heading"></a></h4>
<section id="struct-intf-extn-imcl-id-intent-map-t">
<h5>struct intf_extn_imcl_id_intent_map_t<a class="headerlink" href="#struct-intf-extn-imcl-id-intent-map-t" title="Link to this heading"></a></h5>
<p>Contains the intents that are supported over the specified port.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>port_id</p></td>
<td><p>Identifies the port.</p>
<p><strong>Supported values:</strong> Control port IDs exposed by the module that is visible to the ARC tools</p>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>peer_module_-</p>
<p>instance_id</p>
</td>
<td><p>Identifies the peer module instance.</p></td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>peer_port_id</p></td>
<td><p>Identifies the peer port.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>num_intents</p></td>
<td><p>Number of elements in the array. The intents are supported by the</p>
<p>control port (port_id).</p>
</td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>intent_arr</p></td>
<td><p>Array of intents of size num_intents.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="struct-intf-extn-imcl-port-open-t">
<h5>struct intf_extn_imcl_port_open_t<a class="headerlink" href="#struct-intf-extn-imcl-port-open-t" title="Link to this heading"></a></h5>
<p>Payload for the <a class="reference external" href="#intf-extn-imcl-port-open">INTF_EXTN_IMCL_PORT_OPEN</a> operation.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>num_ports</p></td>
<td><p>Number of elements in the array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#struct-intf-extn-imcl-id-intent-map-t">intf_extn_imcl-</a></p>
<p><a class="reference external" href="#struct-intf-extn-imcl-id-intent-map-t">_id_intent_map_t</a></p>
</td>
<td><p>intent_map</p></td>
<td><p>Array of intents (list of <a class="reference external" href="#struct-intf-extn-imcl-id-intent-map-t">intf_extn_imcl_id_intent_map_t</a> structures)</p>
<p>supported by each opened control port.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="struct-intf-extn-imcl-port-close-t">
<h5>struct intf_extn_imcl_port_close_t<a class="headerlink" href="#struct-intf-extn-imcl-port-close-t" title="Link to this heading"></a></h5>
<p>Payload for the <a class="reference external" href="#intf-extn-imcl-port-close">INTF_EXTN_IMCL_PORT_CLOSE</a> operation.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>num_ports</p></td>
<td><p>Number of elements in the array.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>port_id_arr</p></td>
<td><p>Array of control port IDs to be closed.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="struct-intf-extn-imcl-port-start-t">
<h5>struct intf_extn_imcl_port_start_t<a class="headerlink" href="#struct-intf-extn-imcl-port-start-t" title="Link to this heading"></a></h5>
<p>Payload for the <a class="reference external" href="#intf-extn-data-port-start">INTF_EXTN_DATA_PORT_START</a> operation.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>num_ports</p></td>
<td><p>Number of elements in the array.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>port_id_arr</p></td>
<td><p>Array of control port IDs to be started.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="struct-intf-extn-imcl-port-stop-t">
<h5>struct intf_extn_imcl_port_stop_t<a class="headerlink" href="#struct-intf-extn-imcl-port-stop-t" title="Link to this heading"></a></h5>
<p>Payload for the <a class="reference external" href="#intf-extn-data-port-stop">INTF_EXTN_DATA_PORT_STOP</a> operation.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>num_ports</p></td>
<td><p>Number of elements in the array.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>port_id_arr</p></td>
<td><p>Array of control port IDs to be stopped.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="id57">
<h4>Enumeration Type Documentation<a class="headerlink" href="#id57" title="Link to this heading"></a></h4>
<section id="enum-intf-extn-imcl-port-opcode-t">
<h5>enum intf_extn_imcl_port_opcode_t<a class="headerlink" href="#enum-intf-extn-imcl-port-opcode-t" title="Link to this heading"></a></h5>
<p>Types of port operation codes (opcodes) used by <a class="reference external" href="#define-intf-extn-param-id-imcl-port-operation-0x0a001018">INTF_EXTN_PARAM_ID_IMCL_PORT_OPERATION</a>.</p>
<p><strong>Enumerator:</strong></p>
</section>
<section id="intf-extn-imcl-port-open">
<h5><strong>INTF_EXTN_IMCL_PORT_OPEN</strong><a class="headerlink" href="#intf-extn-imcl-port-open" title="Link to this heading"></a></h5>
<p>Indicates the port open operation on specific control port IDs.</p>
<p>Information provided to the modules includes the number of ports being opened, control port IDs, peer module instance IDs, peer port IDs, and the array of intents. (Each port ID can have multiple intents.)</p>
<p>Modules must not send any messages when the control port is in this state.</p>
<blockquote>
<div><p>Payload: <a class="reference external" href="#struct-intf-extn-imcl-port-open-t">intf_extn_imcl_port_open_t</a></p>
</div></blockquote>
</section>
<section id="intf-extn-imcl-port-peer-connected">
<h5><strong>INTF_EXTN_IMCL_PORT_PEER_CONNECTED</strong><a class="headerlink" href="#intf-extn-imcl-port-peer-connected" title="Link to this heading"></a></h5>
<p>Indicates that the peer port is connected and ready to handle incoming messages.</p>
<p>As soon as a control port is opened, a module might try to send a message, however, the other side might not be ready yet. The module must wait for the connected state before it can send any messages over the control link.</p>
</section>
<section id="intf-extn-imcl-port-peer-disconnected">
<h5><strong>INTF_EXTN_IMCL_PORT_PEER_DISCONNECTED</strong><a class="headerlink" href="#intf-extn-imcl-port-peer-disconnected" title="Link to this heading"></a></h5>
<p>Indicates that the peer port is stopped and is not ready to receive messages.</p>
<p>Modules must not send any messages when the control port is in this state.</p>
</section>
<section id="intf-extn-imcl-port-close">
<h5><strong>INTF_EXTN_IMCL_PORT_CLOSE</strong><a class="headerlink" href="#intf-extn-imcl-port-close" title="Link to this heading"></a></h5>
<p>Indicates the port close operation on specific port IDs. Each port ID can have multiple intents.</p>
<p>A close operation is atomic: all intents associated with the port are closed. Modules must not send any control messages when the control port is in this state.</p>
<blockquote>
<div><p>Payload: <a class="reference external" href="#struct-intf-extn-imcl-port-close-t">intf_extn_imcl_port_close_t</a></p>
</div></blockquote>
</section>
<section id="intf-extn-imcl-port-state-invalid">
<h5><strong>INTF_EXTN_IMCL_PORT_STATE_INVALID</strong><a class="headerlink" href="#intf-extn-imcl-port-state-invalid" title="Link to this heading"></a></h5>
<p>Port opcode is not valid.</p>
</section>
</section>
</section>
<section id="id58">
<h3>Metadata<a class="headerlink" href="#id58" title="Link to this heading"></a></h3>
<section id="id59">
<h4>Define Documentation<a class="headerlink" href="#id59" title="Link to this heading"></a></h4>
<section id="define-intf-extn-metadata-0x0a00101f">
<h5>#define INTF_EXTN_METADATA 0x0A00101F<a class="headerlink" href="#define-intf-extn-metadata-0x0a00101f" title="Link to this heading"></a></h5>
<p>Unique identifier of the interface extension for metadata definitions and their methods.</p>
</section>
<section id="define-intf-extn-metadata-handler-version-0x00000001">
<h5>#define INTF_EXTN_METADATA_HANDLER_VERSION 0x00000001<a class="headerlink" href="#define-intf-extn-metadata-handler-version-0x00000001" title="Link to this heading"></a></h5>
<p>Version details of the metadata handler supported by the framework. Will be incremented for every update to the supported features.</p>
</section>
<section id="define-intf-extn-param-id-metadata-handler-0x0a001020">
<h5>#define INTF_EXTN_PARAM_ID_METADATA_HANDLER 0x0A001020<a class="headerlink" href="#define-intf-extn-param-id-metadata-handler-0x0a001020" title="Link to this heading"></a></h5>
<p>ID of the parameter the containers or services use to set the handlers for different methods of operating on metadata lists.</p>
</section>
<section id="define-module-cmn-md-tracking-use-specified-heap-optional-0">
<h5>#define MODULE_CMN_MD_TRACKING_USE_SPECIFIED_HEAP_OPTIONAL 0<a class="headerlink" href="#define-module-cmn-md-tracking-use-specified-heap-optional-0" title="Link to this heading"></a></h5>
<p>Specifies that it is optional to allocate the metadata tracking information in the client-specified heap.</p>
</section>
<section id="define-module-cmn-md-tracking-use-specified-heap-mandatory-1">
<h5>#define MODULE_CMN_MD_TRACKING_USE_SPECIFIED_HEAP_MANDATORY 1<a class="headerlink" href="#define-module-cmn-md-tracking-use-specified-heap-mandatory-1" title="Link to this heading"></a></h5>
<p>Specifies that it is mandatory to allocate the metadata tracking information in the client-specified heap.</p>
</section>
<section id="define-module-cmn-md-tracking-disable-cloning-event-0">
<h5>#define MODULE_CMN_MD_TRACKING_DISABLE_CLONING_EVENT 0<a class="headerlink" href="#define-module-cmn-md-tracking-disable-cloning-event-0" title="Link to this heading"></a></h5>
<p>Specifies that client does not need any cloning events.</p>
</section>
<section id="define-module-cmn-md-tracking-enable-cloning-event-1">
<h5>#define MODULE_CMN_MD_TRACKING_ENABLE_CLONING_EVENT 1<a class="headerlink" href="#define-module-cmn-md-tracking-enable-cloning-event-1" title="Link to this heading"></a></h5>
<p>Specifies that client requires a cloning event from the framework when the tracking MD is cloned.</p>
</section>
<section id="define-module-cmn-md-tracking-use-generic-event-0">
<h5>#define MODULE_CMN_MD_TRACKING_USE_GENERIC_EVENT 0<a class="headerlink" href="#define-module-cmn-md-tracking-use-generic-event-0" title="Link to this heading"></a></h5>
<p>Specifies that the tracking event uses a generic implementation.</p>
</section>
<section id="define-module-cmn-md-tracking-use-custom-event-1">
<h5>#define MODULE_CMN_MD_TRACKING_USE_CUSTOM_EVENT 1<a class="headerlink" href="#define-module-cmn-md-tracking-use-custom-event-1" title="Link to this heading"></a></h5>
<p>Specifies that the tracking event needs custom implementation.</p>
<dl class="simple">
<dt>example<span class="classifier">EOS from the HLOS client uses custom implementation and</span></dt><dd><p>EOS from OLC uses generic implementation.</p>
</dd>
</dl>
</section>
<section id="define-module-cmn-md-out-of-band-1">
<h5>#define MODULE_CMN_MD_OUT_OF_BAND 1<a class="headerlink" href="#define-module-cmn-md-out-of-band-1" title="Link to this heading"></a></h5>
<p>Metadata is out-of-band.</p>
<p>The metadata-specific memory is elsewhere and <a class="reference external" href="#struct-module-cmn-md-t">module_cmn_md_t</a> has a pointer to it.</p>
</section>
<section id="define-module-cmn-md-in-band-0">
<h5>#define MODULE_CMN_MD_IN_BAND 0<a class="headerlink" href="#define-module-cmn-md-in-band-0" title="Link to this heading"></a></h5>
<p>Metadata is in-band.</p>
<p>The <a class="reference external" href="#struct-module-cmn-md-t">module_cmn_md_t</a> structure and the metadata-specific payload are in one contiguous memory buffer.</p>
</section>
<section id="define-module-cmn-md-sample-associated-0">
<h5>#define MODULE_CMN_MD_SAMPLE_ASSOCIATED 0<a class="headerlink" href="#define-module-cmn-md-sample-associated-0" title="Link to this heading"></a></h5>
<p>Metadata is applicable at the offset at which it is inserted.</p>
<p>This metadata suffers both algorithmic and buffering delays. For example, EOS.</p>
</section>
<section id="define-module-cmn-md-buffer-associated-1">
<h5>#define MODULE_CMN_MD_BUFFER_ASSOCIATED 1<a class="headerlink" href="#define-module-cmn-md-buffer-associated-1" title="Link to this heading"></a></h5>
<p>Metadata is applicable at the offset for the buffer.</p>
<p>This metadata suffers buffering delays only. For example, Data Flow Gap (DFG).</p>
</section>
<section id="define-module-cmn-md-is-external-client-md-1">
<h5>#define MODULE_CMN_MD_IS_EXTERNAL_CLIENT_MD 1<a class="headerlink" href="#define-module-cmn-md-is-external-client-md-1" title="Link to this heading"></a></h5>
<p>Metadata is from an external ARE client.</p>
</section>
<section id="define-module-cmn-md-is-internal-client-md-0">
<h5>#define MODULE_CMN_MD_IS_INTERNAL_CLIENT_MD 0<a class="headerlink" href="#define-module-cmn-md-is-internal-client-md-0" title="Link to this heading"></a></h5>
<p>Metadata is from an internal ARE client.</p>
</section>
<section id="define-module-cmn-md-tracking-config-disable-0">
<h5>#define MODULE_CMN_MD_TRACKING_CONFIG_DISABLE 0<a class="headerlink" href="#define-module-cmn-md-tracking-config-disable-0" title="Link to this heading"></a></h5>
<p>Definition of a metadata tracking configuration disable.</p>
</section>
<section id="define-module-cmn-md-tracking-config-enable-for-drops-only-1">
<h5>#define MODULE_CMN_MD_TRACKING_CONFIG_ENABLE_FOR_DROPS_ONLY 1<a class="headerlink" href="#define-module-cmn-md-tracking-config-enable-for-drops-only-1" title="Link to this heading"></a></h5>
<p>Definition of a metadata tracking configuration to enable for MD drops only.</p>
</section>
<section id="define-module-cmn-md-tracking-config-enable-for-drop-or-consume-2">
<h5>#define MODULE_CMN_MD_TRACKING_CONFIG_ENABLE_FOR_DROP_OR_CONSUME 2<a class="headerlink" href="#define-module-cmn-md-tracking-config-enable-for-drop-or-consume-2" title="Link to this heading"></a></h5>
<p>Definition of a metadata tracking configuration to enable for MD drop or consume.</p>
</section>
<section id="define-module-cmn-md-tracking-event-policy-last-0">
<h5>#define MODULE_CMN_MD_TRACKING_EVENT_POLICY_LAST 0<a class="headerlink" href="#define-module-cmn-md-tracking-event-policy-last-0" title="Link to this heading"></a></h5>
<p>Definition of a metadata tracking event policy last.</p>
</section>
<section id="define-module-cmn-md-tracking-event-policy-each-1">
<h5>#define MODULE_CMN_MD_TRACKING_EVENT_POLICY_EACH 1<a class="headerlink" href="#define-module-cmn-md-tracking-event-policy-each-1" title="Link to this heading"></a></h5>
<p>Definition of a metadata tracking event policy each.</p>
</section>
<section id="define-module-cmn-md-version-0">
<h5>#define MODULE_CMN_MD_VERSION 0<a class="headerlink" href="#define-module-cmn-md-version-0" title="Link to this heading"></a></h5>
<p>Specifies the version of the metadata</p>
</section>
<section id="define-module-cmn-md-end-associated-md">
<h5>#define MODULE_CMN_MD_END_ASSOCIATED_MD<a class="headerlink" href="#define-module-cmn-md-end-associated-md" title="Link to this heading"></a></h5>
<p>Specifies that the metadata offset at the output should be at the end of the buffer.</p>
</section>
<section id="define-module-cmn-md-begin-associated-md">
<h5>#define MODULE_CMN_MD_BEGIN_ASSOCIATED_MD<a class="headerlink" href="#define-module-cmn-md-begin-associated-md" title="Link to this heading"></a></h5>
<p>Specifies that the metadata offset at the output should be at the start of the buffer.</p>
</section>
<section id="define-module-cmn-md-needs-propagation-to-client-buffer-enable-1">
<h5>#define MODULE_CMN_MD_NEEDS_PROPAGATION_TO_CLIENT_BUFFER_ENABLE 1<a class="headerlink" href="#define-module-cmn-md-needs-propagation-to-client-buffer-enable-1" title="Link to this heading"></a></h5>
<p>Definition of a metadata to enable propagation to CLIENT BUFFER</p>
</section>
<section id="define-module-cmn-md-needs-propagation-to-client-buffer-disable-0">
<h5>#define MODULE_CMN_MD_NEEDS_PROPAGATION_TO_CLIENT_BUFFER_DISABLE 0<a class="headerlink" href="#define-module-cmn-md-needs-propagation-to-client-buffer-disable-0" title="Link to this heading"></a></h5>
<p>Definition of a metadata to disable propagation to CLIENT BUFFER</p>
</section>
<section id="define-module-cmn-md-inband-get-req-size-inband-size">
<h5>#define MODULE_CMN_MD_INBAND_GET_REQ_SIZE(inband_size)<a class="headerlink" href="#define-module-cmn-md-inband-get-req-size-inband-size" title="Link to this heading"></a></h5>
<p>Macro for getting the required size for in-band metadata.</p>
</section>
<section id="define-module-cmn-md-eos-basic-client-cmd-0">
<h5>#define MODULE_CMN_MD_EOS_BASIC_CLIENT_CMD 0<a class="headerlink" href="#define-module-cmn-md-eos-basic-client-cmd-0" title="Link to this heading"></a></h5>
<p>Basic EOS command from the client.</p>
</section>
<section id="define-module-cmn-md-eos-extension-client-cmd-1">
<h5>#define MODULE_CMN_MD_EOS_EXTENSION_CLIENT_CMD 1<a class="headerlink" href="#define-module-cmn-md-eos-extension-client-cmd-1" title="Link to this heading"></a></h5>
<p>Extended EOS message from the client for addressing multi-DSP offload.</p>
</section>
<section id="define-module-cmn-md-eos-flushing-1">
<h5>#define MODULE_CMN_MD_EOS_FLUSHING 1<a class="headerlink" href="#define-module-cmn-md-eos-flushing-1" title="Link to this heading"></a></h5>
<p>Macro for flushing EOS.</p>
</section>
<section id="define-module-cmn-md-eos-non-flushing-0">
<h5>#define MODULE_CMN_MD_EOS_NON_FLUSHING 0<a class="headerlink" href="#define-module-cmn-md-eos-non-flushing-0" title="Link to this heading"></a></h5>
<p>Macro for non-flushing EOS.</p>
</section>
<section id="define-module-cmn-md-id-dfg-0x0a001025">
<h5>#define MODULE_CMN_MD_ID_DFG 0x0A001025<a class="headerlink" href="#define-module-cmn-md-id-dfg-0x0a001025" title="Link to this heading"></a></h5>
<p>Identifies the metadata ID for DFG.</p>
<p>The <a class="reference external" href="#struct-module-cmn-md-t">module_cmn_md_t</a> structure must set the metadata_id field to this ID when the metadata is DFG. The module also must check this ID before operating on DFG structures. A data flow gap indicates that there will be a larger than steady-state gap in time between when the most recent data message was sent to this input port and when the next data message (if one exists) will be sent to this input port.</p>
</section>
</section>
<section id="id60">
<h4>Data Structure Documentation<a class="headerlink" href="#id60" title="Link to this heading"></a></h4>
<section id="struct-intf-extn-md-propagation-t">
<h5>struct intf_extn_md_propagation_t<a class="headerlink" href="#struct-intf-extn-md-propagation-t" title="Link to this heading"></a></h5>
<p>Defines the input and output data formats.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="#enum-data-format-t">data_format_t</a></p></td>
<td><p>df</p></td>
<td><p>Data format.</p>
<p>For CAPI_RAW_COMPRESSED: bits_per_sample and sample_rate are not applicable.</p>
<p>In all other cases (PCM and packetized), they are applicable.</p>
<p>For PCM and packetized: all lengths are given in bytes_per_channel.</p>
<p>For raw compressed: per_channel qualifier is not applicable.</p>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>initial_len_per-</p>
<p>_ch_in_bytes</p>
</td>
<td><p>Amount of data in the buffer (in bytes per channel) when</p>
<p><a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a> is entered.</p>
<p>For inputs: after process() returns, the data remaining in the buffer = (initial_len_per_ch_in_bytes - len_per_ch_in_bytes) <em>&gt;</em>= 0.</p>
<p>For outputs: after process returns, the data in the output buffer = (initial_len_per_ch_in_bytes + len_per_ch_in_bytes).</p>
<p>Also, after moving metadata to the output list, offsets are adjusted by adding initial_len_per_ch_in_bytes.</p>
</td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>len_per_ch_in-</p>
<p>_bytes</p>
</td>
<td><p>Length (in bytes) of data consumed for input and data produced for output per channel.</p>
<p>For inputs and outputs, this value corresponds to the actual length after the <a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a> call.</p>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>buf_delay_per-</p>
<p>_ch_in_bytes</p>
</td>
<td><p>Delay (length in bytes) of data per channel already buffered in the</p>
<p>input or output channel before the <a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a> call.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – For most modules</p></li>
<li><p>Nonzero – For modules with internal buffering that is not accounted for by the algorithm delay.</p></li>
</ul>
<p>This buffering delay must not be included in a module’s reported algorithm delay. It will lead to incorrect calculations in</p>
<p><a class="reference external" href="#_bookmark612">intf_extn_param_id_metadata_handler_t::metadata_propagate()</a> for adjusting metadata offsets.</p>
</td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>bits_per_-</p>
<p>sample</p>
</td>
<td><p>Bits per sample if the data is PCM or packetized.</p>
<p><strong>Supported values:</strong> 16, 32</p>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>sample_rate</p></td>
<td><p>Sample rate (in Hertz) if the data is PCM or packetized.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="struct-module-cmn-md-tracking-flags-t">
<h5>struct module_cmn_md_tracking_flags_t<a class="headerlink" href="#struct-module-cmn-md-tracking-flags-t" title="Link to this heading"></a></h5>
<p>Specifies the control flags for tracking metadata.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>union <a class="reference external" href="#struct-module-cmn-md-tracking-flags-t">module-</a></p>
<p><a class="reference external" href="#struct-module-cmn-md-tracking-flags-t">_cmn_md_tracking_flags_t</a></p>
</td>
<td><p>unnamed</p></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="union-module-cmn-md-tracking-flags-t-unnamed">
<h5>union module_cmn_md_tracking_flags_t. unnamed<a class="headerlink" href="#union-module-cmn-md-tracking-flags-t-unnamed" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>unnamed</p></td>
<td><p>unnamed</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>word</p></td>
<td><p>Entire 32-bit word for easy access to read or write an entire word in</p>
<p>one shot.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="struct-module-cmn-md-tracking-flags-t-unnamed-unnamed">
<h5>struct module_cmn_md_tracking_flags_t. unnamed <em>.</em> unnamed<a class="headerlink" href="#struct-module-cmn-md-tracking-flags-t-unnamed-unnamed" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>use_only_-</p>
<p>specified_heap: 1</p>
</td>
<td><p>Indicates if the tracking information needs to be allocated only from</p>
<p>the specified heap.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="#define-module-cmn-md-tracking-use-specified-heap-optional-0">MODULE_CMN_MD_TRACKING_USE_SPECIFIED_HEAP_OPTIONAL</a></p></li>
<li><p><a class="reference external" href="#define-module-cmn-md-tracking-use-specified-heap-mandatory-1">MODULE_CMN_MD_TRACKING_USE_SPECIFIED_HEAP_MANDATORY</a></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>enable_cloning-</p>
<p>_event: 1</p>
</td>
<td><p>Indicates if the client needs to be notified through an event when the</p>
<p>tracking MD is cloned in the framework.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="#define-module-cmn-md-tracking-disable-cloning-event-0">MODULE_CMN_MD_TRACKING_DISABLE_CLONING_EVENT</a></p></li>
<li><p><a class="reference external" href="#define-module-cmn-md-tracking-enable-cloning-event-1">MODULE_CMN_MD_TRACKING_ENABLE_CLONING_EVENT</a></p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>requires_-</p>
<p>custom_event: 1</p>
</td>
<td><p>Indicates if the metadata needs custom tracking event handling.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="#define-module-cmn-md-tracking-use-generic-event-0">MODULE_CMN_MD_TRACKING_USE_GENERIC_EVENT</a></p></li>
<li><p><a class="reference external" href="#define-module-cmn-md-tracking-use-custom-event-1">MODULE_CMN_MD_TRACKING_USE_CUSTOM_EVENT</a></p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
<section id="struct-module-cmn-md-tracking-payload-t">
<h5>struct module_cmn_md_tracking_payload_t<a class="headerlink" href="#struct-module-cmn-md-tracking-payload-t" title="Link to this heading"></a></h5>
<blockquote>
<div><p>Payload structure specific to the metadata tracking information.</p>
</div></blockquote>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="#struct-module-cmn-md-tracking-flags-t">module_cmn_-</a></p>
<p><a class="reference external" href="#struct-module-cmn-md-tracking-flags-t">md_tracking_flags_t</a></p>
</td>
<td><p>flags</p></td>
<td><p>Indicates the metadata tracking flag.</p></td>
</tr>
<tr class="row-odd"><td><p>uint16_t</p></td>
<td><p>src_domain_id</p></td>
<td><p>Domain ID of the packet’s source.</p>
<p>Bits 8 to 15 (eight bits) in the core header structure, gpr_packet_t (see gpr_packet.h).</p>
</td>
</tr>
<tr class="row-even"><td><p>uint16_t</p></td>
<td><p>dst_domain_id</p></td>
<td><p>Domain ID of the destination where the packet is to be delivered.</p>
<p>Bits 0 to 7 (eight bits) in the core header structure, gpr_packet_t (see gpr_packet.h).</p>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>src_port</p></td>
<td><p>Identifies the service from where the packet came.</p>
<p>Bits 31 to 0 (thirty-two bits) in the core header structure, gpr_packet_t (see gpr_packet.h).</p>
</td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>dest_port</p></td>
<td><p>Identifies the service where the packet is to be delivered.</p>
<p>Bits 31 to 0 (thirty-two bits) in the core header structure, gpr_packet_t (see gpr_packet.h).</p>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>token_lsw</p></td>
<td><p>Client transaction ID provided by the sender. Lower 32 bits of the</p>
<p>token. This value is populated from the metadata header sent by the client.</p>
</td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>token_msw</p></td>
<td><p>Client transaction ID provided by the sender. Higher 32 bits of the</p>
<p>token. This value is populated from the metadata header sent by the client.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="struct-module-cmn-md-tracking-t">
<h5>struct module_cmn_md_tracking_t<a class="headerlink" href="#struct-module-cmn-md-tracking-t" title="Link to this heading"></a></h5>
<p>The metadata can create a tracking reference based on the client configuration. The metadata tracking would have the payload to raise an event when the metadata is either dropped/rendered based on the client configuration. The payload also specifies the control flags and heap ID to create the tracking reference.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="#struct-module-cmn-md-tracking-payload-t">module_cmn_-</a></p>
<p><a class="reference external" href="#struct-module-cmn-md-tracking-payload-t">md_tracking_payload_t</a></p>
</td>
<td><p>tracking_-</p>
<p>payload</p>
</td>
<td><p>Metadata tracking payload information.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#struct-capi-heap-id-t">capi_heap_id_t</a></p></td>
<td><p>heap_info</p></td>
<td><p>Specifies the heap ID for allocating the tracking payload.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="struct-intf-extn-param-id-metadata-handler-t">
<h5>struct intf_extn_param_id_metadata_handler_t<a class="headerlink" href="#struct-intf-extn-param-id-metadata-handler-t" title="Link to this heading"></a></h5>
<p>Function wrapper for callback functions that help in common metadata operations. This wrapper includes the following functions:</p>
<ul class="simple">
<li><p><a class="reference external" href="#_bookmark609">metadata_create()</a></p></li>
<li><p><a class="reference external" href="#_bookmark610">metadata_clone()</a></p></li>
<li><p><a class="reference external" href="#_bookmark611">metadata_destroy()</a></p></li>
<li><p><a class="reference external" href="#_bookmark612">metadata_propagate()</a></p></li>
<li><p><a class="reference external" href="#_bookmark613">metadata_modify_at_data_flow_start()</a></p></li>
<li><p><a class="reference external" href="#_bookmark614">metadata_create_with_tracking()</a></p></li>
</ul>
<p><strong>Data Fields</strong></p>
<ul>
<li><p>uint32_t <a class="reference external" href="#_bookmark607">version</a></p></li>
<li><p>void ∗ <a class="reference external" href="#_bookmark608">context_ptr</a></p></li>
<li><p><a class="reference external" href="#typedef-uint32-t-capi-err-t">capi_err_t</a>(∗
<a class="reference external" href="#_bookmark609">metadata_create</a> )(void
∗<a class="reference external" href="#_bookmark608">context_ptr</a>,
<a class="reference external" href="#struct-module-cmn-md-list-t">module_cmn_md_list_t</a> ∗∗md_list_pptr,
uint32_t size, <a class="reference external" href="#struct-capi-heap-id-t">capi_heap_id_t</a>
heap_id, bool_t is_out_band,
<a class="reference external" href="#struct-module-cmn-md-t">module_cmn_md_t</a> ∗∗md_pptr)</p></li>
<li><p><a class="reference external" href="#typedef-uint32-t-capi-err-t">capi_err_t</a>(∗
<a class="reference external" href="#_bookmark610">metadata_clone</a> )(void
∗<a class="reference external" href="#_bookmark608">context_ptr</a>,
<a class="reference external" href="#struct-module-cmn-md-t">module_cmn_md_t</a> ∗md_ptr,
<a class="reference external" href="#struct-module-cmn-md-list-t">module_cmn_md_list_t</a> ∗∗md_list_pptr,
<a class="reference external" href="#struct-capi-heap-id-t">capi_heap_id_t</a> heap_id)</p></li>
<li><p><a class="reference external" href="#typedef-uint32-t-capi-err-t">capi_err_t</a>(∗
<a class="reference external" href="#_bookmark611">metadata_destroy</a> )(void
∗<a class="reference external" href="#_bookmark608">context_ptr</a>,
<a class="reference external" href="#struct-module-cmn-md-list-t">module_cmn_md_list_t</a> ∗md_list_ptr, bool_t
is_dropped, <a class="reference external" href="#struct-module-cmn-md-list-t">module_cmn_md_list_t</a>
∗∗head_pptr)</p></li>
<li><p><a class="reference external" href="#typedef-uint32-t-capi-err-t">capi_err_t</a>(∗
<a class="reference external" href="#_bookmark612">metadata_propagate</a> )(void
∗<a class="reference external" href="#_bookmark608">context_ptr</a>,
<a class="reference external" href="#struct-capi-stream-data-v2-t">capi_stream_data_v2_t</a>
∗input_stream_ptr,
<a class="reference external" href="#struct-capi-stream-data-v2-t">capi_stream_data_v2_t</a>
∗output_stream_ptr, <a class="reference external" href="#struct-module-cmn-md-list-t">module_cmn_md_list_t</a>
∗∗internal_md_list_pptr, uint32_t algo_delay_us,
<a class="reference external" href="#struct-intf-extn-md-propagation-t">intf_extn_md_propagation_t</a>
∗input_md_info_ptr,
<a class="reference external" href="#struct-intf-extn-md-propagation-t">intf_extn_md_propagation_t</a>
∗output_md_info_ptr)</p></li>
<li><p><a class="reference external" href="#typedef-uint32-t-capi-err-t">capi_err_t</a>(∗
<a class="reference external" href="#_bookmark613">metadata_modify_at_data_flow_start</a> )(void
∗<a class="reference external" href="#_bookmark608">context_ptr</a>,
<a class="reference external" href="#struct-module-cmn-md-list-t">module_cmn_md_list_t</a></p>
<blockquote>
<div><p>∗md_node_pptr, <a class="reference external" href="#struct-module-cmn-md-list-t">module_cmn_md_list_t</a>
∗∗head_pptr)</p>
</div></blockquote>
</li>
<li><p><a class="reference external" href="#typedef-uint32-t-capi-err-t">capi_err_t</a>(∗
<a class="reference external" href="#_bookmark614">metadata_create_with_tracking</a> )(void
∗<a class="reference external" href="#_bookmark608">context_ptr</a>,
<a class="reference external" href="#struct-module-cmn-md-list-t">module_cmn_md_list_t</a> ∗∗md_list-</p>
<blockquote>
<div><p>_pptr, uint32_t size,
<a class="reference external" href="#struct-capi-heap-id-t">capi_heap_id_t</a> heap_id, uint32_t
metadata_id,
<a class="reference external" href="#struct-module-cmn-md-flags-t">module_cmn_md_flags_t</a> flags,
<a class="reference external" href="#struct-module-cmn-md-tracking-t">module_cmn_md_tracking_t</a>
∗md_tracking_ptr, <a class="reference external" href="#struct-module-cmn-md-t">module_cmn_md_t</a>
∗∗md_pptr)</p>
</div></blockquote>
</li>
</ul>
<p><strong>Field Documentation</strong></p>
<blockquote>
<div><p>. <strong>uint32_t intf_extn_param_id_metadata_handler_t::version</strong></p>
<blockquote>
<div><p>Version of this structure (currently v1).</p>
<p>In subsequent versions, more fields might be present, but no fields will be removed.</p>
<p>The version supported by the framework would be configured to the module. The module should only use features supported by the specified version.</p>
<p>example : If the module is compiled for version 2 and framework uses version 1, the module should only use API features from version 1 specified by framework to the module.</p>
</div></blockquote>
<p><strong>void</strong>∗
<strong>intf_extn_param_id_metadata_handler_t::conte</strong><strong>xt_ptr</strong></p>
<blockquote>
<div><p>Context pointer passed to the module implementing this extension.</p>
</div></blockquote>
<p><strong>capi_err_t(</strong>∗
<strong>intf_extn_param_id_metadata_handler_t::metadata_create)(void</strong>
∗<strong>context_ptr, module_cmn_md_list_t</strong> ∗∗<strong>md_list_pptr,
uint32_t size, capi_heap_id_t heap_id, bool_t is_out_band,
module_cmn_md_t</strong> ∗∗<strong>md_pptr)</strong></p>
<blockquote>
<div><p>Allocates memory for metadata, creates a list node, and inserts the
new list node to the tail of a given list.</p>
</div></blockquote>
</div></blockquote>
<p><strong>Associated data types</strong></p>
<blockquote>
<div><p><a class="reference external" href="#struct-capi-heap-id-t">capi_heap_id_t</a></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>in</p></th>
<th class="head"><p><em>context_ptr</em></p></th>
<th class="head"><p>Pointer to the context of the handler.</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>md_list_pptr</em></p></td>
<td><p>Double pointer to the list to which the new metadata object is</p>
<p>inserted.</p>
</td>
</tr>
<tr class="row-odd"><td><p>in</p></td>
<td><p><em>size</em></p></td>
<td><p>Size of the metadata object to be created</p></td>
</tr>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>heap_id</em></p></td>
<td><p>ID of the heap on which the metadata object is to be created.</p></td>
</tr>
<tr class="row-odd"><td><p>in</p></td>
<td><p><em>is_out_band</em></p></td>
<td><p>Indicates whether the metadata object is out-of-band in the</p>
<p><a class="reference external" href="#struct-module-cmn-md-t">module_cmn_md_t</a> structure.</p>
</td>
</tr>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>md_pptr</em></p></td>
<td><p>Double pointer to the new metadata object that is inserted.</p></td>
</tr>
</tbody>
</table>
<p><strong>Detailed description</strong></p>
<p>This function handles only one metadata object per call.</p>
<p>The module initializes the metadata with the ID, flag, and other details.</p>
<p>The metadata payload cannot contain references, for example, metadata_buf or metadata_ptr, that cannot contain a pointer to another memory.</p>
<p><strong>Returns</strong></p>
<blockquote>
<div><p>Error code (see <a class="reference internal" href="#capi-error-codes"><span class="std std-ref">Error Codes</span></a>).</p>
</div></blockquote>
<p><strong>capi_err_t(∗intf_extn_param_id_metadata_handler_t::metadata_clone)(void ∗context_ptr, module_cmn_md_t ∗md_ptr, module_cmn_md_list_t ∗∗md_list_pptr, capi_heap_id_t heap_id)</strong></p>
<p>Creates a clone and (deep) copies the payload contents of the given metadata (even for out-of-band, which is inherited when cloning).</p>
<p><strong>Associated data types</strong></p>
<p><a class="reference external" href="#struct-capi-heap-id-t">capi_heap_id_t</a></p>
<p><strong>Parameters</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>in</p></th>
<th class="head"><p><em>context_ptr</em></p></th>
<th class="head"><p>Pointer to the context of the handler.</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>md_ptr</em></p></td>
<td><p>Pointer to the metadata to be cloned.</p></td>
</tr>
<tr class="row-odd"><td><p>in</p></td>
<td><p><em>md_list_pptr</em></p></td>
<td><p>Double pointer to the metadata list in which the cloned object</p>
<p>is to be inserted.</p>
</td>
</tr>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>heap_id</em></p></td>
<td><p>ID of the heap on which the metadata object is to be created</p>
<p>when cloning.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Detailed description</strong></p>
<p>This function handles only one metadata object per call. For EOS and the data flow gap (DFG), special handling is automatically used.</p>
<p>Cloning is useful for modules such as splitters that replicate data from an input to multiple outputs.</p>
<p>However, cloning is costly due to mallocs. Use this function only if the input metadata list and objects cannot be reused for output. For example, the first output port can reuse metadata from input, but other output ports require clones.</p>
<p>The metadata payload cannot contain references, for example, metadata_buf or metadata_ptr, that cannot contain a pointer to another memory.</p>
<p><strong>Returns</strong></p>
<blockquote>
<div><p>Error code (see <a class="reference internal" href="#capi-error-codes"><span class="std std-ref">Error Codes</span></a>).</p>
</div></blockquote>
<p><strong>Dependencies</strong></p>
<blockquote>
<div><p>All input arguments must be valid.</p>
</div></blockquote>
<p><strong>capi_err_t(</strong>∗ <strong>intf_extn_param_id_metadata_handler_t::metadata_destroy)(void</strong> ∗<strong>context_ptr, module_cmn_md_list_t</strong> ∗<strong>md_list_ptr, bool_t is_dropped, module_cmn_md_list_t</strong> ∗∗<strong>head_pptr)</strong></p>
<p>Destroys a metadata object and updates the head pointer of the stream data’s metadata list.</p>
<p><strong>Parameters</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>in</p></th>
<th class="head"><p><em>context_ptr</em></p></th>
<th class="head"><p>Pointer to the context of the handler.</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>md_list_ptr</em></p></td>
<td><p>Pointer to the list of metadata.</p></td>
</tr>
<tr class="row-odd"><td><p>in</p></td>
<td><p><em>is_dropped</em></p></td>
<td><p>Indicates whether some metadata (EOS) can result in events</p>
<p>when not dropped.</p>
</td>
</tr>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>head_pptr</em></p></td>
<td><p>Pointer to the metadata list head pointer. If the current head is</p>
<p>being destroyed, it is updated with the next pointer.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Detailed description</strong></p>
<p>This destroy function is different from simply freeing memory. It changes reference counters and thus can affect when certain events are raised.</p>
<p>This function handles only one metadata per call. It updates the list when an object and list node are removed. For EOS, special handling is automatically used. For out-of-band, the payload is also freed.</p>
<p>If the caller is iterating over a list, the next pointer must be read before calling this function because the node will be freed by this call.</p>
<p><strong>Returns</strong></p>
<blockquote>
<div><p>Error code (see <a class="reference internal" href="#capi-error-codes"><span class="std std-ref">Error Codes</span></a>).</p>
</div></blockquote>
<p><strong>Dependencies</strong></p>
<blockquote>
<div><p>All input arguments must be valid.</p>
</div></blockquote>
<p><strong>capi_err_t(</strong>∗ <strong>intf_extn_param_id_metadata_handler_t::metadata_propagate)(void</strong></p>
<p>∗<strong>context_ptr, capi_stream_data_v2_t</strong> ∗<strong>input_stream_ptr, capi_stream_data_v2_t</strong> ∗<strong>output_stream_ptr, module_cmn_md_list_t</strong> ∗∗<strong>internal_md_list_pptr, uint32_t algo_delay_us, intf_extn_md_propagation_t</strong> ∗<strong>input_md_info_ptr, intf_extn_md_propagation_t</strong> ∗<strong>output_md_info_ptr)</strong></p>
<p>Propagates metadata from the input stream to an internal list and the output stream while considering algorithmic and buffering delays.</p>
<p><strong>Associated data types</strong></p>
<p><a class="reference external" href="#struct-capi-stream-data-v2-t">capi_stream_data_v2_t</a>
<a class="reference external" href="#struct-intf-extn-md-propagation-t">intf_extn_md_propagation_t</a></p>
<p><strong>Parameters</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>in</p></th>
<th class="head"><p><em>context_ptr</em></p></th>
<th class="head"><p>Pointer to the context of the handler.</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>input_stream_ptr</em></p></td>
<td><p>Pointer to the input stream provided in the</p>
<p><a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a> call.</p>
<p>This function uses only <a class="reference external" href="#_bookmark178">capi_stream_data_v2_t::flags</a> and metadata_list_ptr. It does not use <a class="reference external" href="#_bookmark179">capi_stream_data_v2_t::buf_ptr</a> or <a class="reference external" href="#_bookmark172">capi_buf_t::actual_data_len</a>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>in</p></td>
<td><p><em>output_stream_ptr</em></p></td>
<td><p>Pointer to the output stream pointer provided in the</p>
<p><a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a> call.</p>
<p>This function uses only <a class="reference external" href="#_bookmark178">capi_stream_data_v2_t::flags</a> and <a class="reference external" href="#_bookmark180">capi_stream_data_v2_t::metadata_list_ptr</a>. It does not use <a class="reference external" href="#_bookmark179">capi_stream_data_v2_t::buf_ptr</a> or <a class="reference external" href="#_bookmark172">capi_buf_t::actual_data_len</a>.</p>
</td>
</tr>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>internal_md_list_-</em></p>
<p><em>pptr</em></p>
</td>
<td><p>Double pointer to the list internal to the module.</p>
<p>This list stores the metadata that could not get to the output due to an algorithm delay.</p>
<p>For decoders, the internal list must be provided even if the algorithm delay is zero, because decoders must be called repeatedly during a forced <a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a> call.</p>
</td>
</tr>
<tr class="row-odd"><td><p>in</p></td>
<td><p><em>algo_delay_us</em></p></td>
<td><p>Algorithm delay in microseconds. This value must not include</p>
<p>the buffering delay.</p>
</td>
</tr>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>input_md_info_ptr</em></p></td>
<td><p>Pointer to the input metadata information.</p></td>
</tr>
<tr class="row-odd"><td><p>in</p></td>
<td><p><em>output_md_info_ptr</em></p></td>
<td><p>Pointer to the output metadata information.</p></td>
</tr>
</tbody>
</table>
<p><strong>Detailed description</strong></p>
<p>This function handles all metadata per call. Following is the simplified algorithm:</p>
<ul class="simple">
<li><p>Metadata whose offset is within the input data being consumed is
removed from the input stream metadata list and is moved to internal
list.</p></li>
<li><p>From the internal list, metadata whose offset is beyond the
algorithmic delay (plus buffering delay) is moved to the output
metadata list.</p></li>
<li><p>Stream data flags except EOF are updated.</p></li>
</ul>
<p>Typically, modules call this function from <a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a> after the module’s algorithm is processed and the amount of input consumed and amount of output produced are known.</p>
<p>While adjusting metadata offsets, this function segregates the input metadata list into the output metadata list or a module internal metadata list.</p>
<p>This function is suitable for one-to-one or one-to-many transfers of metadata from input to output (pairwise). It is not suitable for many-to-one because the input list is cleared after the first copy.</p>
<p>Multiport modules can use the function input-output pairwise. Metadata handling modules must take care of EOF because this function does not propagate EOF.</p>
<p>This function does not propagate end_of_frame (in <a class="reference external" href="#struct-capi-stream-data-v2-t">capi_stream_data_v2_t</a>).</p>
<p>Typically, end_of_frame must be propagated only after the module cannot produce any more outputs with the given inputs.</p>
<p>When end_of_frame is set, the given input can also be dropped if no output can be produced (for example, the threshold modules might require fixed length input to produce any output).</p>
<p>For modules that generate or consume metadata, the recommended order is:</p>
<ol class="arabic simple">
<li><p>Consume the input metadata.</p></li>
<li><p>Propagate the rest of the metadata using this function.</p></li>
<li><p>Add new metadata for the output.</p></li>
</ol>
<p>If data is dropped, this function must be called after dropping data.</p>
<p><strong>See also</strong></p>
<blockquote>
<div><p>marker_eos flag
(<a class="reference external" href="#union-capi-stream-flags-t">capi_stream_flags_t</a>)</p>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p>Error code (see <a class="reference internal" href="#capi-error-codes"><span class="std std-ref">Error Codes</span></a>).</p>
</div></blockquote>
<p><strong>Dependencies</strong></p>
<p>All input arguments must be valid.</p>
<p><strong>capi_err_t(</strong>∗ <strong>intf_extn_param_id_metadata_handler_t::metadata_modify_at_data_flow_start)(void</strong> ∗<strong>context_ptr, module_cmn_md_list_t</strong> ∗<strong>md_node_pptr, module_cmn_md_list_t</strong> ∗∗<strong>head_pptr)</strong></p>
<p>Checks and modifies any metadata when data flow starts.</p>
<p><strong>Associated data types</strong></p>
<blockquote>
<div><p><a class="reference external" href="#struct-module-cmn-md-list-t">module_cmn_md_list_t</a>
<a class="reference external" href="#struct-intf-extn-md-propagation-t">intf_extn_md_propagation_t</a></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>in</p></th>
<th class="head"><p><em>context_ptr</em></p></th>
<th class="head"><p>Pointer to the context of the handler.</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>md_node_pptr</em></p></td>
<td><p>Pointer to the metadata node to be handled.</p></td>
</tr>
<tr class="row-odd"><td><p>in</p></td>
<td><p><em>head_pptr</em></p></td>
<td><p>Double pointer to the head pointer to be updated.</p></td>
</tr>
</tbody>
</table>
<p><strong>Detailed description</strong></p>
<p>When data flow starts, any internal EOS or DFG in the buffer can be destroyed. Flushing EOS must be converted to non-flushing EOS. To achieve this, modules can call this function.</p>
<p>Only modules that modify the data flow state should implement this function. Most modules are not required to use this function because the framework typically takes care of this operation. For example, a module inserts zeroes when upstream data flow is stopped; it must call this function to change flushing EOS to non-flushing EOS. Thus, the metadata is modified as follows:</p>
<ol class="arabic simple">
<li><p>If it is flushing external EOS, make it non-flushing.</p></li>
<li><p>If it is flushing internal EOS, it is destroyed.</p></li>
<li><p>If it is DFG, it is destroyed.</p></li>
</ol>
<p>This function handles only one metadata node and updates the head pointer if necessary.</p>
<p><strong>Returns</strong></p>
<blockquote>
<div><p>Error code (see <a class="reference internal" href="#capi-error-codes"><span class="std std-ref">Error Codes</span></a>).</p>
</div></blockquote>
<p><strong>capi_err_t(</strong>∗ <strong>intf_extn_param_id_metadata_handler_t::metadata_create_with_tracking)(void</strong> ∗<strong>context_ptr, module_cmn_md_list_t</strong> ∗∗<strong>md_list_pptr, uint32_t size, capi_heap_id_t</strong> <strong>heap_id, uint32_t metadata_id, module_cmn_md_flags_t flags, module_cmn_md_tracking_t</strong> ∗<strong>md_tracking_ptr, module_cmn_md_t</strong> ∗∗<strong>md_pptr)</strong></p>
<p>Allocates memory for metadata with tracking, creates a list node, inserts the new list node to the tail of a given list, and creates a reference counter for tracking.</p>
<p><strong>Associated data types</strong></p>
<blockquote>
<div><p><a class="reference external" href="#struct-capi-heap-id-t">capi_heap_id_t</a></p>
</div></blockquote>
<p><strong>Parameters</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>in</p></th>
<th class="head"><p><em>context_ptr</em></p></th>
<th class="head"><p>Pointer to the context of the handler.</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>md_list_pptr</em></p></td>
<td><p>Double pointer to the list to which the new metadata object is</p>
<p>inserted.</p>
</td>
</tr>
<tr class="row-odd"><td><p>in</p></td>
<td><p><em>size</em></p></td>
<td><p>Size of the metadata object to be created.</p></td>
</tr>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>heap_id</em></p></td>
<td><p>ID of the heap on which the metadata object is to be created.</p></td>
</tr>
<tr class="row-odd"><td><p>in</p></td>
<td><p><em>metadata_id</em></p></td>
<td><p>Metadata GUID.</p></td>
</tr>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>flags</em></p></td>
<td><p>Specifies the metadata flags. variable type :</p>
<p><a class="reference external" href="#struct-module-cmn-md-flags-t">module_cmn_md_flags_t</a></p>
</td>
</tr>
<tr class="row-odd"><td><p>in</p></td>
<td><p><em>tracking_info_ptr</em></p></td>
<td><p>Specifies the tracking information. variable type :</p>
<p><a class="reference external" href="#struct-module-cmn-md-tracking-t">module_cmn_md_tracking_t</a></p>
</td>
</tr>
<tr class="row-even"><td><p>in</p></td>
<td><p><em>md_pptr</em></p></td>
<td><p>Double pointer to the new metadata object that is inserted.</p></td>
</tr>
</tbody>
</table>
<p><strong>Detailed description</strong></p>
<blockquote>
<div><p>This function handles only one metadata object per call.</p>
<p>The module initializes the metadata with the offset and other
details. This create would update the metadata ID and the flags.</p>
<p>The metadata creates a tracking reference. The tracking reference
contains the payload to raise an event when the metadata is
dropped/rendered based on the configuration specified during
metadata create.</p>
<p>The metadata payload cannot contain references, for example,
metadata_buf or metadata_ptr, that cannot contain a pointer to
another memory.</p>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p>Error code (see <a class="reference internal" href="#capi-error-codes"><span class="std std-ref">Error Codes</span></a>).</p>
</div></blockquote>
</section>
<section id="struct-module-cmn-md-flags-t">
<h5>struct module_cmn_md_flags_t<a class="headerlink" href="#struct-module-cmn-md-flags-t" title="Link to this heading"></a></h5>
<blockquote>
<div><p>Specifies the control flags for the various metadata features.</p>
</div></blockquote>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>union <a class="reference external" href="#struct-module-cmn-md-flags-t">module_-</a></p>
<p><a class="reference external" href="#struct-module-cmn-md-flags-t">cmn_md_flags-</a></p>
<p><a class="reference external" href="#struct-module-cmn-md-flags-t">_t</a></p>
</td>
<td><p>unnamed</p></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="union-module-cmn-md-flags-t-unnamed">
<h5>union module_cmn_md_flags_t. unnamed<a class="headerlink" href="#union-module-cmn-md-flags-t-unnamed" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>unnamed</p></td>
<td><p>unnamed</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>word</p></td>
<td><p>Entire 32-bit word for easy access to read or write an entire word in</p>
<p>one shot.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="struct-module-cmn-md-flags-t-unnamed-unnamed">
<h5>struct module_cmn_md_flags_t. unnamed <em>.</em> unnamed<a class="headerlink" href="#struct-module-cmn-md-flags-t-unnamed-unnamed" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>version: 3</p></td>
<td><p>Specifies the version of the internal metadata API.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="#define-module-cmn-md-version-0">MODULE_CMN_MD_VERSION</a></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>is_out_of_band: 1</p></td>
<td><p>Indicates whether the metadata is out-of-band.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="#define-module-cmn-md-out-of-band-1">MODULE_CMN_MD_OUT_OF_BAND</a></p></li>
<li><p><a class="reference external" href="#define-module-cmn-md-in-band-0">MODULE_CMN_MD_IN_BAND</a></p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>is_client_-</p>
<p>metadata: 1</p>
</td>
<td><p>Specifies if the metadata is from/to the external client.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="#define-module-cmn-md-is-external-client-md-1">MODULE_CMN_MD_IS_EXTERNAL_CLIENT_MD</a></p></li>
<li><p><a class="reference external" href="#define-module-cmn-md-is-internal-client-md-0">MODULE_CMN_MD_IS_INTERNAL_CLIENT_MD</a></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>tracking_mode: 2</p></td>
<td><p>Specifies if the metadata needs to be tracked and the event is raised for drop or consumption of the metadata.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="#define-module-cmn-md-tracking-config-disable-0">MODULE_CMN_MD_TRACKING_CONFIG_DISABLE</a></p></li>
<li><p><a class="reference external" href="#define-module-cmn-md-tracking-config-enable-for-drops-only-1">MODULE_CMN_MD_TRACKING_CONFIG_ENABLE_FOR_DROPS_ONLY</a></p></li>
<li><p><a class="reference external" href="#define-module-cmn-md-tracking-config-enable-for-drop-or-consume-2">MODULE_CMN_MD_TRACKING_CONFIG_ENABLE_FOR_DROP_OR_CONSUME</a></p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>tracking_policy: 1</p></td>
<td><p>Specifies the policy for raising the event.</p>
<p>For every split in the path, the metadata will be cloned to both the paths. This increases the internal references for the specified metadata and can lead to</p>
<p>multiple drops/consumptions.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="#define-module-cmn-md-tracking-event-policy-last-0">MODULE_CMN_MD_TRACKING_EVENT_POLICY_LAST</a></p></li>
<li><p><a class="reference external" href="#define-module-cmn-md-tracking-event-policy-each-1">MODULE_CMN_MD_TRACKING_EVENT_POLICY_EACH</a></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>buf_sample_-</p>
<p>association: 1</p>
</td>
<td><p>Indicates whether the metadata is sample- or buffer-associated.</p>
<p>Sample-associated metadata is applicable at the offset at which it is inserted. This metadata suffers both algorithmic and buffering delays, for example, EOS.</p>
<p>Buffer-associated metadata is applicable at the offset for the buffer. This metadata suffers buffering delays only, for example, Data Flow Gap.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="#define-module-cmn-md-buffer-associated-1">MODULE_CMN_MD_BUFFER_ASSOCIATED</a></p></li>
<li><p><a class="reference external" href="#define-module-cmn-md-sample-associated-0">MODULE_CMN_MD_SAMPLE_ASSOCIATED</a></p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>is_begin_-</p>
<p>associated_md: 1</p>
</td>
<td><p>Indicates whether the metadata is begin- or end-associated.</p>
<p>This is applicable when metadata is present when the data buffer is empty. If a module produces output data when there is no input data, this field indicates</p>
<p>whether the metadata offset at the output should be at the start or end of the buffer. The default behavior is end-associated.</p>
<p>For example, consider TTR metadata on voice Rx path in case of erasure. The Mailbox Rx module will set the erasure flag, create TTR metadata, and provide</p>
<p>an empty data buffer. Then, the voice decoder will insert the correct amount of zeros. During metadata propagation through the voice decoder, TTR must</p>
<p>remain atthe beginning of the buffer. However, other metadata like EOS must remain at the end of the buffer.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="#define-module-cmn-md-end-associated-md">MODULE_CMN_MD_END_ASSOCIATED_MD</a></p></li>
<li><p><a class="reference external" href="#define-module-cmn-md-begin-associated-md">MODULE_CMN_MD_BEGIN_ASSOCIATED_MD</a></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>needs_-</p>
<p>propagation_to-</p>
<p>_client_buffer: 1</p>
</td>
<td><p>Specifies if the metadata needs to be propagated to client in the  client buffer as well. This flag would be used to write the metadata to the Read Buffer if</p>
<p>enabled</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="#define-module-cmn-md-needs-propagation-to-client-buffer-disable-0">MODULE_CMN_MD_NEEDS_PROPAGATION_TO_CLIENT_BUFFER_DISABLE</a></p></li>
<li><p><a class="reference external" href="#define-module-cmn-md-needs-propagation-to-client-buffer-enable-1">MODULE_CMN_MD_NEEDS_PROPAGATION_TO_CLIENT_BUFFER_ENABLE</a></p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
<section id="struct-module-cmn-md-t">
<h5>struct module_cmn_md_t<a class="headerlink" href="#struct-module-cmn-md-t" title="Link to this heading"></a></h5>
<blockquote>
<div><p>Contains the CAPI metadata information.</p>
<p>In the ARE, metadata is passed in a
<a class="reference external" href="#capi-err-t-capi-vtbl-t-process-capi-t-pif-capi-stream-data-t-input-capi-stream-data-t-output">capi_vtbl_t::process()</a>
call through
<a class="reference external" href="#struct-capi-stream-data-v2-t">capi_stream_data_v2_t</a>.
Modules can consume some metadata from the list and produce metadata
that is attached to the list.</p>
<p>Metadata can be transferred between containers via the
metadata_list_ptr field of
<a class="reference external" href="#struct-capi-stream-data-v2-t">capi_stream_data_v2_t</a>. The
metadata payload cannot contain references; that is, both
metadata_buf and metadata_ptr cannot
contain a pointer to another memory buffer.</p>
<p>If the structure of the metadata payload is similar to {element 1,
element 2, pointer_to_mem}, we recommend you split this payload
into two metadata payloads with elements 1 and 2 in the first
payload, and pointer_to_mem in the second (out of band) payload.</p>
<p>All metadata is applicable for all channels. In other words, you
cannot attach different metadata to different channels.</p>
</div></blockquote>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>metadata_id</p></td>
<td><p>Globally Unique ID (GUID) of the metadata flag.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#struct-module-cmn-md-flags-t">module_cmn_md_flags_t</a></p></td>
<td><p>metadata_flag</p></td>
<td><p>Indicates the metadata flag.</p></td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>actual_size</p></td>
<td><p>Number of valid bytes in the payload.</p>
<p>This value starts from metadata_ptr or metadata_buf and excludes this <a class="reference external" href="#struct-module-cmn-md-t">module_cmn_md_t</a> struct.</p>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>max_size</p></td>
<td><p>Total size (in bytes) of the buffer in the payload.</p>
<p>This value starts from metadata_ptr or metadata_buf and excludes this <a class="reference external" href="#struct-module-cmn-md-t">module_cmn_md_t</a> struct.</p>
</td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>offset</p></td>
<td><p>Starting offset from which metadata is applicable.</p>
<p>When the offset is a valid value, the following criteria apply for propagation:</p>
<ul>
<li><p>For raw compressed data (<a class="reference external" href="#_bookmark188">CAPI_RAW_COMPRESSED</a>), the offset is in bytes.</p></li>
<li><p>For PCM and packetized data, the offset is in samples (per channel).</p></li>
<li><p>For de-interleaved data, metadata is applicable from the sample at (buffer + (sample_offset ∗ bits_per_sample)).</p></li>
<li><p>For interleaved data (most packetized formats are also</p>
<blockquote>
<div><p>interleaved), metadata is applicable from the sample at (buffer + (sample_offset ∗ bits_per_sample ∗ num channels)).</p>
</div></blockquote>
</li>
<li><p>For de-interleaved packed data, metadata is applicable from the</p>
<blockquote>
<div><p>sample at (buffer + offset + bits_per_sample) in each channel.</p>
</div></blockquote>
</li>
</ul>
<p>The sample_offset must be less than buffer end.</p>
</td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#struct-module-cmn-md-tracking-payload-t">module_cmn_md_tracking_payload_t</a> ∗</p></td>
<td><p>tracking_ptr</p></td>
<td><p>Metadata tracking payload, this pointer is valid only if tracking is</p>
<p>enabled.</p>
</td>
</tr>
<tr class="row-even"><td><p>union <a class="reference external" href="#struct-module-cmn-md-t">module_cmn_md_t</a></p></td>
<td><p>unnamed</p></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="union-module-cmn-md-t-unnamed">
<h5>union module_cmn_md_t. unnamed<a class="headerlink" href="#union-module-cmn-md-t-unnamed" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint64_t</p></td>
<td><p>metadata_buf</p></td>
<td><p>First byte of the metadata starts here (inline).</p></td>
</tr>
<tr class="row-odd"><td><p>void ∗</p></td>
<td><p>metadata_ptr</p></td>
<td><p>Pointer to the metadata buffer based on the metadata ID. It can be</p>
<p>cast according to the structure that corresponds to the metadata ID.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="struct-module-cmn-md-list-t">
<h5>struct module_cmn_md_list_t<a class="headerlink" href="#struct-module-cmn-md-list-t" title="Link to this heading"></a></h5>
<blockquote>
<div><p>Doubly linked list of metadata objects.</p>
</div></blockquote>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="#struct-module-cmn-md-t">module_cmn_md_t</a> ∗</p></td>
<td><p>obj_ptr</p></td>
<td><p>Pointer to the metadata object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#struct-module-cmn-md-list-t">module_cmn_md_list_t</a> ∗</p></td>
<td><p>next_ptr</p></td>
<td><p>Pointer to the next list item.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#struct-module-cmn-md-list-t">module_cmn_md_list_t</a> ∗</p></td>
<td><p>prev_ptr</p></td>
<td><p>Pointer to the previous list item.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="struct-module-cmn-md-eos-flags-t">
<h5>struct module_cmn_md_eos_flags_t<a class="headerlink" href="#struct-module-cmn-md-eos-flags-t" title="Link to this heading"></a></h5>
<blockquote>
<div><p>Contains the metadata EOS flags.</p>
</div></blockquote>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>union <a class="reference external" href="#struct-module-cmn-md-eos-flags-t">module_-</a></p>
<p><a class="reference external" href="#struct-module-cmn-md-eos-flags-t">cmn_md_eos_flags_t</a></p>
</td>
<td><p>unnamed</p></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="union-module-cmn-md-eos-flags-t-unnamed">
<h5>union module_cmn_md_eos_flags_t. unnamed<a class="headerlink" href="#union-module-cmn-md-eos-flags-t-unnamed" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>unnamed</p></td>
<td><p>unnamed</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>word</p></td>
<td><p>Entire 32-bit word for easy access to read or write an entire word in</p>
<p>one shot.</p>
</td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>Type</strong></p></td>
<td><p><strong>Parameter</strong></p></td>
<td><p><strong>Description</strong></p></td>
</tr>
</tbody>
</table>
</section>
<section id="struct-module-cmn-md-eos-flags-t-unnamed-unnamed">
<h5>struct module_cmn_md_eos_flags_t. unnamed <em>.</em> unnamed<a class="headerlink" href="#struct-module-cmn-md-eos-flags-t-unnamed-unnamed" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>is_flushing_eos: 1</p></td>
<td><p>Flag that indicates whether all stream data is to be rendered.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="#define-module-cmn-md-eos-flushing-1">MODULE_CMN_MD_EOS_FLUSHING</a></p></li>
<li><p><a class="reference external" href="#define-module-cmn-md-eos-non-flushing-0">MODULE_CMN_MD_EOS_NON_FLUSHING</a></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>is_internal_eos: 1</p></td>
<td><p>Flag that indicates whether an EOS was introduced internally.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>TRUE (EOS was introduced internally due to an upstream gap (stop or flush)</p></li>
<li><p>FALSE (EOS is due to some other reason)</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>skip_voting_-</p>
<p>on_dfs_change: 1</p>
</td>
<td><p>Flag that indicates if KPPS and bandwidth voting needs to be</p>
<p>skipped when data flow stops and restarts for the modules that propagated this particular EOS. Framework does best effort to not vote if this flag is set.</p>
<p>This can help in the cases where data flow changes within island and the use case doesnt have to exit island.</p>
<p>If any another EOS gets propagated with this flag=false, any previous skip votings may not be honored. The same applies if any control/events get triggered, skip vote will be ignored and framework will update the votes.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>TRUE – KPPS and bandwidth voting can be skipped in the propagated path</p></li>
<li><p>FALSE – Default behavior; updates the votes based on the data flow state</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
<section id="struct-module-cmn-md-eos-t">
<h5>struct module_cmn_md_eos_t<a class="headerlink" href="#struct-module-cmn-md-eos-t" title="Link to this heading"></a></h5>
<blockquote>
<div><p>Contains the stream’s metadata</p>
</div></blockquote>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="#struct-module-cmn-md-eos-flags-t">module_cmn_-</a></p>
<p><a class="reference external" href="#struct-module-cmn-md-eos-flags-t">md_eos_flags_t</a></p>
</td>
<td><p>flags</p></td>
<td><p>EOS flags</p></td>
</tr>
<tr class="row-odd"><td><p>void ∗</p></td>
<td><p>cntr_ref_ptr</p></td>
<td><p>Pointer to the container reference structure, which only lives within</p>
<p>a container.</p>
</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="path-delay">
<span id="id61"></span><h3>Path Delay<a class="headerlink" href="#path-delay" title="Link to this heading"></a></h3>
<section id="id62">
<h4>Define Documentation<a class="headerlink" href="#id62" title="Link to this heading"></a></h4>
<section id="define-intf-extn-path-delay-0x0a00102e">
<h5>#define INTF_EXTN_PATH_DELAY 0x0A00102E<a class="headerlink" href="#define-intf-extn-path-delay-0x0a00102e" title="Link to this heading"></a></h5>
<blockquote>
<div><p>Unique identifier of the Path Delay interface extension, which
modules use to get defined path delays. This module supports the
following event and parameter IDs:</p>
</div></blockquote>
<ul class="simple">
<li><p><a class="reference external" href="#define-intf-extn-event-id-request-path-delay-0x0a00102f">INTF_EXTN_EVENT_ID_REQUEST_PATH_DELAY</a></p></li>
<li><p><a class="reference external" href="#define-intf-extn-param-id-response-path-delay-0x0a001030">INTF_EXTN_PARAM_ID_RESPONSE_PATH_DELAY</a></p></li>
<li><p><a class="reference external" href="#define-intf-extn-param-id-destroy-path-delay-0x0a001032">INTF_EXTN_PARAM_ID_DESTROY_PATH_DELAY</a></p></li>
</ul>
</section>
<section id="define-intf-extn-event-id-request-path-delay-0x0a00102f">
<h5>#define INTF_EXTN_EVENT_ID_REQUEST_PATH_DELAY 0x0A00102F<a class="headerlink" href="#define-intf-extn-event-id-request-path-delay-0x0a00102f" title="Link to this heading"></a></h5>
<blockquote>
<div><p>ID of the event to use with
<a class="reference external" href="#_bookmark338">CAPI_EVENT_DATA_TO_DSP_SERVICE</a> to request a
service to set up the path delay mechanism.</p>
</div></blockquote>
<p><strong>Message payload (intf_extn_event_id_request_path_delay_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>src_module_-</p>
<p>instance_id</p>
</td>
<td><p>Identifies the module instance that is the source of the path.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>src_port_id</p></td>
<td><p>Identifies the port that is the source of the path.</p>
<p>If the ID is unknown, set this field to 0.</p>
</td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>dst_module_-</p>
<p>instance_id</p>
</td>
<td><p>Identifies the module instance that is the destination of the path.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>dst_port_id</p></td>
<td><p>Identifies the port that is the destination of the path.</p>
<p>If the ID is unknown, set this field to 0.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-intf-extn-param-id-response-path-delay-0x0a001030">
<h5>#define INTF_EXTN_PARAM_ID_RESPONSE_PATH_DELAY 0x0A001030<a class="headerlink" href="#define-intf-extn-param-id-response-path-delay-0x0a001030" title="Link to this heading"></a></h5>
<blockquote>
<div><p>ID of the parameter used to set the path delay-related information.</p>
<p>The containers sets this parameter on the module that raised
<a class="reference external" href="#define-intf-extn-event-id-request-path-delay-0x0a00102f">INTF_EXTN_EVENT_ID_REQUEST_PATH_DELAY</a>.</p>
</div></blockquote>
<p><strong>Message payload (intf_extn_path_delay_response_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>path_id</p></td>
<td><p>Identifies the path assigned by the framework.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>src_module_-</p>
<p>instance_id</p>
</td>
<td><p>Identifies the module instance that is the source of the path.</p></td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>src_port_id</p></td>
<td><p>Identifies the port that is the source of the path.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>dst_module_-</p>
<p>instance_id</p>
</td>
<td><p>Identifies the module instance that is the destination of the path.</p></td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>dst_port_id</p></td>
<td><p>Identifies the port that is the destination of the path.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>num_delay_ptrs</p></td>
<td><p>Number of delay pointers.</p></td>
</tr>
<tr class="row-even"><td><p>volatile uint32_t ∗∗</p></td>
<td><p>delay_us_pptr</p></td>
<td><p>Pointer to the array of pointers to the delay variable created by the</p>
<p>Audio Processing Manager (APM).</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-intf-extn-param-id-destroy-path-delay-0x0a001032">
<h5>#define INTF_EXTN_PARAM_ID_DESTROY_PATH_DELAY 0x0A001032<a class="headerlink" href="#define-intf-extn-param-id-destroy-path-delay-0x0a001032" title="Link to this heading"></a></h5>
<blockquote>
<div><p>ID of the parameter used to clear the path delay-related
information.</p>
<p>The containers set this parameter on the module that received
<a class="reference external" href="#define-intf-extn-param-id-response-path-delay-0x0a001030">INTF_EXTN_PARAM_ID_RESPONSE_PATH_DELAY</a>.</p>
<p>Even if the destroy function is not called, the modules are to clear
everything in the end function.</p>
</div></blockquote>
<p><strong>Message payload (intf_extn_path_delay_destroy_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bool_t</p></td>
<td><p>is_set</p></td>
<td><p>Indicates whether the path delay is set.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE (unset the delay during close or destroy operations)</p></li>
<li><p>1 – TRUE (set the delay in response to <a class="reference external" href="#define-intf-extn-event-id-request-path-delay-0x0a00102f">INTF_EXTN_EVENT_ID_REQUEST_PATH_DELAY</a></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>path_id</p></td>
<td><p>Identifies the path assigned by the framework.</p></td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>src_module_instance_id</p></td>
<td><p>Identifies the module instance that is the source of the path.</p></td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>src_port_id</p></td>
<td><p>Port ID of the source of the path.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="propagated-port-properties">
<h3>Propagated Port Properties<a class="headerlink" href="#propagated-port-properties" title="Link to this heading"></a></h3>
<section id="id63">
<h4>Define Documentation<a class="headerlink" href="#id63" title="Link to this heading"></a></h4>
<section id="define-intf-extn-prop-is-rt-port-property-0x0a001048">
<h5>#define INTF_EXTN_PROP_IS_RT_PORT_PROPERTY 0x0A001048<a class="headerlink" href="#define-intf-extn-prop-is-rt-port-property-0x0a001048" title="Link to this heading"></a></h5>
<blockquote>
<div><p>Unique identifier of the interface extension used to propagate port
properties across modules in real time or non-real time.</p>
<p>This extension supports the following parameter and event IDs:</p>
</div></blockquote>
<ul class="simple">
<li><p><a class="reference external" href="#define-intf-extn-param-id-is-rt-port-property-0x0a001049">INTF_EXTN_PARAM_ID_IS_RT_PORT_PROPERTY</a></p></li>
<li><p><a class="reference external" href="#define-intf-extn-event-id-is-rt-port-property-0x0a00104a">INTF_EXTN_EVENT_ID_IS_RT_PORT_PROPERTY</a></p></li>
</ul>
</section>
<section id="define-intf-extn-param-id-is-rt-port-property-0x0a001049">
<h5>#define INTF_EXTN_PARAM_ID_IS_RT_PORT_PROPERTY 0x0A001049<a class="headerlink" href="#define-intf-extn-param-id-is-rt-port-property-0x0a001049" title="Link to this heading"></a></h5>
<p>ID of the parameter a container uses to tell a module about the port property of a specified port.</p>
<p>Upon receiving the property, the module can either propagate the state to the connected input/output ports or ignore the parameter.</p>
<p><strong>Message payload (intf_extn_param_id_is_rt_port_property_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bool_t</p></td>
<td><p>is_rt</p></td>
<td><p>Indicates whether the propagated property is real time.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE (non-real time)</p></li>
<li><p>1 – TRUE (real time)</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>bool_t</p></td>
<td><p>is_input</p></td>
<td><p>Indicates whether the port is an input port.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE (output port)</p></li>
<li><p>1 – TRUE (input port)</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>port_index</p></td>
<td><p>Input or output port index, depending on the value of is_input.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="define-intf-extn-event-id-is-rt-port-property-0x0a00104a">
<h5>#define INTF_EXTN_EVENT_ID_IS_RT_PORT_PROPERTY 0x0A00104A<a class="headerlink" href="#define-intf-extn-event-id-is-rt-port-property-0x0a00104a" title="Link to this heading"></a></h5>
<p>ID of the event raised by a module via <a class="reference external" href="#_bookmark338">CAPI_EVENT_DATA_TO_DSP_SERVICE</a> in response to <a class="reference external" href="#define-intf-extn-param-id-is-rt-port-property-0x0a001049">INTF_EXTN_PARAM_ID_IS_RT_PORT_PROPERTY</a>.</p>
<p><strong>Message payload (intf_extn_param_id_is_rt_port_property_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bool_t</p></td>
<td><p>is_rt</p></td>
<td><p>Indicates whether the propagated property is real time.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE (non-real time)</p></li>
<li><p>1 – TRUE (real time)</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>bool_t</p></td>
<td><p>is_input</p></td>
<td><p>Indicates whether the port is an input port.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE (output port)</p></li>
<li><p>1 – TRUE (input port)</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>port_index</p></td>
<td><p>Input or output port index, depending on the value of is_input.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="propagated-port-downstream-states">
<h3>Propagated Port Downstream States<a class="headerlink" href="#propagated-port-downstream-states" title="Link to this heading"></a></h3>
<section id="id64">
<h4>Define Documentation<a class="headerlink" href="#id64" title="Link to this heading"></a></h4>
<section id="define-intf-extn-prop-port-ds-state-0x0a001040">
<h5>#define INTF_EXTN_PROP_PORT_DS_STATE 0x0A001040<a class="headerlink" href="#define-intf-extn-prop-port-ds-state-0x0a001040" title="Link to this heading"></a></h5>
<p>Unique identifier of the interface extension used to propagate the downstream state of a port. This extension supports the following parameter and event IDs:</p>
<ul class="simple">
<li><p><a class="reference external" href="#define-intf-extn-param-id-port-ds-state-0x0a001041">INTF_EXTN_PARAM_ID_PORT_DS_STATE</a></p></li>
<li><p><a class="reference external" href="#define-intf-extn-event-id-port-ds-state-0x0a001042">INTF_EXTN_EVENT_ID_PORT_DS_STATE</a></p></li>
<li><p><a class="reference external" href="#define-intf-extn-event-id-block-port-ds-state-prop-0x0a001046">INTF_EXTN_EVENT_ID_BLOCK_PORT_DS_STATE_PROP</a></p></li>
</ul>
</section>
<section id="define-intf-extn-param-id-port-ds-state-0x0a001041">
<h5>#define INTF_EXTN_PARAM_ID_PORT_DS_STATE 0x0A001041<a class="headerlink" href="#define-intf-extn-param-id-port-ds-state-0x0a001041" title="Link to this heading"></a></h5>
<p>ID of the parameter that the container uses to send the downstream state of an output port to a module. Upon receiving the state, the module can either propagate the state to connected input ports or ignore the parameter.</p>
<p>When a module implements this interface extension, the framework does not automatically propagate the state, even for SISO modules.</p>
<p>If the module chooses to ignore the downstream state, it must ignore all Prepare, Start, and Stop states.</p>
<p><strong>Message payload (intf_extn_param_id_port_ds_state_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>output_port_index</p></td>
<td><p>Index of the output port that receives the downstream state.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#enum-intf-extn-prop-data-port-state-t">intf_extn_prop_data_port_state_t</a></p></td>
<td><p>port_state</p></td>
<td><p>Downstream state of the port being propagated.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="#intf-extn-prop-data-port-state-stopped">INTF_EXTN_PROP_DATA_PORT_STATE_STOPPED</a></p></li>
<li><p><a class="reference external" href="#intf-extn-prop-data-port-state-prepared">INTF_EXTN_PROP_DATA_PORT_STATE_PREPARED</a></p></li>
<li><p><a class="reference external" href="#intf-extn-prop-data-port-state-started">INTF_EXTN_PROP_DATA_PORT_STATE_STARTED</a></p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-intf-extn-event-id-port-ds-state-0x0a001042">
<h5>#define INTF_EXTN_EVENT_ID_PORT_DS_STATE 0x0A001042<a class="headerlink" href="#define-intf-extn-event-id-port-ds-state-0x0a001042" title="Link to this heading"></a></h5>
<p>ID of the event raised by module via <a class="reference external" href="#_bookmark338">CAPI_EVENT_DATA_TO_DSP_SERVICE</a> in response to <a class="reference external" href="#define-intf-extn-param-id-port-ds-state-0x0a001041">INTF_EXTN_PARAM_ID_PORT_DS_STATE</a>.</p>
<p><strong>Message payload (intf_extn_event_id_port_ds_state_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>input_port_index</p></td>
<td><p>Index of the input port that is providing the downstream state.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#enum-intf-extn-prop-data-port-state-t">intf_extn_prop_data_port_state_t</a></p></td>
<td><p>port_state</p></td>
<td><p>Downstream state of the port being propagated.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="#intf-extn-prop-data-port-state-stopped">INTF_EXTN_PROP_DATA_PORT_STATE_STOPPED</a></p></li>
<li><p><a class="reference external" href="#intf-extn-prop-data-port-state-prepared">INTF_EXTN_PROP_DATA_PORT_STATE_PREPARED</a></p></li>
<li><p><a class="reference external" href="#intf-extn-prop-data-port-state-started">INTF_EXTN_PROP_DATA_PORT_STATE_STARTED</a></p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-intf-extn-event-id-block-port-ds-state-prop-0x0a001046">
<h5>#define INTF_EXTN_EVENT_ID_BLOCK_PORT_DS_STATE_PROP 0x0A001046<a class="headerlink" href="#define-intf-extn-event-id-block-port-ds-state-prop-0x0a001046" title="Link to this heading"></a></h5>
<p>Raised on an output port to block the downstream state propagation from that port.</p>
<p>A module raises this event when the state of its output port is not to change because of the downstream state. This event is raised only when the output port is open, so the module also must implement <a class="reference external" href="#define-intf-extn-data-port-operation-0x0a001023">INTF_EXTN_DATA_PORT_OPERATION</a>.</p>
<p><strong>Message payload (intf_extn_event_id_block_port_ds_state_prop_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>output_port_index</p></td>
<td><p>Index of the output port that is not to change per the downstream</p>
<p>state propagation.</p>
</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="id65">
<h4>Enumeration Type Documentation<a class="headerlink" href="#id65" title="Link to this heading"></a></h4>
<section id="enum-intf-extn-prop-data-port-state-t">
<h5>enum intf_extn_prop_data_port_state_t<a class="headerlink" href="#enum-intf-extn-prop-data-port-state-t" title="Link to this heading"></a></h5>
<p>Valid values for propagated data port states.</p>
<p><strong>Enumerator:</strong></p>
</section>
<section id="intf-extn-prop-data-port-state-stopped">
<h5><strong>INTF_EXTN_PROP_DATA_PORT_STATE_STOPPED</strong><a class="headerlink" href="#intf-extn-prop-data-port-state-stopped" title="Link to this heading"></a></h5>
<p>Propagated state of the port is stopped.</p>
</section>
<section id="intf-extn-prop-data-port-state-prepared">
<h5><strong>INTF_EXTN_PROP_DATA_PORT_STATE_PREPARED</strong><a class="headerlink" href="#intf-extn-prop-data-port-state-prepared" title="Link to this heading"></a></h5>
<p>Propagated state of the port is prepared.</p>
</section>
<section id="intf-extn-prop-data-port-state-started">
<h5><strong>INTF_EXTN_PROP_DATA_PORT_STATE_STARTED</strong><a class="headerlink" href="#intf-extn-prop-data-port-state-started" title="Link to this heading"></a></h5>
<p>Propagated state of the port is started.</p>
</section>
<section id="intf-extn-prop-data-port-state-suspended">
<h5><strong>INTF_EXTN_PROP_DATA_PORT_STATE_SUSPENDED</strong><a class="headerlink" href="#intf-extn-prop-data-port-state-suspended" title="Link to this heading"></a></h5>
<p>Propagated state of data port is suspended.</p>
</section>
</section>
<section id="intf-extn-prop-data-port-state-invalid">
<h4><strong>INTF_EXTN_PROP_DATA_PORT_STATE_INVALID</strong><a class="headerlink" href="#intf-extn-prop-data-port-state-invalid" title="Link to this heading"></a></h4>
<p>Invalid propagated state.</p>
</section>
</section>
<section id="mimo-modules-process-states">
<h3>MIMO Modules Process States<a class="headerlink" href="#mimo-modules-process-states" title="Link to this heading"></a></h3>
<p>MIMO modules that can sometimes work in SISO mode and don’t need any processing from input to output can be disabled using this extension.</p>
<p>If MIMO modules use the generic event (<a class="reference external" href="#_bookmark333">CAPI_EVENT_PROCESS_STATE</a>) to disable then data flow is blocked at their input which may not be desirable, so this extension can be used to inform the framework that they are disabled. The framework tries to honor the modules’ request by evaluating the following conditions.</p>
<ul class="simple">
<li><p>Module must be in SISO mode. Only one active input and one active
output port.</p></li>
<li><p>Module must have zero algorithm/buffer delay. It should not be
maintaining any delay buffer while in the Disabled state.</p></li>
<li><p>Module must have valid and same media format on input and output
ports.</p></li>
</ul>
<p>The framework can enable the module at any time without informing the module. Usually this occurs when:</p>
<ul class="simple">
<li><p>A new port opens and module is not operating in SISO mode anymore</p></li>
<li><p>Framework detects non-zero algorithm delay for the module</p></li>
<li><p>Framework detects a different media format on input and output ports</p></li>
</ul>
<p>Modules can also be enabled temporarily to propagate certain metadata. This is why modules must not have any algorithm delay when disabled, because its processes can be called discontinuously and if there is any delay buffer then it can get discontinuous data.</p>
<section id="id66">
<h4>Define Documentation<a class="headerlink" href="#id66" title="Link to this heading"></a></h4>
<section id="define-intf-extn-mimo-module-process-state-0x0a00101c">
<h5>#define INTF_EXTN_MIMO_MODULE_PROCESS_STATE 0x0A00101C<a class="headerlink" href="#define-intf-extn-mimo-module-process-state-0x0a00101c" title="Link to this heading"></a></h5>
<p>Unique identifier of the interface extension that the MIMO module uses to enable/disable itself. Only MIMO modules which can’t use <a class="reference external" href="#_bookmark333">CAPI_EVENT_PROCESS_STATE</a> to update their enable/disable state should use this extension.</p>
<p>This extension supports the following events:</p>
<ul class="simple">
<li><p><a class="reference external" href="#define-intf-extn-event-id-mimo-module-process-state-0x0a001059">INTF_EXTN_EVENT_ID_MIMO_MODULE_PROCESS_STATE</a></p></li>
</ul>
</section>
<section id="define-intf-extn-event-id-mimo-module-process-state-0x0a001059">
<h5>#define INTF_EXTN_EVENT_ID_MIMO_MODULE_PROCESS_STATE 0x0A001059<a class="headerlink" href="#define-intf-extn-event-id-mimo-module-process-state-0x0a001059" title="Link to this heading"></a></h5>
<p>ID of the custom event raised by the module to enable/disable itself.</p>
<p>When the module disables itself the framework evaluates whether the module can be removed from the processing chain or not.</p>
<ul class="simple">
<li><p>If it can be removed the module’s process will not be called .</p></li>
<li><p>If it can’t be removed the module is considered enabled.</p></li>
</ul>
<p>Even if the module is considered disabled, the framework can still call the module’s process, usually to propagate certain metadata.</p>
<p><strong>Message payload (intf_extn_event_id_mimo_module_process_state_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bool_t</p></td>
<td><p>is_disabled</p></td>
<td><p>Indicates whether the module is disabled or enabled.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – Enabled</p></li>
<li><p>1 – Disabled</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="duty-cycling-island">
<h3>Duty Cycling Island<a class="headerlink" href="#duty-cycling-island" title="Link to this heading"></a></h3>
<section id="id67">
<h4>Define Documentation<a class="headerlink" href="#id67" title="Link to this heading"></a></h4>
<section id="define-intf-extn-param-id-cntr-duty-cycling-enabled-0x0a001063">
<h5>#define INTF_EXTN_PARAM_ID_CNTR_DUTY_CYCLING_ENABLED 0x0A001063<a class="headerlink" href="#define-intf-extn-param-id-cntr-duty-cycling-enabled-0x0a001063" title="Link to this heading"></a></h5>
<p>ID of the parameter a container uses to tell a module about the duty cycling mode of the container. Upon receiving the property, the gapless module raises a buffer fullness event.</p>
<p><strong>Message payload (intf_extn_param_id_cntr_duty_cycling_enabled_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bool_t</p></td>
<td><p>is_cntr_duty_cycling</p></td>
<td><p>Indicates whether the container is duty cycling enabled.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE</p></li>
<li><p>1 – TRUE</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-intf-extn-event-id-allow-duty-cycling-0x0a001064">
<h5>#define INTF_EXTN_EVENT_ID_ALLOW_DUTY_CYCLING 0x0A001064<a class="headerlink" href="#define-intf-extn-event-id-allow-duty-cycling-0x0a001064" title="Link to this heading"></a></h5>
<p>ID of the event raised by a module via <a class="reference external" href="#_bookmark338">CAPI_EVENT_DATA_TO_DSP_SERVICE</a> in response to <a class="reference external" href="#define-intf-extn-event-id-allow-duty-cycling-0x0a001064">INTF_EXTN_EVENT_ID_ALLOW_DUTY_CYCLING</a>.</p>
<p><strong>Message payload (intf_extn_event_id_allow_duty_cycling_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bool_t</p></td>
<td><p>is_buffer_full_-</p>
<p>req_dcm_to_unblock_island-</p>
<p>_entry</p>
</td>
<td><p>Indicates whether the module buffer is full, e.g., Gapless Delay</p>
<p>Buffer.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE</p></li>
<li><p>1 – TRUE</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
<section id="define-intf-extn-event-id-allow-duty-cycling-v2-0x0a001069">
<h5>#define INTF_EXTN_EVENT_ID_ALLOW_DUTY_CYCLING_V2 0x0A001069<a class="headerlink" href="#define-intf-extn-event-id-allow-duty-cycling-v2-0x0a001069" title="Link to this heading"></a></h5>
<p>ID of the event raised by a module via <a class="reference external" href="#_bookmark338">CAPI_EVENT_DATA_TO_DSP_SERVICE</a> in response to <a class="reference external" href="#define-intf-extn-event-id-allow-duty-cycling-v2-0x0a001069">INTF_EXTN_EVENT_ID_ALLOW_DUTY_CYCLING_V2</a>.</p>
<p><strong>Message payload (intf_extn_event_id_allow_duty_cycling_v2_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bool_t</p></td>
<td><p>allow_duty_cycling</p></td>
<td><p>Indicates whether the module allows duty cycling or not, e.g., the</p>
<p>gapless module allows duty cycling when the buffer is full.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE</p></li>
<li><p>1 – TRUE</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="id68">
<h4>Typedef Documentation<a class="headerlink" href="#id68" title="Link to this heading"></a></h4>
<section id="typedef-struct-intf-extn-param-id-cntr-duty-cycling-enabled-t-intf-extn-param-id-cntr-duty-cycling-enabled-t">
<h5>typedef struct intf_extn_param_id_cntr_duty_cycling_enabled_t intf_extn_param_id_cntr_duty_cycling_enabled_t<a class="headerlink" href="#typedef-struct-intf-extn-param-id-cntr-duty-cycling-enabled-t-intf-extn-param-id-cntr-duty-cycling-enabled-t" title="Link to this heading"></a></h5>
<p>ID of the event raised by a module via <a class="reference external" href="#_bookmark338">CAPI_EVENT_DATA_TO_DSP_SERVICE</a> in response to <a class="reference external" href="#define-intf-extn-param-id-cntr-duty-cycling-enabled-0x0a001063">INTF_EXTN_PARAM_ID_CNTR_DUTY_CYCLING_ENABLED</a>.</p>
<p><strong>Message payload (intf_extn_param_id_cntr_duty_cycling_enabled_t)</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bool_t</p></td>
<td><p>is_cntr_duty_cycling</p></td>
<td><p>Indicates whether the container is duty cycling enabled.</p>
<p><strong>Supported values:</strong></p>
<ul class="simple">
<li><p>0 – FALSE</p></li>
<li><p>1 – TRUE</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="period-length">
<h3>Period Length<a class="headerlink" href="#period-length" title="Link to this heading"></a></h3>
<section id="id69">
<h4>Define Documentation<a class="headerlink" href="#id69" title="Link to this heading"></a></h4>
<section id="define-intf-extn-period-0x0a001060">
<h5>#define INTF_EXTN_PERIOD 0x0A001060<a class="headerlink" href="#define-intf-extn-period-0x0a001060" title="Link to this heading"></a></h5>
<p>Unique identifier to get the VFR cycle duration.</p>
</section>
<section id="define-intf-extn-param-id-period-0x0a001061">
<h5>#define INTF_EXTN_PARAM_ID_PERIOD 0x0A001061<a class="headerlink" href="#define-intf-extn-param-id-period-0x0a001061" title="Link to this heading"></a></h5>
<p>ID of the parameter the framework uses to inform VFR cycle duration to the module.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>period_us</p></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Message payload (intf_extn_period_t)</strong></p>
</section>
</section>
</section>
<section id="signal-triggered-module-timestamp">
<h3>Signal Triggered Module Timestamp<a class="headerlink" href="#signal-triggered-module-timestamp" title="Link to this heading"></a></h3>
<section id="id70">
<h4>Define Documentation<a class="headerlink" href="#id70" title="Link to this heading"></a></h4>
<section id="define-intf-extn-stm-ts-0x0a001baf">
<h5>#define INTF_EXTN_STM_TS 0x0A001BAF<a class="headerlink" href="#define-intf-extn-stm-ts-0x0a001baf" title="Link to this heading"></a></h5>
<p>Unique identifier of the Signal Triggered Module Timestamp interface extension.</p>
</section>
<section id="define-intf-extn-param-id-stm-ts-0x0a001bb0">
<h5>#define INTF_EXTN_PARAM_ID_STM_TS 0x0A001BB0<a class="headerlink" href="#define-intf-extn-param-id-stm-ts-0x0a001bb0" title="Link to this heading"></a></h5>
<p>ID of the parameter the framework uses to share the latest signal-trigger timestamp value to the module.</p>
</section>
</section>
<section id="id71">
<h4>Data Structure Documentation<a class="headerlink" href="#id71" title="Link to this heading"></a></h4>
<section id="struct-intf-extn-param-id-stm-ts-t">
<h5>struct intf_extn_param_id_stm_ts_t<a class="headerlink" href="#struct-intf-extn-param-id-stm-ts-t" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type</strong></p></th>
<th class="head"><p><strong>Parameter</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="#_bookmark435">stm_latest_-</a></p>
<p><a class="reference external" href="#_bookmark435">trigger_ts_t</a> ∗</p>
</td>
<td><p>ts_ptr</p></td>
<td><p>Pointer to store the address pointing to the latest signal trigger</p>
<p>timestamp.</p>
</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="id72">
<h4>Typedef Documentation<a class="headerlink" href="#id72" title="Link to this heading"></a></h4>
<section id="typedef-struct-stm-latest-trigger-ts-t-stm-latest-trigger-ts-t">
<h5>typedef struct stm_latest_trigger_ts_t stm_latest_trigger_ts_t<a class="headerlink" href="#typedef-struct-stm-latest-trigger-ts-t-stm-latest-trigger-ts-t" title="Link to this heading"></a></h5>
<p>Structure used in <a class="reference external" href="#define-intf-extn-param-id-stm-ts-0x0a001bb0">INTF_EXTN_PARAM_ID_STM_TS</a></p>
</section>
</section>
</section>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading"></a></h2>
<section id="acronyms-and-terms">
<h3>Acronyms and Terms<a class="headerlink" href="#acronyms-and-terms" title="Link to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Acronym or term</strong></p></th>
<th class="head"><p><strong>Definition</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>APM</p></td>
<td><p>Audio Processing Manager</p></td>
</tr>
<tr class="row-odd"><td><p>ASRC</p></td>
<td><p>Asynchronous Sample Rate Converter</p></td>
</tr>
<tr class="row-even"><td><p>CAPI</p></td>
<td><p>Common Audio Processor Interface</p></td>
</tr>
<tr class="row-odd"><td><p>COP</p></td>
<td><p>Compressed over PCM</p></td>
</tr>
<tr class="row-even"><td><p>DRC</p></td>
<td><p>Dynamic range control</p></td>
</tr>
<tr class="row-odd"><td><p>DSD</p></td>
<td><p>Direct-Stream Digital</p></td>
</tr>
<tr class="row-even"><td><p>DTX</p></td>
<td><p>Discontinuous transmission</p></td>
</tr>
<tr class="row-odd"><td><p>ECNS</p></td>
<td><p>Echo cancellation and noise suppression</p></td>
</tr>
<tr class="row-even"><td><p>EOF</p></td>
<td><p>End of frame</p></td>
</tr>
<tr class="row-odd"><td><p>EOS</p></td>
<td><p>End of stream</p></td>
</tr>
<tr class="row-even"><td><p>GUID</p></td>
<td><p>Globally unique identifier</p></td>
</tr>
<tr class="row-odd"><td><p>KPPS</p></td>
<td><p>Kilo packets per second</p></td>
</tr>
<tr class="row-even"><td><p>LCM</p></td>
<td><p>Least common multiple</p></td>
</tr>
<tr class="row-odd"><td><p>PCM</p></td>
<td><p>Pulse coded modulation</p></td>
</tr>
<tr class="row-even"><td><p>SISO</p></td>
<td><p>Single input-single output</p></td>
</tr>
<tr class="row-odd"><td><p>ARC</p></td>
<td><p>AudioReach Creator</p></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="dev_workflow.html" class="btn btn-neutral float-left" title="Use Case Development Workflow" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="plat_port.html" class="btn btn-neutral float-right" title="Platform Porting Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, AudioReach.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>