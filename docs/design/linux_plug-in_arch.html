

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Linux Plug-in Architecture &mdash; AudioReach Documentation 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/audioreach.css?v=cd7bb9cf" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=f2a433a1"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Linux ASoC Architecture" href="linux_asoc_arch.html" />
    <link rel="prev" title="Linux Adaptation Design" href="lx_design.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            AudioReach Documentation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../sdk_overview.html">AudioReach Project Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">AudioReach Designs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="arch_overview.html">AudioReach Architecture Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="design_concept.html">AudioReach Concept and Terminology</a></li>
<li class="toctree-l2"><a class="reference internal" href="arspf_design.html">AudioReach Engine</a></li>
<li class="toctree-l2"><a class="reference internal" href="args_design.html">AudioReach Graph Services</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpr_design.html">Generic Packet Router</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="lx_design.html">Linux Adaptation Design</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Linux Plug-in Architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#architecture">Architecture</a></li>
<li class="toctree-l4"><a class="reference internal" href="#audioreach-realization-through-alsa">AudioReach Realization through ALSA</a></li>
<li class="toctree-l4"><a class="reference internal" href="#guidelines-for-assigning-key-vectors-to-sub-graphs">Guidelines for assigning key vectors to sub-graphs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sample-graph-design-for-plug-in-architecture">Sample Graph Design for Plug-in Architecture</a></li>
<li class="toctree-l4"><a class="reference internal" href="#guide-to-setup-use-case-through-alsa">Guide to Setup Use Case through ALSA</a></li>
<li class="toctree-l4"><a class="reference internal" href="#playback-sssd">Playback SSSD</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="linux_asoc_arch.html">Linux ASoC Architecture</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="arc_design.html">AudioReach Creator Design</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">AudioReach APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev/index.html">AudioReach Developer Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platform/index.html">Platform Reference Guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">AudioReach Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">AudioReach Designs</a></li>
          <li class="breadcrumb-item"><a href="lx_design.html">Linux Adaptation Design</a></li>
      <li class="breadcrumb-item active">Linux Plug-in Architecture</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/design/linux_plug-in_arch.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="linux-plug-in-architecture">
<span id="lx-plugin-arch"></span><h1>Linux Plug-in Architecture<a class="headerlink" href="#linux-plug-in-architecture" title="Link to this heading"></a></h1>
<section id="architecture">
<h2>Architecture<a class="headerlink" href="#architecture" title="Link to this heading"></a></h2>
<section id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Link to this heading"></a></h3>
<p>AudioReach plug-in architecture for Linux is designed to enable genuine AudioReach development workflow and provide same richness of features AR has to offer. At the same time, plug-in architecture must be able to interoperate with well-established Linux audio frameworks and APIs in order to serve broad Linux ecosystem need. Particularly, ALSA support is available on most, if not all, of Linux-based platform
ubiquitously. Many applications and middleware have been developed to run on top of ALSA. Though plug-in architecture would not utilize kernel ALSA framework for DSP configuration, ALSA interface would
still be supported through plug-in approach. At the same time, plug-in architecture would still interface with kernel ALSA/ASoC framework for configuration of audio peripherals e.g mixed signal CODEC given many peripheral drivers have been developed as ASoC CODEC compliant drivers.</p>
<p>At high level, plug-in architecture can be seen consisting of five major pieces as depicted in figure below. First piece is a set of AudioReach kernel drivers responsible for establishing connection with
AudioReach engine in audio DSP through IPC driver and provide user-space interface to channel commands and events exchanged between user-space and ARE. Second piece is Linux implementation of OSAL providing OS services
to Audioreach Graph Services(ARGS). OSAL interfaces with AR kernel drivers in order to communicate with ARE in audio DSP. Third piece is a set of software modules which plug into tinyalsa, alsa lib and tinycompress libraries and
translate ALSA commands and constructs to ARGS commands and constructs for audio graph setup and configuration in the audio DSP. Fourth piece is Platform Adaptation Layer(PAL) which alleviates clients from managing low level use cases setup and sound devices configuration with GKV/CKV/TKV and invoking ALSA APIs. At last, fifth piece is adaptation layer to enable well-known audio middleware, such as PulseAudio, gain access to services exposed by PAL. At the same time, path which PulseAudio interfaces with ALSA library can still be supported with configuration data abstracted into Use Case Manager(UCM) file.</p>
<figure class="fig-center align-default" id="id3">
<img alt="../_images/arlinux_plugin_block.png" src="../_images/arlinux_plugin_block.png" />
<figcaption>
<p><span class="caption-text">Linux Plug-in Architecture Diagram</span><a class="headerlink" href="#id3" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="building-blocks">
<h3>Building Blocks<a class="headerlink" href="#building-blocks" title="Link to this heading"></a></h3>
<figure class="fig-center align-default" id="id4">
<img alt="../_images/tinyalsa_plugin_arch.png" src="../_images/tinyalsa_plugin_arch.png" />
<figcaption>
<p><span class="caption-text">TinyALSA Plug-in Architecture Diagram</span><a class="headerlink" href="#id4" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>PAL and other Applications</strong></p>
<p>PAL and other Applications are clients which interface to TinyALSA
APIs. These modules run it’s own process context as shown in the
diagram.</p>
<p><strong>PCM, Mixer, Compress</strong></p>
<p>PCM, Mixer and Compress blocks are the enhanced TinyALSA and
TinyCompress libraries with plugin support.</p>
<p><strong>SND Card Parser</strong></p>
<p>Parses card-defs.xml which contains definition of virtual cards and
devices. It is used by tinyalsa to create virtual mixer controls and
to get plugin library name associated with card/device. Card-defs.xml
contains details of different PCM/Compress nodes such as device id
and properties such as playback/record and session_mode.</p>
<p>Sample card-defs.xml entry:</p>
<div class="highlight-XML notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;card&gt;</span>
<span class="w">        </span><span class="nt">&lt;id&gt;</span>100<span class="nt">&lt;/id&gt;</span>
<span class="w">        </span><span class="nt">&lt;name&gt;</span>qcm6490virtualsndcard<span class="nt">&lt;/name&gt;</span>
<span class="w">        </span><span class="nt">&lt;pcm-device&gt;</span>
<span class="w">                </span><span class="nt">&lt;id&gt;</span>100<span class="nt">&lt;/id&gt;</span>
<span class="w">                </span><span class="nt">&lt;name&gt;</span>PCM100<span class="nt">&lt;/name&gt;</span>
<span class="w">                </span><span class="nt">&lt;pcm_plugin&gt;</span>
<span class="w">                        </span><span class="nt">&lt;so-name&gt;</span>libagm_pcm_plugin.so<span class="nt">&lt;/so-name&gt;</span>
<span class="w">                </span><span class="nt">&lt;/pcm_plugin&gt;</span>
<span class="w">                </span><span class="nt">&lt;props&gt;</span>
<span class="w">                        </span><span class="nt">&lt;playback&gt;</span>1<span class="nt">&lt;/playback&gt;</span>
<span class="w">                        </span><span class="nt">&lt;capture&gt;</span>0<span class="nt">&lt;/capture&gt;</span>
<span class="w">                </span><span class="nt">&lt;/props&gt;</span>
<span class="w">        </span><span class="nt">&lt;/pcm-device&gt;</span>

<span class="w">        </span><span class="nt">&lt;pcm-device&gt;</span>
<span class="w">                </span><span class="nt">&lt;id&gt;</span>101<span class="nt">&lt;/id&gt;</span>
<span class="w">                </span><span class="nt">&lt;name&gt;</span>PCM101<span class="nt">&lt;/name&gt;</span>
<span class="w">                </span><span class="nt">&lt;pcm_plugin&gt;</span>
<span class="w">                        </span><span class="nt">&lt;so-name&gt;</span>libagm_pcm_plugin.so<span class="nt">&lt;/so-name&gt;</span>
<span class="w">                </span><span class="nt">&lt;/pcm_plugin&gt;</span>
<span class="w">                </span><span class="nt">&lt;props&gt;</span>
<span class="w">                        </span><span class="nt">&lt;playback&gt;</span>0<span class="nt">&lt;/playback&gt;</span>
<span class="w">                        </span><span class="nt">&lt;capture&gt;</span>1<span class="nt">&lt;/capture&gt;</span>
<span class="w">                </span><span class="nt">&lt;/props&gt;</span>
<span class="w">        </span><span class="nt">&lt;/pcm-device&gt;</span>

<span class="w">        </span><span class="nt">&lt;mixer&gt;</span>
<span class="w">                </span><span class="nt">&lt;id&gt;</span>1<span class="nt">&lt;/id&gt;</span>
<span class="w">                </span><span class="nt">&lt;name&gt;</span>agm_mixer<span class="nt">&lt;/name&gt;</span>
<span class="w">                </span><span class="nt">&lt;mixer_plugin&gt;</span>
<span class="w">                        </span><span class="nt">&lt;so-name&gt;</span>libagm_mixer_plugin.so<span class="nt">&lt;/so-name&gt;</span>
<span class="w">                </span><span class="nt">&lt;/mixer_plugin&gt;</span>
<span class="w">        </span><span class="nt">&lt;/mixer&gt;</span>
<span class="nt">&lt;/card&gt;</span>
</pre></div>
</div>
<p><strong>PCM HW, Mixer HW, Compress HW</strong></p>
<p>PCM HW, Mixer HW and Compress HW blocks are the TinyALSA modules which
implement all ops to interface with established ALSA kernel ops and
interacts with Kernel ALSA drivers.</p>
<p><strong>PCM Plugin, Mixer Plugin, Compress Plugin</strong></p>
<p>PCM Plugin, Mixer Plugin and Compress Plugin blocks register callbacks
for all pcm, mixers and compressed ops to PCM, Mixer and Compress core
fwk module. These modules load the plugin .so and call plugin_init
function. and routes all pcm / mixer calls from application to plugin
specific implementation.</p>
<p><strong>TinyALSA PCM Plugin, TinyALSA Mixer Plugin, TinyALSA Compress
Plugin</strong></p>
<p>PCM , Mixer and Compress TinyALSA Plugins are TinyALSA plugins which
route all pcm, mixer and compress calls from application to plugin
specific implementation.</p>
<p><strong>Audio Graph Manager(AGM)</strong></p>
<p>AGM provides apis for mixer plugins, PCM and Compressed apis to setup
audio usecases. It runs as an audio service ( by
platform specific means such as init script) so it can cater multiple
tinyALSA clients.</p>
<p><strong>GSL</strong></p>
<p>GSL is the graph service library which is responsible for loading and
initialization of sub-graphs and graphs via Graph Key Vector, Graph
setup and Dynamic handling of the sub-graphs within the graph, Data
Command Management - Read/Write buffer and Calibration (Set Config/Get
Config) of the ARE Modules.</p>
<p><strong>AML</strong></p>
<p>ACDB Management library also known as ACDB SW provides get/set APIs to retrieve and
adjust data in the ACDB DATA files. Provides data abstractions and
organization for how calibration data is to be consumed by the Audio
Driver and it’s components.</p>
<p><strong>IPC</strong></p>
<p>GSL communicates over Generic Packet Router(GPR) protocol to communicate
messages with ARE. Since ARE runs on a different subsystem, GSL has
to communicate over a IPC layer. This IPC is implemented as a device
node which is opened by userspace Linux datalink layer.</p>
<p><strong>ASoC Drivers</strong></p>
<p>ASoC drivers are the ALSA compatible drivers which together form sound card with PCM devices
enumerated from ASoC dai links. Plug-in architecture bypasses ALSA framework for audio graph
setup/configuration in audio DSP and data interface. These dai links are meant to provide access
to hardware resources managed in the kernel like GPIOs, clocks and mixed signal CODEC.</p>
</section>
</section>
<section id="audioreach-realization-through-alsa">
<span id="ar-alsa-hld"></span><h2>AudioReach Realization through ALSA<a class="headerlink" href="#audioreach-realization-through-alsa" title="Link to this heading"></a></h2>
<p>ALSA dynamic PCM framework provides the ability to dynamically connect PCM front-end to
physical dai links as shown below. In the following example either or
both of PCM playback and compressed playback front end session can be
connected to either or both of Bluetooth and Analog codec physical link
by configuring the published mixer controls, widgets, routes, and etc.</p>
<figure class="fig-center align-default" id="id5">
<img alt="../_images/Topology-objects.png" src="../_images/Topology-objects.png" />
<figcaption>
<p><span class="caption-text">ARE Graph to ASoC DPCM Concept Diagram</span><a class="headerlink" href="#id5" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>AudioReach plug-in architecture for Linux gets the inspiration from ALSA DPCM framework to model audio graph in form of front-end and back-end.
Front-end PCM or compress ALSA devices can be connected to any of physical links often referred as back-ends. The details on
how the front ends and back ends are enumerated are covered in detail in the AGM and TinyALSA Plugin documentation.</p>
<p>In Audioreach plug-in architecture, audio graph is organized into following segments for both playback and recording generally. At the same
time, system designer can add additional subgraph type if deemed necessary for product</p>
<ul class="simple">
<li><p>Stream: this segment provides data write/read interface, performs decoding/encoding if data is compressed.</p></li>
<li><p>Stream Post/Pre-Processing(PP): this segment contains stream-based processing modules e.g equalizer</p></li>
<li><p>Per Stream Per Device(PSPD): this segment is meant to contain module converting stream media format to device media format</p></li>
<li><p>Device-PP: this segment consists of PP modules for sound device tuning. For example, DRC processing is important for speaker device</p></li>
<li><p>Device: hardware endpoint such as I2S port</p></li>
</ul>
<p>These segments are referred to sub-graphs in AudioReach terminology.
The front-end generally represents stream and stream PP subgraphs while back-end represents the
PSPD, device-PP, device sub-graphs. In plugin architecture, byte-based mixer controls associated with
front-end and back-end for clients to assign GKV and CKV as required metadata setup before starting PCM
device and device switch.</p>
<p>Once a front-end is connected to back-end through routing mixer control, full GKV is formed by concatenating
the subgraph GKVs and CKVs assigned through mixer controls. Upon opening of front-end PCM or compress device, AGM
invokes GSL API with concatenated GKV and CKV to set up the graph in ARE and apply calibration. At the same time, AGM opens
kernel pcm device corresponding to connected back-ends in order to kick off audio peripheral setup.
This mechanism serves as fundamental design for constructing AudioReach graphs through ALSA and enable full audio path including
SoC and audio peripherals.</p>
</section>
<section id="guidelines-for-assigning-key-vectors-to-sub-graphs">
<h2>Guidelines for assigning key vectors to sub-graphs<a class="headerlink" href="#guidelines-for-assigning-key-vectors-to-sub-graphs" title="Link to this heading"></a></h2>
<p>Based on the design described in previous section, the metadata(i.e the GKV and CKV) for FE and BE can be
specified on three segments. One metadata mixer control is associated with each segment.</p>
<ul class="simple">
<li><p>Stream - includes KVs for Stream, Stream PP subgraphs. The same KVs
can be used to specify Stream and Stream PP.</p></li>
<li><p>Device - includes KVs for HW EP related subgraphs or optionally can
also include Device PP subgraphs.</p></li>
<li><p>Stream Device - includes any subgraph in b/w stream and device
subgraphs. eg Device pp, PSPD,</p></li>
</ul>
</section>
<section id="sample-graph-design-for-plug-in-architecture">
<h2>Sample Graph Design for Plug-in Architecture<a class="headerlink" href="#sample-graph-design-for-plug-in-architecture" title="Link to this heading"></a></h2>
<section id="multi-streams-to-single-device-mssd-playback">
<h3>Multi-Streams to Single-Device(MSSD) Playback<a class="headerlink" href="#multi-streams-to-single-device-mssd-playback" title="Link to this heading"></a></h3>
<section id="graph-overview">
<h4>Graph Overview<a class="headerlink" href="#graph-overview" title="Link to this heading"></a></h4>
<figure class="fig-center align-default" id="id6">
<img alt="../_images/mssd_graph_example.png" src="../_images/mssd_graph_example.png" />
<figcaption>
<p><span class="caption-text">Sample Audio Graph for MSSD Scenario</span><a class="headerlink" href="#id6" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Figure depicts the reference design of audio graph for MSSD playback scenario. In this example, stream sub-graph and stream-PP sub graph are consolidated into just stream sub-graph. Stream subgraph consists of write shared memory endpoint, PCM decoder, PCM converter. Client passes PCM samples to write shared memory endpoint. PCM converter is put in place to convert PCM samples to format supported by the stream-specific post-processing modules if conversion is necessary. Output of stream subgraph is fed into stream-device subgraph which consists of media format converter(MFC). MFC is put in place to convert stream-leg PCM to device-leg PCM format. After conversion, output of stream-device sub-graph is fed into device PP subgraph for device-specific post-processing. Note that mixer is placed at the beginning of subgraph to mix input streams. Output of device PP subgraph is then feed into device subgraph containing hardware endpoint module such as I2S driver for eventual rendering out of SoC.</p>
</section>
<section id="key-vector-design">
<h4>Key Vector Design<a class="headerlink" href="#key-vector-design" title="Link to this heading"></a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Sub-graph</strong></p></th>
<th class="head"><p><strong>Keys</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Stream</p></td>
<td><div class="line-block">
<div class="line">Key = StreamRx - type of playback</div>
<div class="line">Key = Instance - instance of Playback</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>Stream Device</p></td>
<td><div class="line-block">
<div class="line">Key = StreamRx - type of playback</div>
<div class="line">Key = Device - logical sound device</div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>Device PP</p></td>
<td><div class="line-block">
<div class="line">Key = Device - logical sound device</div>
<div class="line">Key = DevicePP_rx - name of device PP set</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>Device</p></td>
<td><div class="line-block">
<div class="line">Key = Device - logical sound device</div>
</div>
</td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>MetaData Grouping</strong></p></th>
<th class="head"><p><strong>KV</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Stream1 Metadata</p></td>
<td><p>StreamRX1 KVs</p></td>
</tr>
<tr class="row-odd"><td><p>Stream2 Metadata</p></td>
<td><p>StreamRX2 KVs</p></td>
</tr>
<tr class="row-even"><td><p>Device Metadata</p></td>
<td><p>DeviceRX KVs</p></td>
</tr>
<tr class="row-odd"><td><p>Stream1 + Device Metadata</p></td>
<td><p>StreamRX1DeviceRX KVs, DeviceRX PP KVs</p></td>
</tr>
<tr class="row-even"><td><p>Stream2 + Device Metadata</p></td>
<td><p>StreamRX2DeviceRX KVs, DeviceRX PP KVs</p></td>
</tr>
</tbody>
</table>
<p><strong>GKV</strong></p>
<p>GKV1: &lt;StreamRX1 KVs, StreamRX2 PP KVs, StreamRX1DeviceRX KVs, DeviceRX
PP KVs, DeviceRX KVs&gt;</p>
<p>GKV2: &lt;StreamRX2 KVs, StreamRX2 PP KVs, StreamRX2DeviceRX KVs, DeviceRX
PP KVs, DeviceRX KVs&gt;</p>
</section>
</section>
<section id="single-stream-to-multi-device-ssmd-playback">
<h3>Single-Stream to Multi-Device(SSMD) Playback<a class="headerlink" href="#single-stream-to-multi-device-ssmd-playback" title="Link to this heading"></a></h3>
<section id="id1">
<h4>Graph Overview<a class="headerlink" href="#id1" title="Link to this heading"></a></h4>
<p>Figure depicts the reference design of audio graph for SSMD playback scenario. In essence, stream sub-graph is nearly identical to MSSD scenario except that additional splitter is added to end of stream subgraph so output can be routed to both stream-device sub-graphs for headphone and speaker respectively. Then, there are device PP and device sub-graphs for headphone and speaker respectively.</p>
<figure class="fig-center align-default" id="id7">
<img alt="../_images/ssmd_graph_example.png" src="../_images/ssmd_graph_example.png" />
<figcaption>
<p><span class="caption-text">Sample Audio Graph for SSMD Scenario</span><a class="headerlink" href="#id7" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="id2">
<h4>Key Vector Design<a class="headerlink" href="#id2" title="Link to this heading"></a></h4>
<p>Sub-graphs key vector design is the same as MSSD scenario.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>MetaData Grouping</strong></p></th>
<th class="head"><p><strong>KV</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Stream Metadata</p></td>
<td><p>StreamRX1 KVs</p></td>
</tr>
<tr class="row-odd"><td><p>Device1 Metadata</p></td>
<td><p>DeviceRX1 KVs</p></td>
</tr>
<tr class="row-even"><td><p>Device2 Metadata</p></td>
<td><p>DeviceRX2 KVs</p></td>
</tr>
<tr class="row-odd"><td><p>Stream + Device Metadata</p></td>
<td><p>StreamRXDeviceRX1 KVs, DeviceRX1 PP KVs</p></td>
</tr>
<tr class="row-even"><td><p>Stream + Device Metadata</p></td>
<td><p>StreamRXDeviceRX2 KVs, DeviceRX2 PP KVs</p></td>
</tr>
</tbody>
</table>
<p><strong>GKV</strong></p>
<p>GKV1: &lt;StreamRX KVs, StreamRX PP KVs, StreamRXDeviceRX1 KVs, DeviceRX1
PP KVs, DeviceRX1 KVs&gt;</p>
<p>GKV2: &lt;StreamRX KVs, StreamRX PP KVs, StreamRXDeviceRX2 KVs, DeviceRX2
PP KVs, DeviceRX2 KVs&gt;</p>
</section>
</section>
<section id="device-switch">
<h3>Device Switch<a class="headerlink" href="#device-switch" title="Link to this heading"></a></h3>
<p>Device switch describes the scenario when audio output is routed from one sound device to another sound device due to external event e.g end-user unplug headphone. In plug-in architecture, the mechanism is
tearing down device leg of audio graph and instantiate new device-leg sub-graphs to form new full audio graph. Figure below illustrates device switch from headphone to speaker. During device switch,
Stream-Device, Device PP, Device for headphone are teared down and new sub-graphs of same types for speakers are instantiated.</p>
<figure class="fig-center align-default" id="id8">
<a class="reference internal image-reference" href="../_images/device_switch_example.png"><img alt="../_images/device_switch_example.png" src="../_images/device_switch_example.png" style="width: 1236.95px; height: 595.4px;" />
</a>
<figcaption>
<p><span class="caption-text">Device Switch Example</span><a class="headerlink" href="#id8" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="guide-to-setup-use-case-through-alsa">
<h2>Guide to Setup Use Case through ALSA<a class="headerlink" href="#guide-to-setup-use-case-through-alsa" title="Link to this heading"></a></h2>
<section id="setup-sequence">
<h3>Setup Sequence<a class="headerlink" href="#setup-sequence" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p>Issue mixer control to set up routing inside audio peripheral</p></li>
<li><p>Issue mixer control to set media format of back-end</p></li>
<li><p>Issue mixer control to set meta data for device sub-graph</p></li>
<li><p>Issue mixer control to set meta data for Stream and Stream PP sub-graphs</p></li>
<li><p>Issue mixer control to set meta data for PSPD and Device PP sub-graphs</p></li>
<li><p>Issue mixer control to connect front-end to back-end</p></li>
<li><p>Invoke tinyalsa APIs to kick off use case</p></li>
</ol>
<div class="line-block">
<div class="line">pcm_open()</div>
<div class="line">pcm_prepare()</div>
<div class="line">pcm_start()</div>
<div class="line">pcm_write()/pcm_read()</div>
<div class="line"><br /></div>
</div>
</section>
<section id="shutdown-sequence">
<h3>Shutdown Sequence<a class="headerlink" href="#shutdown-sequence" title="Link to this heading"></a></h3>
<div class="line-block">
<div class="line">pcm_stop()</div>
<div class="line">pcm_close()</div>
<div class="line"><br /></div>
<div class="line">Issue mixer control to disconnect front-end to back-end</div>
<div class="line"><br /></div>
</div>
</section>
<section id="mixer-control-and-payload">
<h3>Mixer Control and Payload<a class="headerlink" href="#mixer-control-and-payload" title="Link to this heading"></a></h3>
<ul>
<li><p>Set backend pcm configuration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tinymix</span> <span class="s1">&#39;&lt;back-end name&gt; rate ch fmt&#39;</span> <span class="o">&lt;</span><span class="n">sample</span> <span class="n">rate</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">channel</span> <span class="n">count</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">PCM</span> <span class="nb">format</span> <span class="n">enum</span> <span class="n">value</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">data</span> <span class="nb">format</span><span class="o">&gt;</span>
</pre></div>
</div>
</li>
<li><p>Connect/Disconnect front-end to back-end:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tinymix</span> <span class="s1">&#39;PCM&lt;#&gt; connect&#39;</span> <span class="o">&lt;</span><span class="n">back</span><span class="o">-</span><span class="n">end</span> <span class="n">name</span><span class="o">&gt;</span>
<span class="n">tinymix</span> <span class="s1">&#39;PCM&lt;#&gt; disconnect&#39;</span> <span class="o">&lt;</span><span class="n">back</span><span class="o">-</span><span class="n">end</span> <span class="n">name</span><span class="o">&gt;</span>
</pre></div>
</div>
</li>
<li><p>Configure device meta data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tinymix</span> <span class="s1">&#39;&lt;back-end name&gt; metadata&#39;</span> <span class="o">&lt;</span><span class="n">meta</span> <span class="n">byte</span> <span class="n">payload</span><span class="o">&gt;</span>
</pre></div>
</div>
</li>
<li><p>Configure stream and stream PP subgraphs meta data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tinymix</span> <span class="s1">&#39;PCM&lt;#&gt; control&#39;</span> <span class="n">Zero</span>
<span class="n">tinymix</span> <span class="s1">&#39;PCM&lt;#&gt; metadata&#39;</span> <span class="o">&lt;</span><span class="n">meta</span> <span class="n">byte</span> <span class="n">payload</span><span class="o">&gt;</span>
</pre></div>
</div>
</li>
<li><p>Configure stream device and device PP subgraphs meta data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tinymix</span> <span class="s1">&#39;PCM&lt;#&gt; control&#39;</span> <span class="o">&lt;</span><span class="n">back</span><span class="o">-</span><span class="n">end</span> <span class="n">name</span><span class="o">&gt;</span>
<span class="n">tinymix</span> <span class="s1">&#39;PCM&lt;#&gt; metadata&#39;</span> <span class="o">&lt;</span><span class="n">meta</span> <span class="n">byte</span> <span class="n">payload</span><span class="o">&gt;</span>
</pre></div>
</div>
</li>
<li><p>&lt;PCM format enum value&gt;: This value is derived from ALSA asound.h SNDRV_PCM_FORMAT</p></li>
<li><p>&lt;back-end name&gt;: this string is derived from agm parsing /proc/asound/pcm to obtain all available hardware endpoint back-ends
available on given board</p></li>
<li><p>&lt;meta byte payload&gt;: agm_meta_data_gsl structure in below code snippet depicts the format of payload. Passing of sub-graph KVs and sub-graph CKV have been described previously. Along with GKV and CKV, there is portion of payload for passing property IDs. Currently, it is used only for aiding the device switch use case.</p></li>
</ul>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Key Vector</span>
<span class="cm"> */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">agm_key_vector_gsl</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_kvs</span><span class="p">;</span><span class="w">                 </span><span class="cm">/**&lt; number of key value pairs */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">agm_key_value</span><span class="w"> </span><span class="o">*</span><span class="n">kv</span><span class="p">;</span><span class="w">       </span><span class="cm">/**&lt; array of key value pairs */</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">sg_prop</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">prop_id</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">num_values</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">values</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm">  * Metadata Key Vectors</span>
<span class="cm">  */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">agm_meta_data_gsl</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Used to lookup the calibration data</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">agm_key_vector_gsl</span><span class="w"> </span><span class="n">gkv</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">    * Used to lookup the calibration data</span>
<span class="cm">    */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">agm_key_vector_gsl</span><span class="w"> </span><span class="n">ckv</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">    * Used to lookup the property ids</span>
<span class="cm">    */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sg_prop</span><span class="w"> </span><span class="n">sg_props</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="sample-mixer-control-setup-for-usecases">
<h3>Sample Mixer control setup for Usecases.<a class="headerlink" href="#sample-mixer-control-setup-for-usecases" title="Link to this heading"></a></h3>
</section>
</section>
<section id="playback-sssd">
<h2>Playback SSSD<a class="headerlink" href="#playback-sssd" title="Link to this heading"></a></h2>
<p><strong>Setup Sequence</strong></p>
<p><strong>‘CODEC_DMA-LPAIF_WSA-RX-0 rate ch fmt’ 48000 2 2(PCM_16) 1(FIXED_POINT)</strong></p>
<p><strong>‘CODEC_DMA-LPAIF_WSA-RX-0 metadata’ bytes</strong> //bytes representing KV
for device/optionally devicePP</p>
<div class="line-block">
<div class="line"><strong>‘PCM100 control’ Zero</strong> // sets the switch to indicate that further
mixer control configuration is for stream</div>
<div class="line"><strong>‘PCM100 metadata’ bytes</strong> //bytes representing KV for stream,
streamPP</div>
</div>
<div class="line-block">
<div class="line"><strong>‘PCM100 control’ CODEC_DMA-LPAIF_WSA-RX-0</strong> // sets the control to
indicate that further mixer control configuration is for graph
configuration b/w stream and device.</div>
<div class="line"><strong>‘PCM100 metadata’ bytes</strong> //bytes representing KV for
StreamDevice(PSPD), DevicePP subgraphs</div>
</div>
<p><strong>‘PCM100 getTaggedInfo’ bytes</strong> // to retrieve module tags, mid, iid
information for the GKV configured for PCM100
and CODEC_DMA-LPAIF_WSA-RX-0</p>
<div class="line-block">
<div class="line"><strong>‘PCM100 control’ Zero</strong> // sets the switch to indicate that further
mixer control configuration is for stream</div>
<div class="line"><strong>‘PCM100 setParam’ bytes</strong> //representing the configuration of modules
in the stream graph</div>
</div>
<div class="line-block">
<div class="line"><strong>‘PCM100 control’ CODEC_DMA-LPAIF_WSA-RX-0</strong> // sets the control to
indicate that further mixer control configuration is for graph
configuration b/w stream and device.</div>
<div class="line"><strong>‘PCM100 setParam’ bytes</strong> //bytes representing the configuration of
modules StreamDevice(PSPD), DevicePP subgraphs</div>
</div>
<p><strong>‘PCM100 connect’CODEC_DMA-LPAIF_WSA-RX-0</strong> // connects PCM100 to
CODEC_DMA-LPAIF_WSA-RX-0 AIF (front end to back end connection)</p>
<div class="line-block">
<div class="line"><strong>pcm_open()</strong></div>
<div class="line"><strong>pcm_prepare()</strong></div>
<div class="line"><strong>pcm_start()</strong></div>
<div class="line"><strong>pcm_write()/pcm_read()</strong></div>
</div>
<p><strong>Teardown Sequence</strong></p>
<p><strong>pcm_stop()</strong></p>
<p><strong>pcm_close()</strong></p>
<p><strong>‘PCM100 disconnect’ CODEC_DMA-LPAIF_WSA-RX-0 //</strong> connects PCM100
to CODEC_DMA-LPAIF_WSA-RX-0 AIF (front end to back end connection)</p>
<section id="playback-ssmd">
<h3>5.2. Playback SSMD<a class="headerlink" href="#playback-ssmd" title="Link to this heading"></a></h3>
<div class="line-block">
<div class="line"><strong>‘CODEC_DMA-LPAIF_WSA-RX-0 metadata’ bytes</strong> //bytes representing
KV for device/optionally devicePP</div>
<div class="line"><strong>‘PCM100 metadata’ bytes</strong> //bytes representing KV for stream,
streamPP</div>
</div>
<div class="line-block">
<div class="line"><strong>‘PCM100 control’ CODEC_DMA-LPAIF_WSA-RX-0</strong>// sets the control to
indicate that further mixer control configuration is for graph
configuration b/w stream and device.</div>
<div class="line"><strong>‘PCM100 metadata’ bytes</strong> //bytes representing KV for
StreamDevice(PSPD), DevicePP subgraphs</div>
</div>
<p><strong>‘PCM100 getTaggedInfo’ bytes</strong> // to retrieve module tags, mid, iid
information for a specific GKV</p>
<div class="line-block">
<div class="line"><strong>‘CODEC_DMA-LPAIF_WSA-RX-0 rate ch fmt’ 48000 2 2(PCM_16) 1(FIXED_POINT)</strong></div>
<div class="line"><strong>‘PCM100 control’ Zero</strong> // sets the control to indicate that further
mixer control configuration is for graph configuration b/w stream and
device.</div>
<div class="line"><strong>‘PCM100 setParam’ bytes</strong> //representing the configuration of
modules in the stream graph</div>
</div>
<div class="line-block">
<div class="line"><strong>‘PCM100 control’ CODEC_DMA-LPAIF_WSA-RX-0</strong> // sets the control to
indicate that further mixer control configuration is for graph
configuration b/w stream and device.</div>
<div class="line"><strong>‘PCM100 setParam’ bytes</strong> //bytes representing the configuration of
modules StreamDevice(PSPD), DevicePP subgraphs</div>
</div>
<p><strong>‘PCM100 connect’ CODEC_DMA-LPAIF_WSA-RX-0</strong> // connects PCM100 to
CODEC_DMA-LPAIF_WSA-RX-0 AIF</p>
<div class="line-block">
<div class="line"><strong>pcm_open()</strong></div>
<div class="line"><strong>pcm_prepare()</strong></div>
<div class="line"><strong>pcm_start()</strong></div>
<div class="line"><strong>pcm_write()/pcm_read()</strong></div>
</div>
<div class="line-block">
<div class="line"><strong>‘CODEC_DMA-LPAIF_WSA-RX-1 metadata’ bytes</strong> //bytes representing
KV for device/optionally devicePP</div>
<div class="line"><strong>‘PCM100 control’ CODEC_DMA-LPAIF_WSA-RX-1</strong>// sets the control to
indicate that further mixer control configuration is for graph
configuration b/w stream and device.</div>
</div>
<p><strong>‘PCM100 metadata’ bytes</strong> //bytes representing KV for
StreamDevice(PSPD), DevicePP subgraphs</p>
<p><strong>‘PCM100 getTaggedInfo’ bytes</strong> // to retrieve module tags, mid, iid
information for a specific GKV</p>
<div class="line-block">
<div class="line"><strong>‘CODEC_DMA-LPAIF_WSA-RX-1 rate ch fmt’ 96000 4 2(PCM_16) 1(FIXED_POINT)</strong></div>
<div class="line"><strong>‘PCM100 control’ CODEC_DMA-LPAIF_WSA-RX-1</strong> // sets the control to
indicate that further mixer control configuration is for graph
configuration b/w stream and device.</div>
</div>
<p><strong>‘PCM100 setParam’ bytes</strong> //bytes representing the configuration of
modules StreamDevice(PSPD), DevicePP subgraphs</p>
<p><strong>‘PCM100 connect’ CODEC_DMA-LPAIF_WSA-RX-1</strong> // connects PCM100 to
<strong>CODEC_DMA-LPAIF_WSA-RX-1</strong> AIF</p>
</section>
<section id="playback-mssd">
<h3>5.3. Playback MSSD<a class="headerlink" href="#playback-mssd" title="Link to this heading"></a></h3>
<div class="line-block">
<div class="line"><strong>‘SLIM_0_RX metadata’ bytes</strong> //bytes representing KV for
device/optionally devicePP</div>
<div class="line"><strong>‘PCM100 metadata’ bytes</strong> //bytes representing KV for stream,
streamPP</div>
</div>
<div class="line-block">
<div class="line"><strong>‘PCM100 control’ SLIM_0_RX</strong>// sets the control to indicate that
further mixer control configuration is for graph configuration b/w
stream and device.</div>
<div class="line"><strong>‘PCM100 metadata’ bytes</strong> //bytes representing KV for
StreamDevice(PSPD), DevicePP subgraphs</div>
</div>
<p><strong>‘PCM100 getTaggedInfo’ bytes</strong> // to retrieve module tags, mid, iid
information for a specific GKV</p>
<div class="line-block">
<div class="line"><strong>‘SLIM_0_RX rate ch fmt’ 48000, 2, 2(PCM_16) 1(FIXED_POINT)</strong></div>
<div class="line"><strong>‘PCM100 control’ Zero</strong> // sets the control to indicate that further
mixer control configuration is for graph configuration b/w stream and
device.</div>
<div class="line"><strong>‘PCM100 setParam’ bytes</strong> //representing the configuration of
modules in the stream graph</div>
</div>
<div class="line-block">
<div class="line"><strong>‘PCM100 control’ SLIM_0_RX</strong> // sets the control to indicate that
further mixer control configuration is for graph configuration b/w
stream and device.</div>
<div class="line"><strong>‘PCM100 setParam’ bytes</strong> //bytes representing the configuration of
modules StreamDevice(PSPD), DevicePP subgraphs</div>
</div>
<p><strong>‘PCM100 connect’ SLIM_0_RX</strong> // connects PCM100 to SLIM_0_RX AIF</p>
<div class="line-block">
<div class="line"><strong>pcm_open()</strong></div>
<div class="line"><strong>pcm_prepare()</strong></div>
<div class="line"><strong>pcm_start()</strong></div>
<div class="line"><strong>pcm_write()/pcm_read()</strong></div>
</div>
<p><strong>‘PCM101 metadata’ bytes</strong> //bytes representing KV for stream, streamPP</p>
<div class="line-block">
<div class="line"><strong>‘PCM101 control’ SLIM_0_RX</strong>// sets the control to indicate that
further mixer control configuration is for graph configuration b/w
stream and device.</div>
<div class="line"><strong>‘PCM101 metadata’ bytes</strong> //bytes representing KV for
StreamDevice(PSPD), DevicePP subgraphs</div>
</div>
<p><strong>‘PCM101 getTaggedInfo’ bytes</strong> // to retrieve module tags, mid, iid
information for a specific GKV</p>
<div class="line-block">
<div class="line"><strong>‘PCM101 control’ Zero</strong> // sets the control to indicate that further
mixer control configuration is for graph configuration b/w stream and
device.</div>
<div class="line"><strong>‘PCM101 setParam’ bytes</strong> //representing the configuration of
modules in the stream graph</div>
</div>
<div class="line-block">
<div class="line"><strong>‘PCM101 control’ SLIM_0_RX</strong> // sets the control to indicate that
further mixer control configuration is for graph configuration b/w
stream and device.</div>
<div class="line"><strong>‘PCM101 setParam’ bytes</strong> //bytes representing the configuration of
modules StreamDevice(PSPD), DevicePP subgraphs</div>
</div>
<p><strong>‘PCM101 connect’ SLIM_0_RX</strong> // connects PCM101 to SLIM_0_RX AIF</p>
<div class="line-block">
<div class="line"><strong>pcm_open()</strong></div>
<div class="line"><strong>pcm_prepare()</strong></div>
<div class="line"><strong>pcm_start()</strong></div>
<div class="line"><strong>pcm_write()/pcm_read()</strong></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lx_design.html" class="btn btn-neutral float-left" title="Linux Adaptation Design" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="linux_asoc_arch.html" class="btn btn-neutral float-right" title="Linux ASoC Architecture" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, AudioReach.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>